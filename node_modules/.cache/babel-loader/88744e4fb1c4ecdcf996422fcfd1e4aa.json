{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectWrapper;\n\nvar pool = require('typedarray-pool');\n\nvar sweep = require('./lib/sweep');\n\nvar boxIntersectIter = require('./lib/intersect');\n\nfunction boxEmpty(d, box) {\n  for (var j = 0; j < d; ++j) {\n    if (!(box[j] <= box[j + d])) {\n      return true;\n    }\n  }\n\n  return false;\n} //Unpack boxes into a flat typed array, remove empty boxes\n\n\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0;\n  var count = 0;\n\n  for (var i = 0, n = boxes.length; i < n; ++i) {\n    var b = boxes[i];\n\n    if (boxEmpty(d, b)) {\n      continue;\n    }\n\n    for (var j = 0; j < 2 * d; ++j) {\n      data[ptr++] = b[j];\n    }\n\n    ids[count++] = i;\n  }\n\n  return count;\n} //Perform type conversions, check bounds\n\n\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length;\n  var m = blue.length; //If either array is empty, then we can skip this whole thing\n\n  if (n <= 0 || m <= 0) {\n    return;\n  } //Compute dimension, if it is 0 then we skip\n\n\n  var d = red[0].length >>> 1;\n\n  if (d <= 0) {\n    return;\n  }\n\n  var retval; //Convert red boxes\n\n  var redList = pool.mallocDouble(2 * d * n);\n  var redIds = pool.mallocInt32(n);\n  n = convertBoxes(red, d, redList, redIds);\n\n  if (n > 0) {\n    if (d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n);\n      retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);\n    } else {\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2 * d * m);\n      var blueIds = pool.mallocInt32(m);\n      m = convertBoxes(blue, d, blueList, blueIds);\n\n      if (m > 0) {\n        sweep.init(n + m);\n\n        if (d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);\n        }\n\n        pool.free(blueList);\n        pool.free(blueIds);\n      }\n    }\n\n    pool.free(redList);\n    pool.free(redIds);\n  }\n\n  return retval;\n}\n\nvar RESULT;\n\nfunction appendItem(i, j) {\n  RESULT.push([i, j]);\n}\n\nfunction intersectFullArray(x) {\n  RESULT = [];\n  boxIntersect(x, x, appendItem, true);\n  return RESULT;\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = [];\n  boxIntersect(x, y, appendItem, false);\n  return RESULT;\n} //User-friendly wrapper, handle full input and no-visitor cases\n\n\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result;\n\n  switch (arguments.length) {\n    case 1:\n      return intersectFullArray(arg0);\n\n    case 2:\n      if (typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true);\n      } else {\n        return intersectBipartiteArray(arg0, arg1);\n      }\n\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false);\n\n    default:\n      throw new Error('box-intersect: Invalid arguments');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}