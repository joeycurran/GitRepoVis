{"ast":null,"code":"'use strict';\n\nmodule.exports = createCamera;\n\nvar now = require('right-now');\n\nvar createView = require('3d-view');\n\nvar mouseChange = require('mouse-change');\n\nvar mouseWheel = require('mouse-wheel');\n\nvar mouseOffset = require('mouse-event-offset');\n\nvar hasPassive = require('has-passive-events');\n\nfunction createCamera(element, options) {\n  element = element || document.body;\n  options = options || {};\n  var limits = [0.01, Infinity];\n\n  if ('distanceLimits' in options) {\n    limits[0] = options.distanceLimits[0];\n    limits[1] = options.distanceLimits[1];\n  }\n\n  if ('zoomMin' in options) {\n    limits[0] = options.zoomMin;\n  }\n\n  if ('zoomMax' in options) {\n    limits[1] = options.zoomMax;\n  }\n\n  var view = createView({\n    center: options.center || [0, 0, 0],\n    up: options.up || [0, 1, 0],\n    eye: options.eye || [0, 0, 10],\n    mode: options.mode || 'orbit',\n    distanceLimits: limits\n  });\n  var pmatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  var distance = 0.0;\n  var width = element.clientWidth;\n  var height = element.clientHeight;\n  var camera = {\n    keyBindingMode: 'rotate',\n    enableWheel: true,\n    view: view,\n    element: element,\n    delay: options.delay || 16,\n    rotateSpeed: options.rotateSpeed || 1,\n    zoomSpeed: options.zoomSpeed || 1,\n    translateSpeed: options.translateSpeed || 1,\n    flipX: !!options.flipX,\n    flipY: !!options.flipY,\n    modes: view.modes,\n    _ortho: options._ortho || options.projection && options.projection.type === 'orthographic' || false,\n    tick: function () {\n      var t = now();\n      var delay = this.delay;\n      var ctime = t - 2 * delay;\n      view.idle(t - delay);\n      view.recalcMatrix(ctime);\n      view.flush(t - (100 + delay * 2));\n      var allEqual = true;\n      var matrix = view.computedMatrix;\n\n      for (var i = 0; i < 16; ++i) {\n        allEqual = allEqual && pmatrix[i] === matrix[i];\n        pmatrix[i] = matrix[i];\n      }\n\n      var sizeChanged = element.clientWidth === width && element.clientHeight === height;\n      width = element.clientWidth;\n      height = element.clientHeight;\n\n      if (allEqual) {\n        return !sizeChanged;\n      }\n\n      distance = Math.exp(view.computedRadius[0]);\n      return true;\n    },\n    lookAt: function (eye, center, up) {\n      view.lookAt(view.lastT(), eye, center, up);\n    },\n    rotate: function (pitch, yaw, roll) {\n      view.rotate(view.lastT(), pitch, yaw, roll);\n    },\n    pan: function (dx, dy, dz) {\n      view.pan(view.lastT(), dx, dy, dz);\n    },\n    translate: function (dx, dy, dz) {\n      view.translate(view.lastT(), dx, dy, dz);\n    }\n  };\n  Object.defineProperties(camera, {\n    matrix: {\n      get: function () {\n        return view.computedMatrix;\n      },\n      set: function (mat) {\n        view.setMatrix(view.lastT(), mat);\n        return view.computedMatrix;\n      },\n      enumerable: true\n    },\n    mode: {\n      get: function () {\n        return view.getMode();\n      },\n      set: function (mode) {\n        var curUp = view.computedUp.slice();\n        var curEye = view.computedEye.slice();\n        var curCenter = view.computedCenter.slice();\n        view.setMode(mode);\n\n        if (mode === 'turntable') {\n          // Hacky time warping stuff to generate smooth animation\n          var t0 = now();\n\n          view._active.lookAt(t0, curEye, curCenter, curUp);\n\n          view._active.lookAt(t0 + 500, curEye, curCenter, [0, 0, 1]);\n\n          view._active.flush(t0);\n        }\n\n        return view.getMode();\n      },\n      enumerable: true\n    },\n    center: {\n      get: function () {\n        return view.computedCenter;\n      },\n      set: function (ncenter) {\n        view.lookAt(view.lastT(), null, ncenter);\n        return view.computedCenter;\n      },\n      enumerable: true\n    },\n    eye: {\n      get: function () {\n        return view.computedEye;\n      },\n      set: function (neye) {\n        view.lookAt(view.lastT(), neye);\n        return view.computedEye;\n      },\n      enumerable: true\n    },\n    up: {\n      get: function () {\n        return view.computedUp;\n      },\n      set: function (nup) {\n        view.lookAt(view.lastT(), null, null, nup);\n        return view.computedUp;\n      },\n      enumerable: true\n    },\n    distance: {\n      get: function () {\n        return distance;\n      },\n      set: function (d) {\n        view.setDistance(view.lastT(), d);\n        return d;\n      },\n      enumerable: true\n    },\n    distanceLimits: {\n      get: function () {\n        return view.getDistanceLimits(limits);\n      },\n      set: function (v) {\n        view.setDistanceLimits(v);\n        return v;\n      },\n      enumerable: true\n    }\n  });\n  element.addEventListener('contextmenu', function (ev) {\n    ev.preventDefault();\n    return false;\n  });\n  camera._lastX = -1;\n  camera._lastY = -1;\n  camera._lastMods = {\n    shift: false,\n    control: false,\n    alt: false,\n    meta: false\n  };\n\n  camera.enableMouseListeners = function () {\n    camera.mouseListener = mouseChange(element, handleInteraction); //enable simple touch interactions\n\n    element.addEventListener('touchstart', function (ev) {\n      var xy = mouseOffset(ev.changedTouches[0], element);\n      handleInteraction(0, xy[0], xy[1], camera._lastMods);\n      handleInteraction(1, xy[0], xy[1], camera._lastMods);\n      ev.preventDefault();\n    }, hasPassive ? {\n      passive: false\n    } : false);\n    element.addEventListener('touchmove', function (ev) {\n      var xy = mouseOffset(ev.changedTouches[0], element);\n      handleInteraction(1, xy[0], xy[1], camera._lastMods);\n      ev.preventDefault();\n    }, hasPassive ? {\n      passive: false\n    } : false);\n    element.addEventListener('touchend', function (ev) {\n      handleInteraction(0, camera._lastX, camera._lastY, camera._lastMods);\n      ev.preventDefault();\n    }, hasPassive ? {\n      passive: false\n    } : false);\n\n    function handleInteraction(buttons, x, y, mods) {\n      var keyBindingMode = camera.keyBindingMode;\n      if (keyBindingMode === false) return;\n      var rotate = keyBindingMode === 'rotate';\n      var pan = keyBindingMode === 'pan';\n      var zoom = keyBindingMode === 'zoom';\n      var ctrl = !!mods.control;\n      var alt = !!mods.alt;\n      var shift = !!mods.shift;\n      var left = !!(buttons & 1);\n      var right = !!(buttons & 2);\n      var middle = !!(buttons & 4);\n      var scale = 1.0 / element.clientHeight;\n      var dx = scale * (x - camera._lastX);\n      var dy = scale * (y - camera._lastY);\n      var flipX = camera.flipX ? 1 : -1;\n      var flipY = camera.flipY ? 1 : -1;\n      var drot = Math.PI * camera.rotateSpeed;\n      var t = now();\n\n      if (camera._lastX !== -1 && camera._lastY !== -1) {\n        if (rotate && left && !ctrl && !alt && !shift || left && !ctrl && !alt && shift) {\n          // Rotate\n          view.rotate(t, flipX * drot * dx, -flipY * drot * dy, 0);\n        }\n\n        if (pan && left && !ctrl && !alt && !shift || right || left && ctrl && !alt && !shift) {\n          // Pan\n          view.pan(t, -camera.translateSpeed * dx * distance, camera.translateSpeed * dy * distance, 0);\n        }\n\n        if (zoom && left && !ctrl && !alt && !shift || middle || left && !ctrl && alt && !shift) {\n          // Zoom\n          var kzoom = -camera.zoomSpeed * dy / window.innerHeight * (t - view.lastT()) * 100;\n          view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n        }\n      }\n\n      camera._lastX = x;\n      camera._lastY = y;\n      camera._lastMods = mods;\n      return true;\n    }\n\n    camera.wheelListener = mouseWheel(element, function (dx, dy) {\n      // TODO remove now that we can disable scroll via scrollZoom?\n      if (camera.keyBindingMode === false) return;\n      if (!camera.enableWheel) return;\n      var flipX = camera.flipX ? 1 : -1;\n      var flipY = camera.flipY ? 1 : -1;\n      var t = now();\n\n      if (Math.abs(dx) > Math.abs(dy)) {\n        view.rotate(t, 0, 0, -dx * flipX * Math.PI * camera.rotateSpeed / window.innerWidth);\n      } else {\n        if (!camera._ortho) {\n          var kzoom = -camera.zoomSpeed * flipY * dy / window.innerHeight * (t - view.lastT()) / 20.0;\n          view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n        }\n      }\n    }, true);\n  };\n\n  camera.enableMouseListeners();\n  return camera;\n}","map":null,"metadata":{},"sourceType":"script"}