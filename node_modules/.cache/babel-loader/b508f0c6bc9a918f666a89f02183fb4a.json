{"ast":null,"code":"'use strict';\n\nmodule.exports = createGLPlot2D;\n\nvar createPick = require('gl-select-static');\n\nvar createGrid = require('./lib/grid');\n\nvar createText = require('./lib/text');\n\nvar createLine = require('./lib/line');\n\nvar createBox = require('./lib/box');\n\nfunction GLPlot2D(gl, pickBuffer) {\n  this.gl = gl;\n  this.pickBuffer = pickBuffer;\n  this.screenBox = [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight];\n  this.viewBox = [0, 0, 0, 0];\n  this.dataBox = [-10, -10, 10, 10];\n  this.gridLineEnable = [true, true];\n  this.gridLineWidth = [1, 1];\n  this.gridLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];\n  this.pixelRatio = 1;\n  this.tickMarkLength = [0, 0, 0, 0];\n  this.tickMarkWidth = [0, 0, 0, 0];\n  this.tickMarkColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.tickPad = [15, 15, 15, 15];\n  this.tickAngle = [0, 0, 0, 0];\n  this.tickEnable = [true, true, true, true];\n  this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.labelPad = [15, 15, 15, 15];\n  this.labelAngle = [0, Math.PI / 2, 0, 3.0 * Math.PI / 2];\n  this.labelEnable = [true, true, true, true];\n  this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.titleCenter = [0, 0];\n  this.titleEnable = true;\n  this.titleAngle = 0;\n  this.titleColor = [0, 0, 0, 1];\n  this.borderColor = [0, 0, 0, 0];\n  this.backgroundColor = [0, 0, 0, 0];\n  this.zeroLineEnable = [true, true];\n  this.zeroLineWidth = [4, 4];\n  this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];\n  this.borderLineEnable = [true, true, true, true];\n  this.borderLineWidth = [2, 2, 2, 2];\n  this.borderLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]; //Drawing parameters\n\n  this.grid = null;\n  this.text = null;\n  this.line = null;\n  this.box = null;\n  this.objects = [];\n  this.overlays = [];\n  this._tickBounds = [Infinity, Infinity, -Infinity, -Infinity];\n  this.static = false;\n  this.dirty = false;\n  this.pickDirty = false;\n  this.pickDelay = 120;\n  this.pickRadius = 10;\n  this._pickTimeout = null;\n  this._drawPick = this.drawPick.bind(this);\n  this._depthCounter = 0;\n}\n\nvar proto = GLPlot2D.prototype;\n\nproto.setDirty = function () {\n  this.dirty = this.pickDirty = true;\n};\n\nproto.setOverlayDirty = function () {\n  this.dirty = true;\n};\n\nproto.nextDepthValue = function () {\n  return this._depthCounter++ / 65536.0;\n};\n\nfunction lerp(a, b, t) {\n  var s = 0.5 * (t + 1.0);\n  return Math.floor((1.0 - s) * a + s * b) | 0;\n}\n\nproto.draw = function () {\n  var TICK_MARK_BOX = [0, 0, 0, 0];\n  return function () {\n    var gl = this.gl;\n    var screenBox = this.screenBox;\n    var viewPixels = this.viewBox;\n    var dataBox = this.dataBox;\n    var pixelRatio = this.pixelRatio;\n    var grid = this.grid;\n    var line = this.line;\n    var text = this.text;\n    var objects = this.objects;\n    this._depthCounter = 0;\n\n    if (this.pickDirty) {\n      if (this._pickTimeout) {\n        clearTimeout(this._pickTimeout);\n      }\n\n      this.pickDirty = false;\n      this._pickTimeout = setTimeout(this._drawPick, this.pickDelay);\n    }\n\n    if (!this.dirty) {\n      return;\n    }\n\n    this.dirty = false;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null); //Turn on scissor\n\n    gl.enable(gl.SCISSOR_TEST); //Turn off depth buffer\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LESS);\n    gl.depthMask(false); //Configure premultiplied alpha blending\n\n    gl.enable(gl.BLEND);\n    gl.blendEquation(gl.FUNC_ADD, gl.FUNC_ADD);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); //Draw border\n\n    if (this.borderColor) {\n      gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);\n      var borderColor = this.borderColor;\n      gl.clearColor(borderColor[0] * borderColor[3], borderColor[1] * borderColor[3], borderColor[2] * borderColor[3], borderColor[3]);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    } //Draw center pane\n\n\n    gl.scissor(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);\n    gl.viewport(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);\n    var backgroundColor = this.backgroundColor;\n    gl.clearColor(backgroundColor[0] * backgroundColor[3], backgroundColor[1] * backgroundColor[3], backgroundColor[2] * backgroundColor[3], backgroundColor[3]);\n    gl.clear(gl.COLOR_BUFFER_BIT); //Draw grid\n\n    grid.draw(); //Draw zero lines separately\n\n    var zeroLineEnable = this.zeroLineEnable;\n    var zeroLineColor = this.zeroLineColor;\n    var zeroLineWidth = this.zeroLineWidth;\n\n    if (zeroLineEnable[0] || zeroLineEnable[1]) {\n      line.bind();\n\n      for (var i = 0; i < 2; ++i) {\n        if (!zeroLineEnable[i] || !(dataBox[i] <= 0 && dataBox[i + 2] >= 0)) {\n          continue;\n        }\n\n        var zeroIntercept = screenBox[i] - dataBox[i] * (screenBox[i + 2] - screenBox[i]) / (dataBox[i + 2] - dataBox[i]);\n\n        if (i === 0) {\n          line.drawLine(zeroIntercept, screenBox[1], zeroIntercept, screenBox[3], zeroLineWidth[i], zeroLineColor[i]);\n        } else {\n          line.drawLine(screenBox[0], zeroIntercept, screenBox[2], zeroIntercept, zeroLineWidth[i], zeroLineColor[i]);\n        }\n      }\n    } //Draw traces\n\n\n    for (var i = 0; i < objects.length; ++i) {\n      objects[i].draw();\n    } //Return viewport to default\n\n\n    gl.viewport(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);\n    gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]); //Draw tick marks\n\n    this.grid.drawTickMarks(); //Draw line elements\n\n    line.bind(); //Draw border lines\n\n    var borderLineEnable = this.borderLineEnable;\n    var borderLineWidth = this.borderLineWidth;\n    var borderLineColor = this.borderLineColor;\n\n    if (borderLineEnable[1]) {\n      line.drawLine(viewPixels[0], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[0], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[1], borderLineColor[1]);\n    }\n\n    if (borderLineEnable[0]) {\n      line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[1], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[1], borderLineWidth[0], borderLineColor[0]);\n    }\n\n    if (borderLineEnable[3]) {\n      line.drawLine(viewPixels[2], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[2], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[3], borderLineColor[3]);\n    }\n\n    if (borderLineEnable[2]) {\n      line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[3], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[3], borderLineWidth[2], borderLineColor[2]);\n    } //Draw text elements\n\n\n    text.bind();\n\n    for (var i = 0; i < 2; ++i) {\n      text.drawTicks(i);\n    }\n\n    if (this.titleEnable) {\n      text.drawTitle();\n    } //Draw other overlay elements (select boxes, etc.)\n\n\n    var overlays = this.overlays;\n\n    for (var i = 0; i < overlays.length; ++i) {\n      overlays[i].draw();\n    } //Turn off scissor test\n\n\n    gl.disable(gl.SCISSOR_TEST);\n    gl.disable(gl.BLEND);\n    gl.depthMask(true);\n  };\n}();\n\nproto.drawPick = function () {\n  return function () {\n    if (this.static) return;\n    var pickBuffer = this.pickBuffer;\n    var gl = this.gl;\n    this._pickTimeout = null;\n    pickBuffer.begin();\n    var pickOffset = 1;\n    var objects = this.objects;\n\n    for (var i = 0; i < objects.length; ++i) {\n      pickOffset = objects[i].drawPick(pickOffset);\n    }\n\n    pickBuffer.end();\n  };\n}();\n\nproto.pick = function () {\n  return function (x, y) {\n    if (this.static) return;\n    var pixelRatio = this.pixelRatio;\n    var pickPixelRatio = this.pickPixelRatio;\n    var viewBox = this.viewBox;\n    var scrX = Math.round((x - viewBox[0] / pixelRatio) * pickPixelRatio) | 0;\n    var scrY = Math.round((y - viewBox[1] / pixelRatio) * pickPixelRatio) | 0;\n    var pickResult = this.pickBuffer.query(scrX, scrY, this.pickRadius);\n\n    if (!pickResult) {\n      return null;\n    }\n\n    var pickValue = pickResult.id + (pickResult.value[0] << 8) + (pickResult.value[1] << 16) + (pickResult.value[2] << 24);\n    var objects = this.objects;\n\n    for (var i = 0; i < objects.length; ++i) {\n      var result = objects[i].pick(scrX, scrY, pickValue);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n}();\n\nfunction deepClone(array) {\n  var result = array.slice();\n\n  for (var i = 0; i < result.length; ++i) {\n    result[i] = result[i].slice();\n  }\n\n  return result;\n}\n\nfunction compareTicks(a, b) {\n  return a.x - b.x;\n}\n\nproto.setScreenBox = function (nbox) {\n  var screenBox = this.screenBox;\n  var pixelRatio = this.pixelRatio;\n  screenBox[0] = Math.round(nbox[0] * pixelRatio) | 0;\n  screenBox[1] = Math.round(nbox[1] * pixelRatio) | 0;\n  screenBox[2] = Math.round(nbox[2] * pixelRatio) | 0;\n  screenBox[3] = Math.round(nbox[3] * pixelRatio) | 0;\n  this.setDirty();\n};\n\nproto.setDataBox = function (nbox) {\n  var dataBox = this.dataBox;\n  var different = dataBox[0] !== nbox[0] || dataBox[1] !== nbox[1] || dataBox[2] !== nbox[2] || dataBox[3] !== nbox[3];\n\n  if (different) {\n    dataBox[0] = nbox[0];\n    dataBox[1] = nbox[1];\n    dataBox[2] = nbox[2];\n    dataBox[3] = nbox[3];\n    this.setDirty();\n  }\n};\n\nproto.setViewBox = function (nbox) {\n  var pixelRatio = this.pixelRatio;\n  var viewBox = this.viewBox;\n  viewBox[0] = Math.round(nbox[0] * pixelRatio) | 0;\n  viewBox[1] = Math.round(nbox[1] * pixelRatio) | 0;\n  viewBox[2] = Math.round(nbox[2] * pixelRatio) | 0;\n  viewBox[3] = Math.round(nbox[3] * pixelRatio) | 0;\n  var pickPixelRatio = this.pickPixelRatio;\n  this.pickBuffer.shape = [Math.round((nbox[2] - nbox[0]) * pickPixelRatio) | 0, Math.round((nbox[3] - nbox[1]) * pickPixelRatio) | 0];\n  this.setDirty();\n};\n\nproto.update = function (options) {\n  options = options || {};\n  var gl = this.gl;\n  this.pixelRatio = options.pixelRatio || 1;\n  var pixelRatio = this.pixelRatio;\n  this.pickPixelRatio = Math.max(pixelRatio, 1);\n  this.setScreenBox(options.screenBox || [0, 0, gl.drawingBufferWidth / pixelRatio, gl.drawingBufferHeight / pixelRatio]);\n  var screenBox = this.screenBox;\n  this.setViewBox(options.viewBox || [0.125 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.125 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio, 0.875 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.875 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio]);\n  var viewBox = this.viewBox;\n  var aspectRatio = (viewBox[2] - viewBox[0]) / (viewBox[3] - viewBox[1]);\n  this.setDataBox(options.dataBox || [-10, -10 / aspectRatio, 10, 10 / aspectRatio]);\n  this.borderColor = options.borderColor !== false ? (options.borderColor || [0, 0, 0, 0]).slice() : false;\n  this.backgroundColor = (options.backgroundColor || [0, 0, 0, 0]).slice();\n  this.gridLineEnable = (options.gridLineEnable || [true, true]).slice();\n  this.gridLineWidth = (options.gridLineWidth || [1, 1]).slice();\n  this.gridLineColor = deepClone(options.gridLineColor || [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]);\n  this.zeroLineEnable = (options.zeroLineEnable || [true, true]).slice();\n  this.zeroLineWidth = (options.zeroLineWidth || [4, 4]).slice();\n  this.zeroLineColor = deepClone(options.zeroLineColor || [[0, 0, 0, 1], [0, 0, 0, 1]]);\n  this.tickMarkLength = (options.tickMarkLength || [0, 0, 0, 0]).slice();\n  this.tickMarkWidth = (options.tickMarkWidth || [0, 0, 0, 0]).slice();\n  this.tickMarkColor = deepClone(options.tickMarkColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n  this.titleCenter = (options.titleCenter || [0.5 * (viewBox[0] + viewBox[2]) / pixelRatio, (viewBox[3] + 120) / pixelRatio]).slice();\n  this.titleEnable = !('titleEnable' in options) || !!options.titleEnable;\n  this.titleAngle = options.titleAngle || 0;\n  this.titleColor = (options.titleColor || [0, 0, 0, 1]).slice();\n  this.labelPad = (options.labelPad || [15, 15, 15, 15]).slice();\n  this.labelAngle = (options.labelAngle || [0, Math.PI / 2, 0, 3.0 * Math.PI / 2]).slice();\n  this.labelEnable = (options.labelEnable || [true, true, true, true]).slice();\n  this.labelColor = deepClone(options.labelColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n  this.tickPad = (options.tickPad || [15, 15, 15, 15]).slice();\n  this.tickAngle = (options.tickAngle || [0, 0, 0, 0]).slice();\n  this.tickEnable = (options.tickEnable || [true, true, true, true]).slice();\n  this.tickColor = deepClone(options.tickColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n  this.borderLineEnable = (options.borderLineEnable || [true, true, true, true]).slice();\n  this.borderLineWidth = (options.borderLineWidth || [2, 2, 2, 2]).slice();\n  this.borderLineColor = deepClone(options.borderLineColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n  var ticks = options.ticks || [[], []]; //Compute bounds on ticks\n\n  var bounds = this._tickBounds;\n  bounds[0] = bounds[1] = Infinity;\n  bounds[2] = bounds[3] = -Infinity;\n\n  for (var i = 0; i < 2; ++i) {\n    var axisTicks = ticks[i].slice(0);\n\n    if (axisTicks.length === 0) {\n      continue;\n    }\n\n    axisTicks.sort(compareTicks);\n    bounds[i] = Math.min(bounds[i], axisTicks[0].x);\n    bounds[i + 2] = Math.max(bounds[i + 2], axisTicks[axisTicks.length - 1].x);\n  } //Update grid\n\n\n  this.grid.update({\n    bounds: bounds,\n    ticks: ticks\n  }); //Update text\n\n  this.text.update({\n    bounds: bounds,\n    ticks: ticks,\n    labels: options.labels || ['x', 'y'],\n    labelSize: options.labelSize || [12, 12],\n    labelFont: options.labelFont || ['sans-serif', 'sans-serif'],\n    title: options.title || '',\n    titleSize: options.titleSize || 18,\n    titleFont: options.titleFont || 'sans-serif'\n  });\n  this.static = !!options.static;\n  this.setDirty();\n};\n\nproto.dispose = function () {\n  this.box.dispose();\n  this.grid.dispose();\n  this.text.dispose();\n  this.line.dispose();\n\n  for (var i = this.objects.length - 1; i >= 0; --i) {\n    this.objects[i].dispose();\n  }\n\n  this.objects.length = 0;\n\n  for (var i = this.overlays.length - 1; i >= 0; --i) {\n    this.overlays[i].dispose();\n  }\n\n  this.overlays.length = 0;\n  this.gl = null;\n};\n\nproto.addObject = function (object) {\n  if (this.objects.indexOf(object) < 0) {\n    this.objects.push(object);\n    this.setDirty();\n  }\n};\n\nproto.removeObject = function (object) {\n  var objects = this.objects;\n\n  for (var i = 0; i < objects.length; ++i) {\n    if (objects[i] === object) {\n      objects.splice(i, 1);\n      this.setDirty();\n      break;\n    }\n  }\n};\n\nproto.addOverlay = function (object) {\n  if (this.overlays.indexOf(object) < 0) {\n    this.overlays.push(object);\n    this.setOverlayDirty();\n  }\n};\n\nproto.removeOverlay = function (object) {\n  var objects = this.overlays;\n\n  for (var i = 0; i < objects.length; ++i) {\n    if (objects[i] === object) {\n      objects.splice(i, 1);\n      this.setOverlayDirty();\n      break;\n    }\n  }\n};\n\nfunction createGLPlot2D(options) {\n  var gl = options.gl;\n  var pickBuffer = createPick(gl, [gl.drawingBufferWidth, gl.drawingBufferHeight]);\n  var plot = new GLPlot2D(gl, pickBuffer);\n  plot.grid = createGrid(plot);\n  plot.text = createText(plot);\n  plot.line = createLine(plot);\n  plot.box = createBox(plot);\n  plot.update(options);\n  return plot;\n}","map":null,"metadata":{},"sourceType":"script"}