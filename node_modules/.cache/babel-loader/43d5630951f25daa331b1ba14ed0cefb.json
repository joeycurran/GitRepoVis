{"ast":null,"code":"\"use strict\";\n\nvar robustDot = require(\"robust-dot-product\");\n\nvar robustSum = require(\"robust-sum\");\n\nmodule.exports = splitPolygon;\nmodule.exports.positive = positive;\nmodule.exports.negative = negative;\n\nfunction planeT(p, plane) {\n  var r = robustSum(robustDot(p, plane), [plane[plane.length - 1]]);\n  return r[r.length - 1];\n} //Can't do this exactly and emit a floating point result\n\n\nfunction lerpW(a, wa, b, wb) {\n  var d = wb - wa;\n  var t = -wa / d;\n\n  if (t < 0.0) {\n    t = 0.0;\n  } else if (t > 1.0) {\n    t = 1.0;\n  }\n\n  var ti = 1.0 - t;\n  var n = a.length;\n  var r = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    r[i] = t * a[i] + ti * b[i];\n  }\n\n  return r;\n}\n\nfunction splitPolygon(points, plane) {\n  var pos = [];\n  var neg = [];\n  var a = planeT(points[points.length - 1], plane);\n\n  for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n    t = points[i];\n    var b = planeT(t, plane);\n\n    if (a < 0 && b > 0 || a > 0 && b < 0) {\n      var p = lerpW(s, b, t, a);\n      pos.push(p);\n      neg.push(p.slice());\n    }\n\n    if (b < 0) {\n      neg.push(t.slice());\n    } else if (b > 0) {\n      pos.push(t.slice());\n    } else {\n      pos.push(t.slice());\n      neg.push(t.slice());\n    }\n\n    a = b;\n  }\n\n  return {\n    positive: pos,\n    negative: neg\n  };\n}\n\nfunction positive(points, plane) {\n  var pos = [];\n  var a = planeT(points[points.length - 1], plane);\n\n  for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n    t = points[i];\n    var b = planeT(t, plane);\n\n    if (a < 0 && b > 0 || a > 0 && b < 0) {\n      pos.push(lerpW(s, b, t, a));\n    }\n\n    if (b >= 0) {\n      pos.push(t.slice());\n    }\n\n    a = b;\n  }\n\n  return pos;\n}\n\nfunction negative(points, plane) {\n  var neg = [];\n  var a = planeT(points[points.length - 1], plane);\n\n  for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n    t = points[i];\n    var b = planeT(t, plane);\n\n    if (a < 0 && b > 0 || a > 0 && b < 0) {\n      neg.push(lerpW(s, b, t, a));\n    }\n\n    if (b <= 0) {\n      neg.push(t.slice());\n    }\n\n    a = b;\n  }\n\n  return neg;\n}","map":null,"metadata":{},"sourceType":"script"}