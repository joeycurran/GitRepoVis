{"ast":null,"code":"'use strict';\n\nmodule.exports = createTurntableController;\n\nvar filterVector = require('filtered-vector');\n\nvar invert44 = require('gl-mat4/invert');\n\nvar rotateM = require('gl-mat4/rotate');\n\nvar cross = require('gl-vec3/cross');\n\nvar normalize3 = require('gl-vec3/normalize');\n\nvar dot3 = require('gl-vec3/dot');\n\nfunction len3(x, y, z) {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n}\n\nfunction clamp1(x) {\n  return Math.min(1.0, Math.max(-1.0, x));\n}\n\nfunction findOrthoPair(v) {\n  var vx = Math.abs(v[0]);\n  var vy = Math.abs(v[1]);\n  var vz = Math.abs(v[2]);\n  var u = [0, 0, 0];\n\n  if (vx > Math.max(vy, vz)) {\n    u[2] = 1;\n  } else if (vy > Math.max(vx, vz)) {\n    u[0] = 1;\n  } else {\n    u[1] = 1;\n  }\n\n  var vv = 0;\n  var uv = 0;\n\n  for (var i = 0; i < 3; ++i) {\n    vv += v[i] * v[i];\n    uv += u[i] * v[i];\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    u[i] -= uv / vv * v[i];\n  }\n\n  normalize3(u, u);\n  return u;\n}\n\nfunction TurntableController(zoomMin, zoomMax, center, up, right, radius, theta, phi) {\n  this.center = filterVector(center);\n  this.up = filterVector(up);\n  this.right = filterVector(right);\n  this.radius = filterVector([radius]);\n  this.angle = filterVector([theta, phi]);\n  this.angle.bounds = [[-Infinity, -Math.PI / 2], [Infinity, Math.PI / 2]];\n  this.setDistanceLimits(zoomMin, zoomMax);\n  this.computedCenter = this.center.curve(0);\n  this.computedUp = this.up.curve(0);\n  this.computedRight = this.right.curve(0);\n  this.computedRadius = this.radius.curve(0);\n  this.computedAngle = this.angle.curve(0);\n  this.computedToward = [0, 0, 0];\n  this.computedEye = [0, 0, 0];\n  this.computedMatrix = new Array(16);\n\n  for (var i = 0; i < 16; ++i) {\n    this.computedMatrix[i] = 0.5;\n  }\n\n  this.recalcMatrix(0);\n}\n\nvar proto = TurntableController.prototype;\n\nproto.setDistanceLimits = function (minDist, maxDist) {\n  if (minDist > 0) {\n    minDist = Math.log(minDist);\n  } else {\n    minDist = -Infinity;\n  }\n\n  if (maxDist > 0) {\n    maxDist = Math.log(maxDist);\n  } else {\n    maxDist = Infinity;\n  }\n\n  maxDist = Math.max(maxDist, minDist);\n  this.radius.bounds[0][0] = minDist;\n  this.radius.bounds[1][0] = maxDist;\n};\n\nproto.getDistanceLimits = function (out) {\n  var bounds = this.radius.bounds[0];\n\n  if (out) {\n    out[0] = Math.exp(bounds[0][0]);\n    out[1] = Math.exp(bounds[1][0]);\n    return out;\n  }\n\n  return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];\n};\n\nproto.recalcMatrix = function (t) {\n  //Recompute curves\n  this.center.curve(t);\n  this.up.curve(t);\n  this.right.curve(t);\n  this.radius.curve(t);\n  this.angle.curve(t); //Compute frame for camera matrix\n\n  var up = this.computedUp;\n  var right = this.computedRight;\n  var uu = 0.0;\n  var ur = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    ur += up[i] * right[i];\n    uu += up[i] * up[i];\n  }\n\n  var ul = Math.sqrt(uu);\n  var rr = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    right[i] -= up[i] * ur / uu;\n    rr += right[i] * right[i];\n    up[i] /= ul;\n  }\n\n  var rl = Math.sqrt(rr);\n\n  for (var i = 0; i < 3; ++i) {\n    right[i] /= rl;\n  } //Compute toward vector\n\n\n  var toward = this.computedToward;\n  cross(toward, up, right);\n  normalize3(toward, toward); //Compute angular parameters\n\n  var radius = Math.exp(this.computedRadius[0]);\n  var theta = this.computedAngle[0];\n  var phi = this.computedAngle[1];\n  var ctheta = Math.cos(theta);\n  var stheta = Math.sin(theta);\n  var cphi = Math.cos(phi);\n  var sphi = Math.sin(phi);\n  var center = this.computedCenter;\n  var wx = ctheta * cphi;\n  var wy = stheta * cphi;\n  var wz = sphi;\n  var sx = -ctheta * sphi;\n  var sy = -stheta * sphi;\n  var sz = cphi;\n  var eye = this.computedEye;\n  var mat = this.computedMatrix;\n\n  for (var i = 0; i < 3; ++i) {\n    var x = wx * right[i] + wy * toward[i] + wz * up[i];\n    mat[4 * i + 1] = sx * right[i] + sy * toward[i] + sz * up[i];\n    mat[4 * i + 2] = x;\n    mat[4 * i + 3] = 0.0;\n  }\n\n  var ax = mat[1];\n  var ay = mat[5];\n  var az = mat[9];\n  var bx = mat[2];\n  var by = mat[6];\n  var bz = mat[10];\n  var cx = ay * bz - az * by;\n  var cy = az * bx - ax * bz;\n  var cz = ax * by - ay * bx;\n  var cl = len3(cx, cy, cz);\n  cx /= cl;\n  cy /= cl;\n  cz /= cl;\n  mat[0] = cx;\n  mat[4] = cy;\n  mat[8] = cz;\n\n  for (var i = 0; i < 3; ++i) {\n    eye[i] = center[i] + mat[2 + 4 * i] * radius;\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    var rr = 0.0;\n\n    for (var j = 0; j < 3; ++j) {\n      rr += mat[i + 4 * j] * eye[j];\n    }\n\n    mat[12 + i] = -rr;\n  }\n\n  mat[15] = 1.0;\n};\n\nproto.getMatrix = function (t, result) {\n  this.recalcMatrix(t);\n  var mat = this.computedMatrix;\n\n  if (result) {\n    for (var i = 0; i < 16; ++i) {\n      result[i] = mat[i];\n    }\n\n    return result;\n  }\n\n  return mat;\n};\n\nvar zAxis = [0, 0, 0];\n\nproto.rotate = function (t, dtheta, dphi, droll) {\n  this.angle.move(t, dtheta, dphi);\n\n  if (droll) {\n    this.recalcMatrix(t);\n    var mat = this.computedMatrix;\n    zAxis[0] = mat[2];\n    zAxis[1] = mat[6];\n    zAxis[2] = mat[10];\n    var up = this.computedUp;\n    var right = this.computedRight;\n    var toward = this.computedToward;\n\n    for (var i = 0; i < 3; ++i) {\n      mat[4 * i] = up[i];\n      mat[4 * i + 1] = right[i];\n      mat[4 * i + 2] = toward[i];\n    }\n\n    rotateM(mat, mat, droll, zAxis);\n\n    for (var i = 0; i < 3; ++i) {\n      up[i] = mat[4 * i];\n      right[i] = mat[4 * i + 1];\n    }\n\n    this.up.set(t, up[0], up[1], up[2]);\n    this.right.set(t, right[0], right[1], right[2]);\n  }\n};\n\nproto.pan = function (t, dx, dy, dz) {\n  dx = dx || 0.0;\n  dy = dy || 0.0;\n  dz = dz || 0.0;\n  this.recalcMatrix(t);\n  var mat = this.computedMatrix;\n  var dist = Math.exp(this.computedRadius[0]);\n  var ux = mat[1];\n  var uy = mat[5];\n  var uz = mat[9];\n  var ul = len3(ux, uy, uz);\n  ux /= ul;\n  uy /= ul;\n  uz /= ul;\n  var rx = mat[0];\n  var ry = mat[4];\n  var rz = mat[8];\n  var ru = rx * ux + ry * uy + rz * uz;\n  rx -= ux * ru;\n  ry -= uy * ru;\n  rz -= uz * ru;\n  var rl = len3(rx, ry, rz);\n  rx /= rl;\n  ry /= rl;\n  rz /= rl;\n  var vx = rx * dx + ux * dy;\n  var vy = ry * dx + uy * dy;\n  var vz = rz * dx + uz * dy;\n  this.center.move(t, vx, vy, vz); //Update z-component of radius\n\n  var radius = Math.exp(this.computedRadius[0]);\n  radius = Math.max(1e-4, radius + dz);\n  this.radius.set(t, Math.log(radius));\n};\n\nproto.translate = function (t, dx, dy, dz) {\n  this.center.move(t, dx || 0.0, dy || 0.0, dz || 0.0);\n}; //Recenters the coordinate axes\n\n\nproto.setMatrix = function (t, mat, axes, noSnap) {\n  //Get the axes for tare\n  var ushift = 1;\n\n  if (typeof axes === 'number') {\n    ushift = axes | 0;\n  }\n\n  if (ushift < 0 || ushift > 3) {\n    ushift = 1;\n  }\n\n  var vshift = (ushift + 2) % 3;\n  var fshift = (ushift + 1) % 3; //Recompute state for new t value\n\n  if (!mat) {\n    this.recalcMatrix(t);\n    mat = this.computedMatrix;\n  } //Get right and up vectors\n\n\n  var ux = mat[ushift];\n  var uy = mat[ushift + 4];\n  var uz = mat[ushift + 8];\n\n  if (!noSnap) {\n    var ul = len3(ux, uy, uz);\n    ux /= ul;\n    uy /= ul;\n    uz /= ul;\n  } else {\n    var ax = Math.abs(ux);\n    var ay = Math.abs(uy);\n    var az = Math.abs(uz);\n    var am = Math.max(ax, ay, az);\n\n    if (ax === am) {\n      ux = ux < 0 ? -1 : 1;\n      uy = uz = 0;\n    } else if (az === am) {\n      uz = uz < 0 ? -1 : 1;\n      ux = uy = 0;\n    } else {\n      uy = uy < 0 ? -1 : 1;\n      ux = uz = 0;\n    }\n  }\n\n  var rx = mat[vshift];\n  var ry = mat[vshift + 4];\n  var rz = mat[vshift + 8];\n  var ru = rx * ux + ry * uy + rz * uz;\n  rx -= ux * ru;\n  ry -= uy * ru;\n  rz -= uz * ru;\n  var rl = len3(rx, ry, rz);\n  rx /= rl;\n  ry /= rl;\n  rz /= rl;\n  var fx = uy * rz - uz * ry;\n  var fy = uz * rx - ux * rz;\n  var fz = ux * ry - uy * rx;\n  var fl = len3(fx, fy, fz);\n  fx /= fl;\n  fy /= fl;\n  fz /= fl;\n  this.center.jump(t, ex, ey, ez);\n  this.radius.idle(t);\n  this.up.jump(t, ux, uy, uz);\n  this.right.jump(t, rx, ry, rz);\n  var phi, theta;\n\n  if (ushift === 2) {\n    var cx = mat[1];\n    var cy = mat[5];\n    var cz = mat[9];\n    var cr = cx * rx + cy * ry + cz * rz;\n    var cf = cx * fx + cy * fy + cz * fz;\n\n    if (tu < 0) {\n      phi = -Math.PI / 2;\n    } else {\n      phi = Math.PI / 2;\n    }\n\n    theta = Math.atan2(cf, cr);\n  } else {\n    var tx = mat[2];\n    var ty = mat[6];\n    var tz = mat[10];\n    var tu = tx * ux + ty * uy + tz * uz;\n    var tr = tx * rx + ty * ry + tz * rz;\n    var tf = tx * fx + ty * fy + tz * fz;\n    phi = Math.asin(clamp1(tu));\n    theta = Math.atan2(tf, tr);\n  }\n\n  this.angle.jump(t, theta, phi);\n  this.recalcMatrix(t);\n  var dx = mat[2];\n  var dy = mat[6];\n  var dz = mat[10];\n  var imat = this.computedMatrix;\n  invert44(imat, mat);\n  var w = imat[15];\n  var ex = imat[12] / w;\n  var ey = imat[13] / w;\n  var ez = imat[14] / w;\n  var gs = Math.exp(this.computedRadius[0]);\n  this.center.jump(t, ex - dx * gs, ey - dy * gs, ez - dz * gs);\n};\n\nproto.lastT = function () {\n  return Math.max(this.center.lastT(), this.up.lastT(), this.right.lastT(), this.radius.lastT(), this.angle.lastT());\n};\n\nproto.idle = function (t) {\n  this.center.idle(t);\n  this.up.idle(t);\n  this.right.idle(t);\n  this.radius.idle(t);\n  this.angle.idle(t);\n};\n\nproto.flush = function (t) {\n  this.center.flush(t);\n  this.up.flush(t);\n  this.right.flush(t);\n  this.radius.flush(t);\n  this.angle.flush(t);\n};\n\nproto.setDistance = function (t, d) {\n  if (d > 0) {\n    this.radius.set(t, Math.log(d));\n  }\n};\n\nproto.lookAt = function (t, eye, center, up) {\n  this.recalcMatrix(t);\n  eye = eye || this.computedEye;\n  center = center || this.computedCenter;\n  up = up || this.computedUp;\n  var ux = up[0];\n  var uy = up[1];\n  var uz = up[2];\n  var ul = len3(ux, uy, uz);\n\n  if (ul < 1e-6) {\n    return;\n  }\n\n  ux /= ul;\n  uy /= ul;\n  uz /= ul;\n  var tx = eye[0] - center[0];\n  var ty = eye[1] - center[1];\n  var tz = eye[2] - center[2];\n  var tl = len3(tx, ty, tz);\n\n  if (tl < 1e-6) {\n    return;\n  }\n\n  tx /= tl;\n  ty /= tl;\n  tz /= tl;\n  var right = this.computedRight;\n  var rx = right[0];\n  var ry = right[1];\n  var rz = right[2];\n  var ru = ux * rx + uy * ry + uz * rz;\n  rx -= ru * ux;\n  ry -= ru * uy;\n  rz -= ru * uz;\n  var rl = len3(rx, ry, rz);\n\n  if (rl < 0.01) {\n    rx = uy * tz - uz * ty;\n    ry = uz * tx - ux * tz;\n    rz = ux * ty - uy * tx;\n    rl = len3(rx, ry, rz);\n\n    if (rl < 1e-6) {\n      return;\n    }\n  }\n\n  rx /= rl;\n  ry /= rl;\n  rz /= rl;\n  this.up.set(t, ux, uy, uz);\n  this.right.set(t, rx, ry, rz);\n  this.center.set(t, center[0], center[1], center[2]);\n  this.radius.set(t, Math.log(tl));\n  var fx = uy * rz - uz * ry;\n  var fy = uz * rx - ux * rz;\n  var fz = ux * ry - uy * rx;\n  var fl = len3(fx, fy, fz);\n  fx /= fl;\n  fy /= fl;\n  fz /= fl;\n  var tu = ux * tx + uy * ty + uz * tz;\n  var tr = rx * tx + ry * ty + rz * tz;\n  var tf = fx * tx + fy * ty + fz * tz;\n  var phi = Math.asin(clamp1(tu));\n  var theta = Math.atan2(tf, tr);\n  var angleState = this.angle._state;\n  var lastTheta = angleState[angleState.length - 1];\n  var lastPhi = angleState[angleState.length - 2];\n  lastTheta = lastTheta % (2.0 * Math.PI);\n  var dp = Math.abs(lastTheta + 2.0 * Math.PI - theta);\n  var d0 = Math.abs(lastTheta - theta);\n  var dn = Math.abs(lastTheta - 2.0 * Math.PI - theta);\n\n  if (dp < d0) {\n    lastTheta += 2.0 * Math.PI;\n  }\n\n  if (dn < d0) {\n    lastTheta -= 2.0 * Math.PI;\n  }\n\n  this.angle.jump(this.angle.lastT(), lastTheta, lastPhi);\n  this.angle.set(t, theta, phi);\n};\n\nfunction createTurntableController(options) {\n  options = options || {};\n  var center = options.center || [0, 0, 0];\n  var up = options.up || [0, 1, 0];\n  var right = options.right || findOrthoPair(up);\n  var radius = options.radius || 1.0;\n  var theta = options.theta || 0.0;\n  var phi = options.phi || 0.0;\n  center = [].slice.call(center, 0, 3);\n  up = [].slice.call(up, 0, 3);\n  normalize3(up, up);\n  right = [].slice.call(right, 0, 3);\n  normalize3(right, right);\n\n  if ('eye' in options) {\n    var eye = options.eye;\n    var toward = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];\n    cross(right, toward, up);\n\n    if (len3(right[0], right[1], right[2]) < 1e-6) {\n      right = findOrthoPair(up);\n    } else {\n      normalize3(right, right);\n    }\n\n    radius = len3(toward[0], toward[1], toward[2]);\n    var ut = dot3(up, toward) / radius;\n    var rt = dot3(right, toward) / radius;\n    phi = Math.acos(ut);\n    theta = Math.acos(rt);\n  } //Use logarithmic coordinates for radius\n\n\n  radius = Math.log(radius); //Return the controller\n\n  return new TurntableController(options.zoomMin, options.zoomMax, center, up, right, radius, theta, phi);\n}","map":null,"metadata":{},"sourceType":"script"}