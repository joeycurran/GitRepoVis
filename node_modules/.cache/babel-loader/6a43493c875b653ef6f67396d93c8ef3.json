{"ast":null,"code":"\"use strict\";\n\nmodule.exports = surfaceNets;\n\nvar generateContourExtractor = require(\"ndarray-extract-contour\");\n\nvar triangulateCube = require(\"triangulate-hypercube\");\n\nvar zeroCrossings = require(\"zero-crossings\");\n\nfunction buildSurfaceNets(order, dtype) {\n  var dimension = order.length;\n  var code = [\"'use strict';\"];\n  var funcName = \"surfaceNets\" + order.join(\"_\") + \"d\" + dtype; //Contour extraction function\n\n  code.push(\"var contour=genContour({\", \"order:[\", order.join(), \"],\", \"scalarArguments: 3,\", \"phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },\");\n\n  if (dtype === \"generic\") {\n    code.push(\"getters:[0],\");\n  } //Generate vertex function\n\n\n  var cubeArgs = [];\n  var extraArgs = [];\n\n  for (var i = 0; i < dimension; ++i) {\n    cubeArgs.push(\"d\" + i);\n    extraArgs.push(\"d\" + i);\n  }\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    cubeArgs.push(\"v\" + i);\n    extraArgs.push(\"v\" + i);\n  }\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    cubeArgs.push(\"p\" + i);\n    extraArgs.push(\"p\" + i);\n  }\n\n  cubeArgs.push(\"a\", \"b\", \"c\");\n  extraArgs.push(\"a\", \"c\");\n  code.push(\"vertex:function vertexFunc(\", cubeArgs.join(), \"){\"); //Mask args together\n\n  var maskStr = [];\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    maskStr.push(\"(p\" + i + \"<<\" + i + \")\");\n  } //Generate variables and giganto switch statement\n\n\n  code.push(\"var m=(\", maskStr.join(\"+\"), \")|0;if(m===0||m===\", (1 << (1 << dimension)) - 1, \"){return}\");\n  var extraFuncs = [];\n  var currentFunc = [];\n\n  if (1 << (1 << dimension) <= 128) {\n    code.push(\"switch(m){\");\n    currentFunc = code;\n  } else {\n    code.push(\"switch(m>>>7){\");\n  }\n\n  for (var i = 0; i < 1 << (1 << dimension); ++i) {\n    if (1 << (1 << dimension) > 128) {\n      if (i % 128 === 0) {\n        if (extraFuncs.length > 0) {\n          currentFunc.push(\"}}\");\n        }\n\n        var efName = \"vExtra\" + extraFuncs.length;\n        code.push(\"case \", i >>> 7, \":\", efName, \"(m&0x7f,\", extraArgs.join(), \");break;\");\n        currentFunc = [\"function \", efName, \"(m,\", extraArgs.join(), \"){switch(m){\"];\n        extraFuncs.push(currentFunc);\n      }\n    }\n\n    currentFunc.push(\"case \", i & 0x7f, \":\");\n    var crossings = new Array(dimension);\n    var denoms = new Array(dimension);\n    var crossingCount = new Array(dimension);\n    var bias = new Array(dimension);\n    var totalCrossings = 0;\n\n    for (var j = 0; j < dimension; ++j) {\n      crossings[j] = [];\n      denoms[j] = [];\n      crossingCount[j] = 0;\n      bias[j] = 0;\n    }\n\n    for (var j = 0; j < 1 << dimension; ++j) {\n      for (var k = 0; k < dimension; ++k) {\n        var u = j ^ 1 << k;\n\n        if (u > j) {\n          continue;\n        }\n\n        if (!(i & 1 << u) !== !(i & 1 << j)) {\n          var sign = 1;\n\n          if (i & 1 << u) {\n            denoms[k].push(\"v\" + u + \"-v\" + j);\n          } else {\n            denoms[k].push(\"v\" + j + \"-v\" + u);\n            sign = -sign;\n          }\n\n          if (sign < 0) {\n            crossings[k].push(\"-v\" + j + \"-v\" + u);\n            crossingCount[k] += 2;\n          } else {\n            crossings[k].push(\"v\" + j + \"+v\" + u);\n            crossingCount[k] -= 2;\n          }\n\n          totalCrossings += 1;\n\n          for (var l = 0; l < dimension; ++l) {\n            if (l === k) {\n              continue;\n            }\n\n            if (u & 1 << l) {\n              bias[l] += 1;\n            } else {\n              bias[l] -= 1;\n            }\n          }\n        }\n      }\n    }\n\n    var vertexStr = [];\n\n    for (var k = 0; k < dimension; ++k) {\n      if (crossings[k].length === 0) {\n        vertexStr.push(\"d\" + k + \"-0.5\");\n      } else {\n        var cStr = \"\";\n\n        if (crossingCount[k] < 0) {\n          cStr = crossingCount[k] + \"*c\";\n        } else if (crossingCount[k] > 0) {\n          cStr = \"+\" + crossingCount[k] + \"*c\";\n        }\n\n        var weight = 0.5 * (crossings[k].length / totalCrossings);\n        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings);\n        vertexStr.push(\"d\" + k + \"-\" + shift + \"-\" + weight + \"*(\" + crossings[k].join(\"+\") + cStr + \")/(\" + denoms[k].join(\"+\") + \")\");\n      }\n    }\n\n    currentFunc.push(\"a.push([\", vertexStr.join(), \"]);\", \"break;\");\n  }\n\n  code.push(\"}},\");\n\n  if (extraFuncs.length > 0) {\n    currentFunc.push(\"}}\");\n  } //Create face function\n\n\n  var faceArgs = [];\n\n  for (var i = 0; i < 1 << dimension - 1; ++i) {\n    faceArgs.push(\"v\" + i);\n  }\n\n  faceArgs.push(\"c0\", \"c1\", \"p0\", \"p1\", \"a\", \"b\", \"c\");\n  code.push(\"cell:function cellFunc(\", faceArgs.join(), \"){\");\n  var facets = triangulateCube(dimension - 1);\n  code.push(\"if(p0){b.push(\", facets.map(function (f) {\n    return \"[\" + f.map(function (v) {\n      return \"v\" + v;\n    }) + \"]\";\n  }).join(), \")}else{b.push(\", facets.map(function (f) {\n    var e = f.slice();\n    e.reverse();\n    return \"[\" + e.map(function (v) {\n      return \"v\" + v;\n    }) + \"]\";\n  }).join(), \")}}});function \", funcName, \"(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return \", funcName, \";\");\n\n  for (var i = 0; i < extraFuncs.length; ++i) {\n    code.push(extraFuncs[i].join(\"\"));\n  } //Compile and link\n\n\n  var proc = new Function(\"genContour\", code.join(\"\"));\n  return proc(generateContourExtractor);\n} //1D case: Need to handle specially\n\n\nfunction mesh1D(array, level) {\n  var zc = zeroCrossings(array, level);\n  var n = zc.length;\n  var npos = new Array(n);\n  var ncel = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    npos[i] = [zc[i]];\n    ncel[i] = [i];\n  }\n\n  return {\n    positions: npos,\n    cells: ncel\n  };\n}\n\nvar CACHE = {};\n\nfunction surfaceNets(array, level) {\n  if (array.dimension <= 0) {\n    return {\n      positions: [],\n      cells: []\n    };\n  } else if (array.dimension === 1) {\n    return mesh1D(array, level);\n  }\n\n  var typesig = array.order.join() + \"-\" + array.dtype;\n  var proc = CACHE[typesig];\n  var level = +level || 0.0;\n\n  if (!proc) {\n    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype);\n  }\n\n  return proc(array, level);\n}","map":null,"metadata":{},"sourceType":"script"}