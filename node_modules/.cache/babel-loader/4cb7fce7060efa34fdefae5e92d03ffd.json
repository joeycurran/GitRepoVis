{"ast":null,"code":"\"use strict\";\n\nvar pool = require(\"typedarray-pool\");\n\nvar INSERTION_SORT_THRESHOLD = 32;\n\nfunction getMallocFree(dtype) {\n  switch (dtype) {\n    case \"uint8\":\n      return [pool.mallocUint8, pool.freeUint8];\n\n    case \"uint16\":\n      return [pool.mallocUint16, pool.freeUint16];\n\n    case \"uint32\":\n      return [pool.mallocUint32, pool.freeUint32];\n\n    case \"int8\":\n      return [pool.mallocInt8, pool.freeInt8];\n\n    case \"int16\":\n      return [pool.mallocInt16, pool.freeInt16];\n\n    case \"int32\":\n      return [pool.mallocInt32, pool.freeInt32];\n\n    case \"float32\":\n      return [pool.mallocFloat, pool.freeFloat];\n\n    case \"float64\":\n      return [pool.mallocDouble, pool.freeDouble];\n\n    default:\n      return null;\n  }\n}\n\nfunction shapeArgs(dimension) {\n  var args = [];\n\n  for (var i = 0; i < dimension; ++i) {\n    args.push(\"s\" + i);\n  }\n\n  for (var i = 0; i < dimension; ++i) {\n    args.push(\"n\" + i);\n  }\n\n  for (var i = 1; i < dimension; ++i) {\n    args.push(\"d\" + i);\n  }\n\n  for (var i = 1; i < dimension; ++i) {\n    args.push(\"e\" + i);\n  }\n\n  for (var i = 1; i < dimension; ++i) {\n    args.push(\"f\" + i);\n  }\n\n  return args;\n}\n\nfunction createInsertionSort(order, dtype) {\n  var code = [\"'use strict'\"];\n  var funcName = [\"ndarrayInsertionSort\", order.join(\"d\"), dtype].join(\"\");\n  var funcArgs = [\"left\", \"right\", \"data\", \"offset\"].concat(shapeArgs(order.length));\n  var allocator = getMallocFree(dtype);\n  var vars = [\"i,j,cptr,ptr=left*s0+offset\"];\n\n  if (order.length > 1) {\n    var scratch_shape = [];\n\n    for (var i = 1; i < order.length; ++i) {\n      vars.push(\"i\" + i);\n      scratch_shape.push(\"n\" + i);\n    }\n\n    if (allocator) {\n      vars.push(\"scratch=malloc(\" + scratch_shape.join(\"*\") + \")\");\n    } else {\n      vars.push(\"scratch=new Array(\" + scratch_shape.join(\"*\") + \")\");\n    }\n\n    vars.push(\"dptr\", \"sptr\", \"a\", \"b\");\n  } else {\n    vars.push(\"scratch\");\n  }\n\n  function dataRead(ptr) {\n    if (dtype === \"generic\") {\n      return [\"data.get(\", ptr, \")\"].join(\"\");\n    }\n\n    return [\"data[\", ptr, \"]\"].join(\"\");\n  }\n\n  function dataWrite(ptr, v) {\n    if (dtype === \"generic\") {\n      return [\"data.set(\", ptr, \",\", v, \")\"].join(\"\");\n    }\n\n    return [\"data[\", ptr, \"]=\", v].join(\"\");\n  } //Create function header\n\n\n  code.push([\"function \", funcName, \"(\", funcArgs.join(\",\"), \"){var \", vars.join(\",\")].join(\"\"), \"for(i=left+1;i<=right;++i){\", \"j=i;ptr+=s0\", \"cptr=ptr\");\n\n  if (order.length > 1) {\n    //Copy data into scratch\n    code.push(\"dptr=0;sptr=ptr\");\n\n    for (var i = order.length - 1; i >= 0; --i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push([\"for(i\", j, \"=0;i\", j, \"<n\", j, \";++i\", j, \"){\"].join(\"\"));\n    }\n\n    code.push(\"scratch[dptr++]=\", dataRead(\"sptr\"));\n\n    for (var i = 0; i < order.length; ++i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push(\"sptr+=d\" + j, \"}\");\n    } //Compare items in outer loop\n\n\n    code.push(\"__g:while(j-->left){\", \"dptr=0\", \"sptr=cptr-s0\");\n\n    for (var i = 1; i < order.length; ++i) {\n      if (i === 1) {\n        code.push(\"__l:\");\n      }\n\n      code.push([\"for(i\", i, \"=0;i\", i, \"<n\", i, \";++i\", i, \"){\"].join(\"\"));\n    }\n\n    code.push([\"a=\", dataRead(\"sptr\"), \"\\nb=scratch[dptr]\\nif(a<b){break __g}\\nif(a>b){break __l}\"].join(\"\"));\n\n    for (var i = order.length - 1; i >= 1; --i) {\n      code.push(\"sptr+=e\" + i, \"dptr+=f\" + i, \"}\");\n    } //Copy data back\n\n\n    code.push(\"dptr=cptr;sptr=cptr-s0\");\n\n    for (var i = order.length - 1; i >= 0; --i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push([\"for(i\", j, \"=0;i\", j, \"<n\", j, \";++i\", j, \"){\"].join(\"\"));\n    }\n\n    code.push(dataWrite(\"dptr\", dataRead(\"sptr\")));\n\n    for (var i = 0; i < order.length; ++i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push([\"dptr+=d\", j, \";sptr+=d\", j].join(\"\"), \"}\");\n    } //Close while loop\n\n\n    code.push(\"cptr-=s0\\n}\"); //Copy scratch into cptr\n\n    code.push(\"dptr=cptr;sptr=0\");\n\n    for (var i = order.length - 1; i >= 0; --i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push([\"for(i\", j, \"=0;i\", j, \"<n\", j, \";++i\", j, \"){\"].join(\"\"));\n    }\n\n    code.push(dataWrite(\"dptr\", \"scratch[sptr++]\"));\n\n    for (var i = 0; i < order.length; ++i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push(\"dptr+=d\" + j, \"}\");\n    }\n  } else {\n    code.push(\"scratch=\" + dataRead(\"ptr\"), \"while((j-->left)&&(\" + dataRead(\"cptr-s0\") + \">scratch)){\", dataWrite(\"cptr\", dataRead(\"cptr-s0\")), \"cptr-=s0\", \"}\", dataWrite(\"cptr\", \"scratch\"));\n  } //Close outer loop body\n\n\n  code.push(\"}\");\n\n  if (order.length > 1 && allocator) {\n    code.push(\"free(scratch)\");\n  }\n\n  code.push(\"} return \" + funcName); //Compile and link function\n\n  if (allocator) {\n    var result = new Function(\"malloc\", \"free\", code.join(\"\\n\"));\n    return result(allocator[0], allocator[1]);\n  } else {\n    var result = new Function(code.join(\"\\n\"));\n    return result();\n  }\n}\n\nfunction createQuickSort(order, dtype, insertionSort) {\n  var code = [\"'use strict'\"];\n  var funcName = [\"ndarrayQuickSort\", order.join(\"d\"), dtype].join(\"\");\n  var funcArgs = [\"left\", \"right\", \"data\", \"offset\"].concat(shapeArgs(order.length));\n  var allocator = getMallocFree(dtype);\n  var labelCounter = 0;\n  code.push([\"function \", funcName, \"(\", funcArgs.join(\",\"), \"){\"].join(\"\"));\n  var vars = [\"sixth=((right-left+1)/6)|0\", \"index1=left+sixth\", \"index5=right-sixth\", \"index3=(left+right)>>1\", \"index2=index3-sixth\", \"index4=index3+sixth\", \"el1=index1\", \"el2=index2\", \"el3=index3\", \"el4=index4\", \"el5=index5\", \"less=left+1\", \"great=right-1\", \"pivots_are_equal=true\", \"tmp\", \"tmp0\", \"x\", \"y\", \"z\", \"k\", \"ptr0\", \"ptr1\", \"ptr2\", \"comp_pivot1=0\", \"comp_pivot2=0\", \"comp=0\"];\n\n  if (order.length > 1) {\n    var ele_size = [];\n\n    for (var i = 1; i < order.length; ++i) {\n      ele_size.push(\"n\" + i);\n      vars.push(\"i\" + i);\n    }\n\n    for (var i = 0; i < 8; ++i) {\n      vars.push(\"b_ptr\" + i);\n    }\n\n    vars.push(\"ptr3\", \"ptr4\", \"ptr5\", \"ptr6\", \"ptr7\", \"pivot_ptr\", \"ptr_shift\", \"elementSize=\" + ele_size.join(\"*\"));\n\n    if (allocator) {\n      vars.push(\"pivot1=malloc(elementSize)\", \"pivot2=malloc(elementSize)\");\n    } else {\n      vars.push(\"pivot1=new Array(elementSize),pivot2=new Array(elementSize)\");\n    }\n  } else {\n    vars.push(\"pivot1\", \"pivot2\");\n  } //Initialize local variables\n\n\n  code.push(\"var \" + vars.join(\",\"));\n\n  function toPointer(v) {\n    return [\"(offset+\", v, \"*s0)\"].join(\"\");\n  }\n\n  function dataRead(ptr) {\n    if (dtype === \"generic\") {\n      return [\"data.get(\", ptr, \")\"].join(\"\");\n    }\n\n    return [\"data[\", ptr, \"]\"].join(\"\");\n  }\n\n  function dataWrite(ptr, v) {\n    if (dtype === \"generic\") {\n      return [\"data.set(\", ptr, \",\", v, \")\"].join(\"\");\n    }\n\n    return [\"data[\", ptr, \"]=\", v].join(\"\");\n  }\n\n  function cacheLoop(ptrs, usePivot, body) {\n    if (ptrs.length === 1) {\n      code.push(\"ptr0=\" + toPointer(ptrs[0]));\n    } else {\n      for (var i = 0; i < ptrs.length; ++i) {\n        code.push([\"b_ptr\", i, \"=s0*\", ptrs[i]].join(\"\"));\n      }\n    }\n\n    if (usePivot) {\n      code.push(\"pivot_ptr=0\");\n    }\n\n    code.push(\"ptr_shift=offset\");\n\n    for (var i = order.length - 1; i >= 0; --i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      code.push([\"for(i\", j, \"=0;i\", j, \"<n\", j, \";++i\", j, \"){\"].join(\"\"));\n    }\n\n    if (ptrs.length > 1) {\n      for (var i = 0; i < ptrs.length; ++i) {\n        code.push([\"ptr\", i, \"=b_ptr\", i, \"+ptr_shift\"].join(\"\"));\n      }\n    }\n\n    code.push(body);\n\n    if (usePivot) {\n      code.push(\"++pivot_ptr\");\n    }\n\n    for (var i = 0; i < order.length; ++i) {\n      var j = order[i];\n\n      if (j === 0) {\n        continue;\n      }\n\n      if (ptrs.length > 1) {\n        code.push(\"ptr_shift+=d\" + j);\n      } else {\n        code.push(\"ptr0+=d\" + j);\n      }\n\n      code.push(\"}\");\n    }\n  }\n\n  function lexicoLoop(label, ptrs, usePivot, body) {\n    if (ptrs.length === 1) {\n      code.push(\"ptr0=\" + toPointer(ptrs[0]));\n    } else {\n      for (var i = 0; i < ptrs.length; ++i) {\n        code.push([\"b_ptr\", i, \"=s0*\", ptrs[i]].join(\"\"));\n      }\n\n      code.push(\"ptr_shift=offset\");\n    }\n\n    if (usePivot) {\n      code.push(\"pivot_ptr=0\");\n    }\n\n    if (label) {\n      code.push(label + \":\");\n    }\n\n    for (var i = 1; i < order.length; ++i) {\n      code.push([\"for(i\", i, \"=0;i\", i, \"<n\", i, \";++i\", i, \"){\"].join(\"\"));\n    }\n\n    if (ptrs.length > 1) {\n      for (var i = 0; i < ptrs.length; ++i) {\n        code.push([\"ptr\", i, \"=b_ptr\", i, \"+ptr_shift\"].join(\"\"));\n      }\n    }\n\n    code.push(body);\n\n    for (var i = order.length - 1; i >= 1; --i) {\n      if (usePivot) {\n        code.push(\"pivot_ptr+=f\" + i);\n      }\n\n      if (ptrs.length > 1) {\n        code.push(\"ptr_shift+=e\" + i);\n      } else {\n        code.push(\"ptr0+=e\" + i);\n      }\n\n      code.push(\"}\");\n    }\n  }\n\n  function cleanUp() {\n    if (order.length > 1 && allocator) {\n      code.push(\"free(pivot1)\", \"free(pivot2)\");\n    }\n  }\n\n  function compareSwap(a_id, b_id) {\n    var a = \"el\" + a_id;\n    var b = \"el\" + b_id;\n\n    if (order.length > 1) {\n      var lbl = \"__l\" + ++labelCounter;\n      lexicoLoop(lbl, [a, b], false, [\"comp=\", dataRead(\"ptr0\"), \"-\", dataRead(\"ptr1\"), \"\\n\", \"if(comp>0){tmp0=\", a, \";\", a, \"=\", b, \";\", b, \"=tmp0;break \", lbl, \"}\\n\", \"if(comp<0){break \", lbl, \"}\"].join(\"\"));\n    } else {\n      code.push([\"if(\", dataRead(toPointer(a)), \">\", dataRead(toPointer(b)), \"){tmp0=\", a, \";\", a, \"=\", b, \";\", b, \"=tmp0}\"].join(\"\"));\n    }\n  }\n\n  compareSwap(1, 2);\n  compareSwap(4, 5);\n  compareSwap(1, 3);\n  compareSwap(2, 3);\n  compareSwap(1, 4);\n  compareSwap(3, 4);\n  compareSwap(2, 5);\n  compareSwap(2, 3);\n  compareSwap(4, 5);\n\n  if (order.length > 1) {\n    cacheLoop([\"el1\", \"el2\", \"el3\", \"el4\", \"el5\", \"index1\", \"index3\", \"index5\"], true, [\"pivot1[pivot_ptr]=\", dataRead(\"ptr1\"), \"\\n\", \"pivot2[pivot_ptr]=\", dataRead(\"ptr3\"), \"\\n\", \"pivots_are_equal=pivots_are_equal&&(pivot1[pivot_ptr]===pivot2[pivot_ptr])\\n\", \"x=\", dataRead(\"ptr0\"), \"\\n\", \"y=\", dataRead(\"ptr2\"), \"\\n\", \"z=\", dataRead(\"ptr4\"), \"\\n\", dataWrite(\"ptr5\", \"x\"), \"\\n\", dataWrite(\"ptr6\", \"y\"), \"\\n\", dataWrite(\"ptr7\", \"z\")].join(\"\"));\n  } else {\n    code.push([\"pivot1=\", dataRead(toPointer(\"el2\")), \"\\n\", \"pivot2=\", dataRead(toPointer(\"el4\")), \"\\n\", \"pivots_are_equal=pivot1===pivot2\\n\", \"x=\", dataRead(toPointer(\"el1\")), \"\\n\", \"y=\", dataRead(toPointer(\"el3\")), \"\\n\", \"z=\", dataRead(toPointer(\"el5\")), \"\\n\", dataWrite(toPointer(\"index1\"), \"x\"), \"\\n\", dataWrite(toPointer(\"index3\"), \"y\"), \"\\n\", dataWrite(toPointer(\"index5\"), \"z\")].join(\"\"));\n  }\n\n  function moveElement(dst, src) {\n    if (order.length > 1) {\n      cacheLoop([dst, src], false, dataWrite(\"ptr0\", dataRead(\"ptr1\")));\n    } else {\n      code.push(dataWrite(toPointer(dst), dataRead(toPointer(src))));\n    }\n  }\n\n  moveElement(\"index2\", \"left\");\n  moveElement(\"index4\", \"right\");\n\n  function comparePivot(result, ptr, n) {\n    if (order.length > 1) {\n      var lbl = \"__l\" + ++labelCounter;\n      lexicoLoop(lbl, [ptr], true, [result, \"=\", dataRead(\"ptr0\"), \"-pivot\", n, \"[pivot_ptr]\\n\", \"if(\", result, \"!==0){break \", lbl, \"}\"].join(\"\"));\n    } else {\n      code.push([result, \"=\", dataRead(toPointer(ptr)), \"-pivot\", n].join(\"\"));\n    }\n  }\n\n  function swapElements(a, b) {\n    if (order.length > 1) {\n      cacheLoop([a, b], false, [\"tmp=\", dataRead(\"ptr0\"), \"\\n\", dataWrite(\"ptr0\", dataRead(\"ptr1\")), \"\\n\", dataWrite(\"ptr1\", \"tmp\")].join(\"\"));\n    } else {\n      code.push([\"ptr0=\", toPointer(a), \"\\n\", \"ptr1=\", toPointer(b), \"\\n\", \"tmp=\", dataRead(\"ptr0\"), \"\\n\", dataWrite(\"ptr0\", dataRead(\"ptr1\")), \"\\n\", dataWrite(\"ptr1\", \"tmp\")].join(\"\"));\n    }\n  }\n\n  function tripleSwap(k, less, great) {\n    if (order.length > 1) {\n      cacheLoop([k, less, great], false, [\"tmp=\", dataRead(\"ptr0\"), \"\\n\", dataWrite(\"ptr0\", dataRead(\"ptr1\")), \"\\n\", dataWrite(\"ptr1\", dataRead(\"ptr2\")), \"\\n\", dataWrite(\"ptr2\", \"tmp\")].join(\"\"));\n      code.push(\"++\" + less, \"--\" + great);\n    } else {\n      code.push([\"ptr0=\", toPointer(k), \"\\n\", \"ptr1=\", toPointer(less), \"\\n\", \"ptr2=\", toPointer(great), \"\\n\", \"++\", less, \"\\n\", \"--\", great, \"\\n\", \"tmp=\", dataRead(\"ptr0\"), \"\\n\", dataWrite(\"ptr0\", dataRead(\"ptr1\")), \"\\n\", dataWrite(\"ptr1\", dataRead(\"ptr2\")), \"\\n\", dataWrite(\"ptr2\", \"tmp\")].join(\"\"));\n    }\n  }\n\n  function swapAndDecrement(k, great) {\n    swapElements(k, great);\n    code.push(\"--\" + great);\n  }\n\n  code.push(\"if(pivots_are_equal){\"); //Pivots are equal case\n\n  code.push(\"for(k=less;k<=great;++k){\");\n  comparePivot(\"comp\", \"k\", 1);\n  code.push(\"if(comp===0){continue}\");\n  code.push(\"if(comp<0){\");\n  code.push(\"if(k!==less){\");\n  swapElements(\"k\", \"less\");\n  code.push(\"}\");\n  code.push(\"++less\");\n  code.push(\"}else{\");\n  code.push(\"while(true){\");\n  comparePivot(\"comp\", \"great\", 1);\n  code.push(\"if(comp>0){\");\n  code.push(\"great--\");\n  code.push(\"}else if(comp<0){\");\n  tripleSwap(\"k\", \"less\", \"great\");\n  code.push(\"break\");\n  code.push(\"}else{\");\n  swapAndDecrement(\"k\", \"great\");\n  code.push(\"break\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}else{\"); //Pivots not equal case\n\n  code.push(\"for(k=less;k<=great;++k){\");\n  comparePivot(\"comp_pivot1\", \"k\", 1);\n  code.push(\"if(comp_pivot1<0){\");\n  code.push(\"if(k!==less){\");\n  swapElements(\"k\", \"less\");\n  code.push(\"}\");\n  code.push(\"++less\");\n  code.push(\"}else{\");\n  comparePivot(\"comp_pivot2\", \"k\", 2);\n  code.push(\"if(comp_pivot2>0){\");\n  code.push(\"while(true){\");\n  comparePivot(\"comp\", \"great\", 2);\n  code.push(\"if(comp>0){\");\n  code.push(\"if(--great<k){break}\");\n  code.push(\"continue\");\n  code.push(\"}else{\");\n  comparePivot(\"comp\", \"great\", 1);\n  code.push(\"if(comp<0){\");\n  tripleSwap(\"k\", \"less\", \"great\");\n  code.push(\"}else{\");\n  swapAndDecrement(\"k\", \"great\");\n  code.push(\"}\");\n  code.push(\"break\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\"); //Move pivots to correct place\n\n  function storePivot(mem_dest, pivot_dest, pivot) {\n    if (order.length > 1) {\n      cacheLoop([mem_dest, pivot_dest], true, [dataWrite(\"ptr0\", dataRead(\"ptr1\")), \"\\n\", dataWrite(\"ptr1\", [\"pivot\", pivot, \"[pivot_ptr]\"].join(\"\"))].join(\"\"));\n    } else {\n      code.push(dataWrite(toPointer(mem_dest), dataRead(toPointer(pivot_dest))), dataWrite(toPointer(pivot_dest), \"pivot\" + pivot));\n    }\n  }\n\n  storePivot(\"left\", \"(less-1)\", 1);\n  storePivot(\"right\", \"(great+1)\", 2); //Recursive sort call\n\n  function doSort(left, right) {\n    code.push([\"if((\", right, \"-\", left, \")<=\", INSERTION_SORT_THRESHOLD, \"){\\n\", \"insertionSort(\", left, \",\", right, \",data,offset,\", shapeArgs(order.length).join(\",\"), \")\\n\", \"}else{\\n\", funcName, \"(\", left, \",\", right, \",data,offset,\", shapeArgs(order.length).join(\",\"), \")\\n\", \"}\"].join(\"\"));\n  }\n\n  doSort(\"left\", \"(less-2)\");\n  doSort(\"(great+2)\", \"right\"); //If pivots are equal, then early out\n\n  code.push(\"if(pivots_are_equal){\");\n  cleanUp();\n  code.push(\"return\");\n  code.push(\"}\");\n\n  function walkPointer(ptr, pivot, body) {\n    if (order.length > 1) {\n      code.push([\"__l\", ++labelCounter, \":while(true){\"].join(\"\"));\n      cacheLoop([ptr], true, [\"if(\", dataRead(\"ptr0\"), \"!==pivot\", pivot, \"[pivot_ptr]){break __l\", labelCounter, \"}\"].join(\"\"));\n      code.push(body, \"}\");\n    } else {\n      code.push([\"while(\", dataRead(toPointer(ptr)), \"===pivot\", pivot, \"){\", body, \"}\"].join(\"\"));\n    }\n  } //Check bounds\n\n\n  code.push(\"if(less<index1&&great>index5){\");\n  walkPointer(\"less\", 1, \"++less\");\n  walkPointer(\"great\", 2, \"--great\");\n  code.push(\"for(k=less;k<=great;++k){\");\n  comparePivot(\"comp_pivot1\", \"k\", 1);\n  code.push(\"if(comp_pivot1===0){\");\n  code.push(\"if(k!==less){\");\n  swapElements(\"k\", \"less\");\n  code.push(\"}\");\n  code.push(\"++less\");\n  code.push(\"}else{\");\n  comparePivot(\"comp_pivot2\", \"k\", 2);\n  code.push(\"if(comp_pivot2===0){\");\n  code.push(\"while(true){\");\n  comparePivot(\"comp\", \"great\", 2);\n  code.push(\"if(comp===0){\");\n  code.push(\"if(--great<k){break}\");\n  code.push(\"continue\");\n  code.push(\"}else{\");\n  comparePivot(\"comp\", \"great\", 1);\n  code.push(\"if(comp<0){\");\n  tripleSwap(\"k\", \"less\", \"great\");\n  code.push(\"}else{\");\n  swapAndDecrement(\"k\", \"great\");\n  code.push(\"}\");\n  code.push(\"break\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\");\n  code.push(\"}\"); //Clean up and do a final sorting pass\n\n  cleanUp();\n  doSort(\"less\", \"great\"); //Close off main loop\n\n  code.push(\"}return \" + funcName); //Compile and link\n\n  if (order.length > 1 && allocator) {\n    var compiled = new Function(\"insertionSort\", \"malloc\", \"free\", code.join(\"\\n\"));\n    return compiled(insertionSort, allocator[0], allocator[1]);\n  }\n\n  var compiled = new Function(\"insertionSort\", code.join(\"\\n\"));\n  return compiled(insertionSort);\n}\n\nfunction compileSort(order, dtype) {\n  var code = [\"'use strict'\"];\n  var funcName = [\"ndarraySortWrapper\", order.join(\"d\"), dtype].join(\"\");\n  var funcArgs = [\"array\"];\n  code.push([\"function \", funcName, \"(\", funcArgs.join(\",\"), \"){\"].join(\"\")); //Unpack local variables from array\n\n  var vars = [\"data=array.data,offset=array.offset|0,shape=array.shape,stride=array.stride\"];\n\n  for (var i = 0; i < order.length; ++i) {\n    vars.push([\"s\", i, \"=stride[\", i, \"]|0,n\", i, \"=shape[\", i, \"]|0\"].join(\"\"));\n  }\n\n  var scratch_stride = new Array(order.length);\n  var nprod = [];\n\n  for (var i = 0; i < order.length; ++i) {\n    var k = order[i];\n\n    if (k === 0) {\n      continue;\n    }\n\n    if (nprod.length === 0) {\n      scratch_stride[k] = \"1\";\n    } else {\n      scratch_stride[k] = nprod.join(\"*\");\n    }\n\n    nprod.push(\"n\" + k);\n  }\n\n  var p = -1,\n      q = -1;\n\n  for (var i = 0; i < order.length; ++i) {\n    var j = order[i];\n\n    if (j !== 0) {\n      if (p > 0) {\n        vars.push([\"d\", j, \"=s\", j, \"-d\", p, \"*n\", p].join(\"\"));\n      } else {\n        vars.push([\"d\", j, \"=s\", j].join(\"\"));\n      }\n\n      p = j;\n    }\n\n    var k = order.length - 1 - i;\n\n    if (k !== 0) {\n      if (q > 0) {\n        vars.push([\"e\", k, \"=s\", k, \"-e\", q, \"*n\", q, \",f\", k, \"=\", scratch_stride[k], \"-f\", q, \"*n\", q].join(\"\"));\n      } else {\n        vars.push([\"e\", k, \"=s\", k, \",f\", k, \"=\", scratch_stride[k]].join(\"\"));\n      }\n\n      q = k;\n    }\n  } //Declare local variables\n\n\n  code.push(\"var \" + vars.join(\",\")); //Create arguments for subroutine\n\n  var sortArgs = [\"0\", \"n0-1\", \"data\", \"offset\"].concat(shapeArgs(order.length)); //Call main sorting routine\n\n  code.push([\"if(n0<=\", INSERTION_SORT_THRESHOLD, \"){\", \"insertionSort(\", sortArgs.join(\",\"), \")}else{\", \"quickSort(\", sortArgs.join(\",\"), \")}\"].join(\"\")); //Return\n\n  code.push(\"}return \" + funcName); //Link everything together\n\n  var result = new Function(\"insertionSort\", \"quickSort\", code.join(\"\\n\"));\n  var insertionSort = createInsertionSort(order, dtype);\n  var quickSort = createQuickSort(order, dtype, insertionSort);\n  return result(insertionSort, quickSort);\n}\n\nmodule.exports = compileSort;","map":null,"metadata":{},"sourceType":"script"}