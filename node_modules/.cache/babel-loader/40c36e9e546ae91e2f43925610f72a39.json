{"ast":null,"code":"'use strict';\n\nvar inCircle = require('robust-in-sphere')[4];\n\nvar bsearch = require('binary-search-bounds');\n\nmodule.exports = delaunayRefine;\n\nfunction testFlip(points, triangulation, stack, a, b, x) {\n  var y = triangulation.opposite(a, b); //Test boundary edge\n\n  if (y < 0) {\n    return;\n  } //Swap edge if order flipped\n\n\n  if (b < a) {\n    var tmp = a;\n    a = b;\n    b = tmp;\n    tmp = x;\n    x = y;\n    y = tmp;\n  } //Test if edge is constrained\n\n\n  if (triangulation.isConstraint(a, b)) {\n    return;\n  } //Test if edge is delaunay\n\n\n  if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n    stack.push(a, b);\n  }\n} //Assume edges are sorted lexicographically\n\n\nfunction delaunayRefine(points, triangulation) {\n  var stack = [];\n  var numPoints = points.length;\n  var stars = triangulation.stars;\n\n  for (var a = 0; a < numPoints; ++a) {\n    var star = stars[a];\n\n    for (var j = 1; j < star.length; j += 2) {\n      var b = star[j]; //If order is not consistent, then skip edge\n\n      if (b < a) {\n        continue;\n      } //Check if edge is constrained\n\n\n      if (triangulation.isConstraint(a, b)) {\n        continue;\n      } //Find opposite edge\n\n\n      var x = star[j - 1],\n          y = -1;\n\n      for (var k = 1; k < star.length; k += 2) {\n        if (star[k - 1] === b) {\n          y = star[k];\n          break;\n        }\n      } //If this is a boundary edge, don't flip it\n\n\n      if (y < 0) {\n        continue;\n      } //If edge is in circle, flip it\n\n\n      if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n        stack.push(a, b);\n      }\n    }\n  }\n\n  while (stack.length > 0) {\n    var b = stack.pop();\n    var a = stack.pop(); //Find opposite pairs\n\n    var x = -1,\n        y = -1;\n    var star = stars[a];\n\n    for (var i = 1; i < star.length; i += 2) {\n      var s = star[i - 1];\n      var t = star[i];\n\n      if (s === b) {\n        y = t;\n      } else if (t === b) {\n        x = s;\n      }\n    } //If x/y are both valid then skip edge\n\n\n    if (x < 0 || y < 0) {\n      continue;\n    } //If edge is now delaunay, then don't flip it\n\n\n    if (inCircle(points[a], points[b], points[x], points[y]) >= 0) {\n      continue;\n    } //Flip the edge\n\n\n    triangulation.flip(a, b); //Test flipping neighboring edges\n\n    testFlip(points, triangulation, stack, x, a, y);\n    testFlip(points, triangulation, stack, a, y, x);\n    testFlip(points, triangulation, stack, y, b, x);\n    testFlip(points, triangulation, stack, b, x, y);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}