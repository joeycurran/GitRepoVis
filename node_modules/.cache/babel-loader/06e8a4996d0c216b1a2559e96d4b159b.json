{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar turfArea = require('@turf/area');\n\nvar turfCentroid = require('@turf/centroid');\n\nvar Lib = require('../../lib');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar Drawing = require('../../components/drawing');\n\nvar makeBlank = require('../../lib/geojson_utils').makeBlank;\n\nvar feature2polygons = require('../choropleth/plot').feature2polygons;\n/* N.B.\n *\n * We fetch the GeoJSON files \"ourselves\" (during\n * mapbox.prototype.fetchMapData) where they are stored in a global object\n * named `PlotlyGeoAssets` (same as for topojson files in `geo` subplots).\n *\n * Mapbox does allow using URLs as geojson sources, but does NOT allow filtering\n * features by feature `id` that are not numbers (more info in:\n * https://github.com/mapbox/mapbox-gl-js/issues/8088).\n */\n\n\nfunction convert(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var isVisible = trace.visible === true && trace._length !== 0;\n  var fill = {\n    layout: {\n      visibility: 'none'\n    },\n    paint: {}\n  };\n  var line = {\n    layout: {\n      visibility: 'none'\n    },\n    paint: {}\n  };\n  var opts = trace._opts = {\n    fill: fill,\n    line: line,\n    geojson: makeBlank()\n  };\n  if (!isVisible) return opts;\n  var geojsonIn = typeof trace.geojson === 'string' ? (window.PlotlyGeoAssets || {})[trace.geojson] : trace.geojson; // This should not happen, but just in case something goes\n  // really wrong when fetching the GeoJSON\n\n  if (!Lib.isPlainObject(geojsonIn)) {\n    Lib.error('Oops ... something when wrong when fetching ' + trace.geojson);\n    return opts;\n  }\n\n  var lookup = {};\n  var featuresOut = [];\n  var i;\n\n  for (i = 0; i < calcTrace.length; i++) {\n    var cdi = calcTrace[i];\n    if (cdi.loc) lookup[cdi.loc] = cdi;\n  }\n\n  var sclFunc = Colorscale.makeColorScaleFuncFromTrace(trace);\n  var marker = trace.marker;\n  var markerLine = marker.line || {};\n  var opacityFn;\n\n  if (Lib.isArrayOrTypedArray(marker.opacity)) {\n    opacityFn = function (d) {\n      var mo = d.mo;\n      return isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n    };\n  }\n\n  var lineColorFn;\n\n  if (Lib.isArrayOrTypedArray(markerLine.color)) {\n    lineColorFn = function (d) {\n      return d.mlc;\n    };\n  }\n\n  var lineWidthFn;\n\n  if (Lib.isArrayOrTypedArray(markerLine.width)) {\n    lineWidthFn = function (d) {\n      return d.mlw;\n    };\n  }\n\n  function appendFeature(fIn) {\n    var cdi = lookup[fIn.id];\n\n    if (cdi) {\n      var geometry = fIn.geometry;\n\n      if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        var props = {\n          fc: sclFunc(cdi.z)\n        };\n        if (opacityFn) props.mo = opacityFn(cdi);\n        if (lineColorFn) props.mlc = lineColorFn(cdi);\n        if (lineWidthFn) props.mlw = lineWidthFn(cdi);\n        var fOut = {\n          type: 'Feature',\n          geometry: geometry,\n          properties: props\n        };\n        cdi._polygons = feature2polygons(fOut);\n        cdi.ct = findCentroid(fOut);\n        cdi.fIn = fIn;\n        cdi.fOut = fOut;\n        featuresOut.push(fOut);\n      } else {\n        Lib.log(['Location with id', cdi.loc, 'does not have a valid GeoJSON geometry,', 'choroplethmapbox traces only support *Polygon* and *MultiPolygon* geometries.'].join(' '));\n      }\n    } // remove key from lookup, so that we can track (if any)\n    // the locations that did not have a corresponding GeoJSON feature\n\n\n    delete lookup[fIn.id];\n  }\n\n  switch (geojsonIn.type) {\n    case 'FeatureCollection':\n      var featuresIn = geojsonIn.features;\n\n      for (i = 0; i < featuresIn.length; i++) {\n        appendFeature(featuresIn[i]);\n      }\n\n      break;\n\n    case 'Feature':\n      appendFeature(geojsonIn);\n      break;\n\n    default:\n      Lib.warn(['Invalid GeoJSON type', (geojsonIn.type || 'none') + ',', 'choroplethmapbox traces only support *FeatureCollection* and *Feature* types.'].join(' '));\n      return opts;\n  }\n\n  for (var loc in lookup) {\n    Lib.log('Location with id ' + loc + ' does not have a matching feature');\n  }\n\n  var opacitySetting = opacityFn ? {\n    type: 'identity',\n    property: 'mo'\n  } : marker.opacity;\n  Lib.extendFlat(fill.paint, {\n    'fill-color': {\n      type: 'identity',\n      property: 'fc'\n    },\n    'fill-opacity': opacitySetting\n  });\n  Lib.extendFlat(line.paint, {\n    'line-color': lineColorFn ? {\n      type: 'identity',\n      property: 'mlc'\n    } : markerLine.color,\n    'line-width': lineWidthFn ? {\n      type: 'identity',\n      property: 'mlw'\n    } : markerLine.width,\n    'line-opacity': opacitySetting\n  });\n  fill.layout.visibility = 'visible';\n  line.layout.visibility = 'visible';\n  opts.geojson = {\n    type: 'FeatureCollection',\n    features: featuresOut\n  };\n  convertOnSelect(calcTrace);\n  return opts;\n}\n\nfunction convertOnSelect(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var opts = trace._opts;\n  var opacitySetting;\n\n  if (trace.selectedpoints) {\n    var fns = Drawing.makeSelectedPointStyleFns(trace);\n\n    for (var i = 0; i < calcTrace.length; i++) {\n      var cdi = calcTrace[i];\n\n      if (cdi.fOut) {\n        cdi.fOut.properties.mo2 = fns.selectedOpacityFn(cdi);\n      }\n    }\n\n    opacitySetting = {\n      type: 'identity',\n      property: 'mo2'\n    };\n  } else {\n    opacitySetting = Lib.isArrayOrTypedArray(trace.marker.opacity) ? {\n      type: 'identity',\n      property: 'mo'\n    } : trace.marker.opacity;\n  }\n\n  Lib.extendFlat(opts.fill.paint, {\n    'fill-opacity': opacitySetting\n  });\n  Lib.extendFlat(opts.line.paint, {\n    'line-opacity': opacitySetting\n  });\n  return opts;\n} // TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\n\n\nfunction findCentroid(feature) {\n  var geometry = feature.geometry;\n  var poly;\n\n  if (geometry.type === 'MultiPolygon') {\n    var coords = geometry.coordinates;\n    var maxArea = 0;\n\n    for (var i = 0; i < coords.length; i++) {\n      var polyi = {\n        type: 'Polygon',\n        coordinates: coords[i]\n      };\n      var area = turfArea.default(polyi);\n\n      if (area > maxArea) {\n        maxArea = area;\n        poly = polyi;\n      }\n    }\n  } else {\n    poly = geometry;\n  }\n\n  return turfCentroid.default(poly).geometry.coordinates;\n}\n\nmodule.exports = {\n  convert: convert,\n  convertOnSelect: convertOnSelect\n};","map":null,"metadata":{},"sourceType":"script"}