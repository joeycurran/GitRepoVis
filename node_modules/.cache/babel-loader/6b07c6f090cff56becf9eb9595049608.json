{"ast":null,"code":"module.exports = vectorizeText;\nmodule.exports.processPixels = processPixels;\n\nvar surfaceNets = require('surface-nets');\n\nvar ndarray = require('ndarray');\n\nvar simplify = require('simplify-planar-graph');\n\nvar cleanPSLG = require('clean-pslg');\n\nvar cdt2d = require('cdt2d');\n\nvar toPolygonCrappy = require('planar-graph-to-polyline');\n\nvar TAG_bold = \"b\";\nvar CHR_bold = 'b|';\nvar TAG_italic = \"i\";\nvar CHR_italic = 'i|';\nvar TAG_super = \"sup\";\nvar CHR_super0 = '+';\nvar CHR_super = '+1';\nvar TAG_sub = \"sub\";\nvar CHR_sub0 = '-';\nvar CHR_sub = '-1';\n\nfunction parseTag(tag, TAG_CHR, str, map) {\n  var opnTag = \"<\" + tag + \">\";\n  var clsTag = \"</\" + tag + \">\";\n  var nOPN = opnTag.length;\n  var nCLS = clsTag.length;\n  var isRecursive = TAG_CHR[0] === CHR_super0 || TAG_CHR[0] === CHR_sub0;\n  var a = 0;\n  var b = -nCLS;\n\n  while (a > -1) {\n    a = str.indexOf(opnTag, a);\n    if (a === -1) break;\n    b = str.indexOf(clsTag, a + nOPN);\n    if (b === -1) break;\n    if (b <= a) break;\n\n    for (var i = a; i < b + nCLS; ++i) {\n      if (i < a + nOPN || i >= b) {\n        map[i] = null;\n        str = str.substr(0, i) + \" \" + str.substr(i + 1);\n      } else {\n        if (map[i] !== null) {\n          var pos = map[i].indexOf(TAG_CHR[0]);\n\n          if (pos === -1) {\n            map[i] += TAG_CHR;\n          } else {\n            // i.e. to handle multiple sub/super-scripts\n            if (isRecursive) {\n              // i.e to increase the sub/sup number\n              map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2);\n            }\n          }\n        }\n      }\n    }\n\n    var start = a + nOPN;\n    var remainingStr = str.substr(start, b - start);\n    var c = remainingStr.indexOf(opnTag);\n    if (c !== -1) a = c;else a = b + nCLS;\n  }\n\n  return map;\n}\n\nfunction transformPositions(positions, options, size) {\n  var align = options.textAlign || \"start\";\n  var baseline = options.textBaseline || \"alphabetic\";\n  var lo = [1 << 30, 1 << 30];\n  var hi = [0, 0];\n  var n = positions.length;\n\n  for (var i = 0; i < n; ++i) {\n    var p = positions[i];\n\n    for (var j = 0; j < 2; ++j) {\n      lo[j] = Math.min(lo[j], p[j]) | 0;\n      hi[j] = Math.max(hi[j], p[j]) | 0;\n    }\n  }\n\n  var xShift = 0;\n\n  switch (align) {\n    case \"center\":\n      xShift = -0.5 * (lo[0] + hi[0]);\n      break;\n\n    case \"right\":\n    case \"end\":\n      xShift = -hi[0];\n      break;\n\n    case \"left\":\n    case \"start\":\n      xShift = -lo[0];\n      break;\n\n    default:\n      throw new Error(\"vectorize-text: Unrecognized textAlign: '\" + align + \"'\");\n  }\n\n  var yShift = 0;\n\n  switch (baseline) {\n    case \"hanging\":\n    case \"top\":\n      yShift = -lo[1];\n      break;\n\n    case \"middle\":\n      yShift = -0.5 * (lo[1] + hi[1]);\n      break;\n\n    case \"alphabetic\":\n    case \"ideographic\":\n      yShift = -3 * size;\n      break;\n\n    case \"bottom\":\n      yShift = -hi[1];\n      break;\n\n    default:\n      throw new Error(\"vectorize-text: Unrecoginized textBaseline: '\" + baseline + \"'\");\n  }\n\n  var scale = 1.0 / size;\n\n  if (\"lineHeight\" in options) {\n    scale *= +options.lineHeight;\n  } else if (\"width\" in options) {\n    scale = options.width / (hi[0] - lo[0]);\n  } else if (\"height\" in options) {\n    scale = options.height / (hi[1] - lo[1]);\n  }\n\n  return positions.map(function (p) {\n    return [scale * (p[0] + xShift), scale * (p[1] + yShift)];\n  });\n}\n\nfunction getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {\n  rawString = rawString.replace(/\\n/g, ''); // don't accept \\n in the input\n\n  if (styletags.breaklines === true) {\n    rawString = rawString.replace(/\\<br\\>/g, '\\n'); // replace <br> tags with \\n in the string\n  } else {\n    rawString = rawString.replace(/\\<br\\>/g, ' '); // don't accept <br> tags in the input and replace with space in this case\n  }\n\n  var activeStyle = \"\";\n  var map = [];\n\n  for (j = 0; j < rawString.length; ++j) {\n    map[j] = activeStyle;\n  }\n\n  if (styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map);\n  if (styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map);\n  if (styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map);\n  if (styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map);\n  var allStyles = [];\n  var plainText = \"\";\n\n  for (j = 0; j < rawString.length; ++j) {\n    if (map[j] !== null) {\n      plainText += rawString[j];\n      allStyles.push(map[j]);\n    }\n  }\n\n  var allTexts = plainText.split('\\n');\n  var numberOfLines = allTexts.length;\n  var lineHeight = Math.round(lineSpacing * fontSize);\n  var offsetX = fontSize;\n  var offsetY = fontSize * 2;\n  var maxWidth = 0;\n  var minHeight = numberOfLines * lineHeight + offsetY;\n\n  if (canvas.height < minHeight) {\n    canvas.height = minHeight;\n  }\n\n  context.fillStyle = \"#000\";\n  context.fillRect(0, 0, canvas.width, canvas.height);\n  context.fillStyle = \"#fff\";\n  var i, j, xPos, yPos, zPos;\n  var nDone = 0;\n  var buffer = \"\";\n\n  function writeBuffer() {\n    if (buffer !== \"\") {\n      var delta = context.measureText(buffer).width;\n      context.fillText(buffer, offsetX + xPos, offsetY + yPos);\n      xPos += delta;\n    }\n  }\n\n  function getTextFontSize() {\n    return \"\" + Math.round(zPos) + \"px \";\n  }\n\n  function changeStyle(oldStyle, newStyle) {\n    var ctxFont = \"\" + context.font;\n\n    if (styletags.subscripts === true) {\n      var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);\n      var newIndex_Sub = newStyle.indexOf(CHR_sub0);\n      var oldSub = oldIndex_Sub > -1 ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;\n      var newSub = newIndex_Sub > -1 ? parseInt(newStyle[1 + newIndex_Sub]) : 0;\n\n      if (oldSub !== newSub) {\n        ctxFont = ctxFont.replace(getTextFontSize(), \"?px \");\n        zPos *= Math.pow(0.75, newSub - oldSub);\n        ctxFont = ctxFont.replace(\"?px \", getTextFontSize());\n      }\n\n      yPos += 0.25 * lineHeight * (newSub - oldSub);\n    }\n\n    if (styletags.superscripts === true) {\n      var oldIndex_Super = oldStyle.indexOf(CHR_super0);\n      var newIndex_Super = newStyle.indexOf(CHR_super0);\n      var oldSuper = oldIndex_Super > -1 ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;\n      var newSuper = newIndex_Super > -1 ? parseInt(newStyle[1 + newIndex_Super]) : 0;\n\n      if (oldSuper !== newSuper) {\n        ctxFont = ctxFont.replace(getTextFontSize(), \"?px \");\n        zPos *= Math.pow(0.75, newSuper - oldSuper);\n        ctxFont = ctxFont.replace(\"?px \", getTextFontSize());\n      }\n\n      yPos -= 0.25 * lineHeight * (newSuper - oldSuper);\n    }\n\n    if (styletags.bolds === true) {\n      var wasBold = oldStyle.indexOf(CHR_bold) > -1;\n      var is_Bold = newStyle.indexOf(CHR_bold) > -1;\n\n      if (!wasBold && is_Bold) {\n        if (wasItalic) {\n          ctxFont = ctxFont.replace(\"italic \", \"italic bold \");\n        } else {\n          ctxFont = \"bold \" + ctxFont;\n        }\n      }\n\n      if (wasBold && !is_Bold) {\n        ctxFont = ctxFont.replace(\"bold \", '');\n      }\n    }\n\n    if (styletags.italics === true) {\n      var wasItalic = oldStyle.indexOf(CHR_italic) > -1;\n      var is_Italic = newStyle.indexOf(CHR_italic) > -1;\n\n      if (!wasItalic && is_Italic) {\n        ctxFont = \"italic \" + ctxFont;\n      }\n\n      if (wasItalic && !is_Italic) {\n        ctxFont = ctxFont.replace(\"italic \", '');\n      }\n    }\n\n    context.font = ctxFont;\n  }\n\n  for (i = 0; i < numberOfLines; ++i) {\n    var txt = allTexts[i] + '\\n';\n    xPos = 0;\n    yPos = i * lineHeight;\n    zPos = fontSize;\n    buffer = \"\";\n\n    for (j = 0; j < txt.length; ++j) {\n      var style = j + nDone < allStyles.length ? allStyles[j + nDone] : allStyles[allStyles.length - 1];\n\n      if (activeStyle === style) {\n        buffer += txt[j];\n      } else {\n        writeBuffer();\n        buffer = txt[j];\n\n        if (style !== undefined) {\n          changeStyle(activeStyle, style);\n          activeStyle = style;\n        }\n      }\n    }\n\n    writeBuffer();\n    nDone += txt.length;\n    var width = Math.round(xPos + 2 * offsetX) | 0;\n    if (maxWidth < width) maxWidth = width;\n  } //Cut pixels from image\n\n\n  var xCut = maxWidth;\n  var yCut = offsetY + lineHeight * numberOfLines;\n  var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4]);\n  return pixels.pick(-1, -1, 0).transpose(1, 0);\n}\n\nfunction getContour(pixels, doSimplify) {\n  var contour = surfaceNets(pixels, 128);\n\n  if (doSimplify) {\n    return simplify(contour.cells, contour.positions, 0.25);\n  }\n\n  return {\n    edges: contour.cells,\n    positions: contour.positions\n  };\n}\n\nfunction processPixelsImpl(pixels, options, size, simplify) {\n  //Extract contour\n  var contour = getContour(pixels, simplify); //Apply warp to positions\n\n  var positions = transformPositions(contour.positions, options, size);\n  var edges = contour.edges;\n  var flip = \"ccw\" === options.orientation; //Clean up the PSLG, resolve self intersections, etc.\n\n  cleanPSLG(positions, edges); //If triangulate flag passed, triangulate the result\n\n  if (options.polygons || options.polygon || options.polyline) {\n    var result = toPolygonCrappy(edges, positions);\n    var nresult = new Array(result.length);\n\n    for (var i = 0; i < result.length; ++i) {\n      var loops = result[i];\n      var nloops = new Array(loops.length);\n\n      for (var j = 0; j < loops.length; ++j) {\n        var loop = loops[j];\n        var nloop = new Array(loop.length);\n\n        for (var k = 0; k < loop.length; ++k) {\n          nloop[k] = positions[loop[k]].slice();\n        }\n\n        if (flip) {\n          nloop.reverse();\n        }\n\n        nloops[j] = nloop;\n      }\n\n      nresult[i] = nloops;\n    }\n\n    return nresult;\n  } else if (options.triangles || options.triangulate || options.triangle) {\n    return {\n      cells: cdt2d(positions, edges, {\n        delaunay: false,\n        exterior: false,\n        interior: true\n      }),\n      positions: positions\n    };\n  } else {\n    return {\n      edges: edges,\n      positions: positions\n    };\n  }\n}\n\nfunction processPixels(pixels, options, size) {\n  try {\n    return processPixelsImpl(pixels, options, size, true);\n  } catch (e) {}\n\n  try {\n    return processPixelsImpl(pixels, options, size, false);\n  } catch (e) {}\n\n  if (options.polygons || options.polyline || options.polygon) {\n    return [];\n  }\n\n  if (options.triangles || options.triangulate || options.triangle) {\n    return {\n      cells: [],\n      positions: []\n    };\n  }\n\n  return {\n    edges: [],\n    positions: []\n  };\n}\n\nfunction vectorizeText(str, canvas, context, options) {\n  var size = 64;\n  var lineSpacing = 1.25;\n  var styletags = {\n    breaklines: false,\n    bolds: false,\n    italics: false,\n    subscripts: false,\n    superscripts: false\n  };\n\n  if (options) {\n    if (options.size && options.size > 0) size = options.size;\n    if (options.lineSpacing && options.lineSpacing > 0) lineSpacing = options.lineSpacing;\n    if (options.styletags && options.styletags.breaklines) styletags.breaklines = options.styletags.breaklines ? true : false;\n    if (options.styletags && options.styletags.bolds) styletags.bolds = options.styletags.bolds ? true : false;\n    if (options.styletags && options.styletags.italics) styletags.italics = options.styletags.italics ? true : false;\n    if (options.styletags && options.styletags.subscripts) styletags.subscripts = options.styletags.subscripts ? true : false;\n    if (options.styletags && options.styletags.superscripts) styletags.superscripts = options.styletags.superscripts ? true : false;\n  }\n\n  context.font = [options.fontStyle, options.fontVariant, options.fontWeight, size + \"px\", options.font].filter(function (d) {\n    return d;\n  }).join(\" \");\n  context.textAlign = \"start\";\n  context.textBaseline = \"alphabetic\";\n  context.direction = \"ltr\";\n  var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags);\n  return processPixels(pixels, options, size);\n}","map":null,"metadata":{},"sourceType":"script"}