{"ast":null,"code":"module.exports = preprocessPolygon;\n\nvar orient = require('robust-orientation')[3];\n\nvar makeSlabs = require('slab-decomposition');\n\nvar makeIntervalTree = require('interval-tree-1d');\n\nvar bsearch = require('binary-search-bounds');\n\nfunction visitInterval() {\n  return true;\n}\n\nfunction intervalSearch(table) {\n  return function (x, y) {\n    var tree = table[x];\n\n    if (tree) {\n      return !!tree.queryPoint(y, visitInterval);\n    }\n\n    return false;\n  };\n}\n\nfunction buildVerticalIndex(segments) {\n  var table = {};\n\n  for (var i = 0; i < segments.length; ++i) {\n    var s = segments[i];\n    var x = s[0][0];\n    var y0 = s[0][1];\n    var y1 = s[1][1];\n    var p = [Math.min(y0, y1), Math.max(y0, y1)];\n\n    if (x in table) {\n      table[x].push(p);\n    } else {\n      table[x] = [p];\n    }\n  }\n\n  var intervalTable = {};\n  var keys = Object.keys(table);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var segs = table[keys[i]];\n    intervalTable[keys[i]] = makeIntervalTree(segs);\n  }\n\n  return intervalSearch(intervalTable);\n}\n\nfunction buildSlabSearch(slabs, coordinates) {\n  return function (p) {\n    var bucket = bsearch.le(coordinates, p[0]);\n\n    if (bucket < 0) {\n      return 1;\n    }\n\n    var root = slabs[bucket];\n\n    if (!root) {\n      if (bucket > 0 && coordinates[bucket] === p[0]) {\n        root = slabs[bucket - 1];\n      } else {\n        return 1;\n      }\n    }\n\n    var lastOrientation = 1;\n\n    while (root) {\n      var s = root.key;\n      var o = orient(p, s[0], s[1]);\n\n      if (s[0][0] < s[1][0]) {\n        if (o < 0) {\n          root = root.left;\n        } else if (o > 0) {\n          lastOrientation = -1;\n          root = root.right;\n        } else {\n          return 0;\n        }\n      } else {\n        if (o > 0) {\n          root = root.left;\n        } else if (o < 0) {\n          lastOrientation = 1;\n          root = root.right;\n        } else {\n          return 0;\n        }\n      }\n    }\n\n    return lastOrientation;\n  };\n}\n\nfunction classifyEmpty(p) {\n  return 1;\n}\n\nfunction createClassifyVertical(testVertical) {\n  return function classify(p) {\n    if (testVertical(p[0], p[1])) {\n      return 0;\n    }\n\n    return 1;\n  };\n}\n\nfunction createClassifyPointDegen(testVertical, testNormal) {\n  return function classify(p) {\n    if (testVertical(p[0], p[1])) {\n      return 0;\n    }\n\n    return testNormal(p);\n  };\n}\n\nfunction preprocessPolygon(loops) {\n  //Compute number of loops\n  var numLoops = loops.length; //Unpack segments\n\n  var segments = [];\n  var vsegments = [];\n  var ptr = 0;\n\n  for (var i = 0; i < numLoops; ++i) {\n    var loop = loops[i];\n    var numVertices = loop.length;\n\n    for (var s = numVertices - 1, t = 0; t < numVertices; s = t++) {\n      var a = loop[s];\n      var b = loop[t];\n\n      if (a[0] === b[0]) {\n        vsegments.push([a, b]);\n      } else {\n        segments.push([a, b]);\n      }\n    }\n  } //Degenerate case: All loops are empty\n\n\n  if (segments.length === 0) {\n    if (vsegments.length === 0) {\n      return classifyEmpty;\n    } else {\n      return createClassifyVertical(buildVerticalIndex(vsegments));\n    }\n  } //Build slab decomposition\n\n\n  var slabs = makeSlabs(segments);\n  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);\n\n  if (vsegments.length === 0) {\n    return testSlab;\n  } else {\n    return createClassifyPointDegen(buildVerticalIndex(vsegments), testSlab);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}