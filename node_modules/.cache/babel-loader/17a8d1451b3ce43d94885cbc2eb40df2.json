{"ast":null,"code":"'use strict';\n\nexports.shader = getShaderReference;\nexports.program = createProgram;\n\nvar GLError = require(\"./GLError\");\n\nvar formatCompilerError = require('gl-format-compiler-error');\n\nvar weakMap = typeof WeakMap === 'undefined' ? require('weakmap-shim') : WeakMap;\nvar CACHE = new weakMap();\nvar SHADER_COUNTER = 0;\n\nfunction ShaderReference(id, src, type, shader, programs, count, cache) {\n  this.id = id;\n  this.src = src;\n  this.type = type;\n  this.shader = shader;\n  this.count = count;\n  this.programs = [];\n  this.cache = cache;\n}\n\nShaderReference.prototype.dispose = function () {\n  if (--this.count === 0) {\n    var cache = this.cache;\n    var gl = cache.gl; //Remove program references\n\n    var programs = this.programs;\n\n    for (var i = 0, n = programs.length; i < n; ++i) {\n      var p = cache.programs[programs[i]];\n\n      if (p) {\n        delete cache.programs[i];\n        gl.deleteProgram(p);\n      }\n    } //Remove shader reference\n\n\n    gl.deleteShader(this.shader);\n    delete cache.shaders[this.type === gl.FRAGMENT_SHADER | 0][this.src];\n  }\n};\n\nfunction ContextCache(gl) {\n  this.gl = gl;\n  this.shaders = [{}, {}];\n  this.programs = {};\n}\n\nvar proto = ContextCache.prototype;\n\nfunction compileShader(gl, type, src) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    var errLog = gl.getShaderInfoLog(shader);\n\n    try {\n      var fmt = formatCompilerError(errLog, src, type);\n    } catch (e) {\n      console.warn('Failed to format compiler error: ' + e);\n      throw new GLError(errLog, 'Error compiling shader:\\n' + errLog);\n    }\n\n    throw new GLError(errLog, fmt.short, fmt.long);\n  }\n\n  return shader;\n}\n\nproto.getShaderReference = function (type, src) {\n  var gl = this.gl;\n  var shaders = this.shaders[type === gl.FRAGMENT_SHADER | 0];\n  var shader = shaders[src];\n\n  if (!shader || !gl.isShader(shader.shader)) {\n    var shaderObj = compileShader(gl, type, src);\n    shader = shaders[src] = new ShaderReference(SHADER_COUNTER++, src, type, shaderObj, [], 1, this);\n  } else {\n    shader.count += 1;\n  }\n\n  return shader;\n};\n\nfunction linkProgram(gl, vshader, fshader, attribs, locations) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vshader);\n  gl.attachShader(program, fshader);\n\n  for (var i = 0; i < attribs.length; ++i) {\n    gl.bindAttribLocation(program, locations[i], attribs[i]);\n  }\n\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    var errLog = gl.getProgramInfoLog(program);\n    throw new GLError(errLog, 'Error linking program: ' + errLog);\n  }\n\n  return program;\n}\n\nproto.getProgram = function (vref, fref, attribs, locations) {\n  var token = [vref.id, fref.id, attribs.join(':'), locations.join(':')].join('@');\n  var prog = this.programs[token];\n\n  if (!prog || !this.gl.isProgram(prog)) {\n    this.programs[token] = prog = linkProgram(this.gl, vref.shader, fref.shader, attribs, locations);\n    vref.programs.push(token);\n    fref.programs.push(token);\n  }\n\n  return prog;\n};\n\nfunction getCache(gl) {\n  var ctxCache = CACHE.get(gl);\n\n  if (!ctxCache) {\n    ctxCache = new ContextCache(gl);\n    CACHE.set(gl, ctxCache);\n  }\n\n  return ctxCache;\n}\n\nfunction getShaderReference(gl, type, src) {\n  return getCache(gl).getShaderReference(type, src);\n}\n\nfunction createProgram(gl, vref, fref, attribs, locations) {\n  return getCache(gl).getProgram(vref, fref, attribs, locations);\n}","map":null,"metadata":{},"sourceType":"script"}