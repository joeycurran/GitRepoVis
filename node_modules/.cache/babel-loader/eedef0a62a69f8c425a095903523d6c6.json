{"ast":null,"code":"'use strict';\n\nmodule.exports = createTextElements;\n\nvar createBuffer = require('gl-buffer');\n\nvar createShader = require('gl-shader');\n\nvar getText = require('text-cache');\n\nvar bsearch = require('binary-search-bounds');\n\nvar shaders = require('./shaders');\n\nfunction TextElements(plot, vbo, shader) {\n  this.plot = plot;\n  this.vbo = vbo;\n  this.shader = shader;\n  this.tickOffset = [[], []];\n  this.tickX = [[], []];\n  this.labelOffset = [0, 0];\n  this.labelCount = [0, 0];\n}\n\nvar proto = TextElements.prototype;\n\nproto.drawTicks = function () {\n  var DATA_AXIS = [0, 0];\n  var SCREEN_OFFSET = [0, 0];\n  var ZERO_2 = [0, 0];\n  return function (axis) {\n    var plot = this.plot;\n    var shader = this.shader;\n    var tickX = this.tickX[axis];\n    var tickOffset = this.tickOffset[axis];\n    var gl = plot.gl;\n    var viewBox = plot.viewBox;\n    var dataBox = plot.dataBox;\n    var screenBox = plot.screenBox;\n    var pixelRatio = plot.pixelRatio;\n    var tickEnable = plot.tickEnable;\n    var tickPad = plot.tickPad;\n    var textColor = plot.tickColor;\n    var textAngle = plot.tickAngle; // todo check if this should be used (now unused)\n    // var tickLength  = plot.tickMarkLength\n\n    var labelEnable = plot.labelEnable;\n    var labelPad = plot.labelPad;\n    var labelColor = plot.labelColor;\n    var labelAngle = plot.labelAngle;\n    var labelOffset = this.labelOffset[axis];\n    var labelCount = this.labelCount[axis];\n    var start = bsearch.lt(tickX, dataBox[axis]);\n    var end = bsearch.le(tickX, dataBox[axis + 2]);\n    DATA_AXIS[0] = DATA_AXIS[1] = 0;\n    DATA_AXIS[axis] = 1;\n    SCREEN_OFFSET[axis] = (viewBox[2 + axis] + viewBox[axis]) / (screenBox[2 + axis] - screenBox[axis]) - 1.0;\n    var screenScale = 2.0 / screenBox[2 + (axis ^ 1)] - screenBox[axis ^ 1];\n    SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[axis ^ 1] - 1.0;\n\n    if (tickEnable[axis]) {\n      SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * tickPad[axis];\n\n      if (start < end && tickOffset[end] > tickOffset[start]) {\n        shader.uniforms.dataAxis = DATA_AXIS;\n        shader.uniforms.screenOffset = SCREEN_OFFSET;\n        shader.uniforms.color = textColor[axis];\n        shader.uniforms.angle = textAngle[axis];\n        gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);\n      }\n    }\n\n    if (labelEnable[axis] && labelCount) {\n      SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * labelPad[axis];\n      shader.uniforms.dataAxis = ZERO_2;\n      shader.uniforms.screenOffset = SCREEN_OFFSET;\n      shader.uniforms.color = labelColor[axis];\n      shader.uniforms.angle = labelAngle[axis];\n      gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);\n    }\n\n    SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[2 + (axis ^ 1)] - 1.0;\n\n    if (tickEnable[axis + 2]) {\n      SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * tickPad[axis + 2];\n\n      if (start < end && tickOffset[end] > tickOffset[start]) {\n        shader.uniforms.dataAxis = DATA_AXIS;\n        shader.uniforms.screenOffset = SCREEN_OFFSET;\n        shader.uniforms.color = textColor[axis + 2];\n        shader.uniforms.angle = textAngle[axis + 2];\n        gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);\n      }\n    }\n\n    if (labelEnable[axis + 2] && labelCount) {\n      SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * labelPad[axis + 2];\n      shader.uniforms.dataAxis = ZERO_2;\n      shader.uniforms.screenOffset = SCREEN_OFFSET;\n      shader.uniforms.color = labelColor[axis + 2];\n      shader.uniforms.angle = labelAngle[axis + 2];\n      gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);\n    }\n  };\n}();\n\nproto.drawTitle = function () {\n  var DATA_AXIS = [0, 0];\n  var SCREEN_OFFSET = [0, 0];\n  return function () {\n    var plot = this.plot;\n    var shader = this.shader;\n    var gl = plot.gl;\n    var screenBox = plot.screenBox;\n    var titleCenter = plot.titleCenter;\n    var titleAngle = plot.titleAngle;\n    var titleColor = plot.titleColor;\n    var pixelRatio = plot.pixelRatio;\n\n    if (!this.titleCount) {\n      return;\n    }\n\n    for (var i = 0; i < 2; ++i) {\n      SCREEN_OFFSET[i] = 2.0 * (titleCenter[i] * pixelRatio - screenBox[i]) / (screenBox[2 + i] - screenBox[i]) - 1;\n    }\n\n    shader.bind();\n    shader.uniforms.dataAxis = DATA_AXIS;\n    shader.uniforms.screenOffset = SCREEN_OFFSET;\n    shader.uniforms.angle = titleAngle;\n    shader.uniforms.color = titleColor;\n    gl.drawArrays(gl.TRIANGLES, this.titleOffset, this.titleCount);\n  };\n}();\n\nproto.bind = function () {\n  var DATA_SHIFT = [0, 0];\n  var DATA_SCALE = [0, 0];\n  var TEXT_SCALE = [0, 0];\n  return function () {\n    var plot = this.plot;\n    var shader = this.shader;\n    var bounds = plot._tickBounds;\n    var dataBox = plot.dataBox;\n    var screenBox = plot.screenBox;\n    var viewBox = plot.viewBox;\n    shader.bind(); //Set up coordinate scaling uniforms\n\n    for (var i = 0; i < 2; ++i) {\n      var lo = bounds[i];\n      var hi = bounds[i + 2];\n      var boundScale = hi - lo;\n      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n      var dataWidth = dataBox[i + 2] - dataBox[i];\n      var viewLo = viewBox[i];\n      var viewHi = viewBox[i + 2];\n      var viewScale = viewHi - viewLo;\n      var screenLo = screenBox[i];\n      var screenHi = screenBox[i + 2];\n      var screenScale = screenHi - screenLo;\n      DATA_SCALE[i] = 2.0 * boundScale / dataWidth * viewScale / screenScale;\n      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth * viewScale / screenScale;\n    }\n\n    TEXT_SCALE[1] = 2.0 * plot.pixelRatio / (screenBox[3] - screenBox[1]);\n    TEXT_SCALE[0] = TEXT_SCALE[1] * (screenBox[3] - screenBox[1]) / (screenBox[2] - screenBox[0]);\n    shader.uniforms.dataScale = DATA_SCALE;\n    shader.uniforms.dataShift = DATA_SHIFT;\n    shader.uniforms.textScale = TEXT_SCALE; //Set attributes\n\n    this.vbo.bind();\n    shader.attributes.textCoordinate.pointer();\n  };\n}();\n\nproto.update = function (options) {\n  var vertices = [];\n  var axesTicks = options.ticks;\n  var bounds = options.bounds;\n  var i, j, k, data, scale, dimension;\n\n  for (dimension = 0; dimension < 2; ++dimension) {\n    var offsets = [Math.floor(vertices.length / 3)],\n        tickX = [-Infinity]; //Copy vertices over to buffer\n\n    var ticks = axesTicks[dimension];\n\n    for (i = 0; i < ticks.length; ++i) {\n      var tick = ticks[i];\n      var x = tick.x;\n      var text = tick.text;\n      var font = tick.font || 'sans-serif';\n      scale = tick.fontSize || 12;\n      var coordScale = 1.0 / (bounds[dimension + 2] - bounds[dimension]);\n      var coordShift = bounds[dimension];\n      var rows = text.split('\\n');\n\n      for (var r = 0; r < rows.length; r++) {\n        data = getText(font, rows[r]).data;\n\n        for (j = 0; j < data.length; j += 2) {\n          vertices.push(data[j] * scale, -data[j + 1] * scale - r * scale * 1.2, (x - coordShift) * coordScale);\n        }\n      }\n\n      offsets.push(Math.floor(vertices.length / 3));\n      tickX.push(x);\n    }\n\n    this.tickOffset[dimension] = offsets;\n    this.tickX[dimension] = tickX;\n  } //Add labels\n\n\n  for (dimension = 0; dimension < 2; ++dimension) {\n    this.labelOffset[dimension] = Math.floor(vertices.length / 3);\n    data = getText(options.labelFont[dimension], options.labels[dimension], {\n      textAlign: 'center'\n    }).data;\n    scale = options.labelSize[dimension];\n\n    for (i = 0; i < data.length; i += 2) {\n      vertices.push(data[i] * scale, -data[i + 1] * scale, 0);\n    }\n\n    this.labelCount[dimension] = Math.floor(vertices.length / 3) - this.labelOffset[dimension];\n  } //Add title\n\n\n  this.titleOffset = Math.floor(vertices.length / 3);\n  data = getText(options.titleFont, options.title).data;\n  scale = options.titleSize;\n\n  for (i = 0; i < data.length; i += 2) {\n    vertices.push(data[i] * scale, -data[i + 1] * scale, 0);\n  }\n\n  this.titleCount = Math.floor(vertices.length / 3) - this.titleOffset; //Upload new vertices\n\n  this.vbo.update(vertices);\n};\n\nproto.dispose = function () {\n  this.vbo.dispose();\n  this.shader.dispose();\n};\n\nfunction createTextElements(plot) {\n  var gl = plot.gl;\n  var vbo = createBuffer(gl);\n  var shader = createShader(gl, shaders.textVert, shaders.textFrag);\n  var text = new TextElements(plot, vbo, shader);\n  return text;\n}","map":null,"metadata":{},"sourceType":"script"}