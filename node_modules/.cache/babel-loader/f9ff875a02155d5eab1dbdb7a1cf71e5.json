{"ast":null,"code":"\"use strict\";\n\nmodule.exports = getCubeEdges;\n\nvar bits = require('bit-twiddle');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar splitPoly = require('split-polygon');\n\nvar orient = require('robust-orientation');\n\nvar mvp = new Array(16);\nvar pCubeVerts = new Array(8);\nvar cubeVerts = new Array(8);\nvar x = new Array(3);\nvar zero3 = [0, 0, 0];\n\n(function () {\n  for (var i = 0; i < 8; ++i) {\n    pCubeVerts[i] = [1, 1, 1, 1];\n    cubeVerts[i] = [1, 1, 1];\n  }\n})();\n\nfunction transformHg(result, x, mat) {\n  for (var i = 0; i < 4; ++i) {\n    result[i] = mat[12 + i];\n\n    for (var j = 0; j < 3; ++j) {\n      result[i] += x[j] * mat[4 * j + i];\n    }\n  }\n}\n\nvar FRUSTUM_PLANES = [[0, 0, 1, 0, 0], [0, 0, -1, 1, 0], [0, -1, 0, 1, 0], [0, 1, 0, 1, 0], [-1, 0, 0, 1, 0], [1, 0, 0, 1, 0]];\n\nfunction polygonArea(p) {\n  for (var i = 0; i < FRUSTUM_PLANES.length; ++i) {\n    p = splitPoly.positive(p, FRUSTUM_PLANES[i]);\n\n    if (p.length < 3) {\n      return 0;\n    }\n  }\n\n  var base = p[0];\n  var ax = base[0] / base[3];\n  var ay = base[1] / base[3];\n  var area = 0.0;\n\n  for (var i = 1; i + 1 < p.length; ++i) {\n    var b = p[i];\n    var c = p[i + 1];\n    var bx = b[0] / b[3];\n    var by = b[1] / b[3];\n    var cx = c[0] / c[3];\n    var cy = c[1] / c[3];\n    var ux = bx - ax;\n    var uy = by - ay;\n    var vx = cx - ax;\n    var vy = cy - ay;\n    area += Math.abs(ux * vy - uy * vx);\n  }\n\n  return area;\n}\n\nvar CUBE_EDGES = [1, 1, 1];\nvar CUBE_AXIS = [0, 0, 0];\nvar CUBE_RESULT = {\n  cubeEdges: CUBE_EDGES,\n  axis: CUBE_AXIS\n};\n\nfunction getCubeEdges(model, view, projection, bounds, ortho) {\n  //Concatenate matrices\n  multiply(mvp, view, model);\n  multiply(mvp, projection, mvp); //First project cube vertices\n\n  var ptr = 0;\n\n  for (var i = 0; i < 2; ++i) {\n    x[2] = bounds[i][2];\n\n    for (var j = 0; j < 2; ++j) {\n      x[1] = bounds[j][1];\n\n      for (var k = 0; k < 2; ++k) {\n        x[0] = bounds[k][0];\n        transformHg(pCubeVerts[ptr], x, mvp);\n        ptr += 1;\n      }\n    }\n  } //Classify camera against cube faces\n\n\n  var closest = -1;\n\n  for (var i = 0; i < 8; ++i) {\n    var w = pCubeVerts[i][3];\n\n    for (var l = 0; l < 3; ++l) {\n      cubeVerts[i][l] = pCubeVerts[i][l] / w;\n    }\n\n    if (ortho) cubeVerts[i][2] *= -1;\n\n    if (w < 0) {\n      if (closest < 0) {\n        closest = i;\n      } else if (cubeVerts[i][2] < cubeVerts[closest][2]) {\n        closest = i;\n      }\n    }\n  }\n\n  if (closest < 0) {\n    closest = 0;\n\n    for (var d = 0; d < 3; ++d) {\n      var u = (d + 2) % 3;\n      var v = (d + 1) % 3;\n      var o0 = -1;\n      var o1 = -1;\n\n      for (var s = 0; s < 2; ++s) {\n        var f0 = s << d;\n        var f1 = f0 + (s << u) + (1 - s << v);\n        var f2 = f0 + (1 - s << u) + (s << v);\n\n        if (orient(cubeVerts[f0], cubeVerts[f1], cubeVerts[f2], zero3) < 0) {\n          continue;\n        }\n\n        if (s) {\n          o0 = 1;\n        } else {\n          o1 = 1;\n        }\n      }\n\n      if (o0 < 0 || o1 < 0) {\n        if (o1 > o0) {\n          closest |= 1 << d;\n        }\n\n        continue;\n      }\n\n      for (var s = 0; s < 2; ++s) {\n        var f0 = s << d;\n        var f1 = f0 + (s << u) + (1 - s << v);\n        var f2 = f0 + (1 - s << u) + (s << v);\n        var o = polygonArea([pCubeVerts[f0], pCubeVerts[f1], pCubeVerts[f2], pCubeVerts[f0 + (1 << u) + (1 << v)]]);\n\n        if (s) {\n          o0 = o;\n        } else {\n          o1 = o;\n        }\n      }\n\n      if (o1 > o0) {\n        closest |= 1 << d;\n        continue;\n      }\n    }\n  }\n\n  var farthest = 7 ^ closest; //Find lowest vertex which is not closest closest\n\n  var bottom = -1;\n\n  for (var i = 0; i < 8; ++i) {\n    if (i === closest || i === farthest) {\n      continue;\n    }\n\n    if (bottom < 0) {\n      bottom = i;\n    } else if (cubeVerts[bottom][1] > cubeVerts[i][1]) {\n      bottom = i;\n    }\n  } //Find left/right neighbors of bottom vertex\n\n\n  var left = -1;\n\n  for (var i = 0; i < 3; ++i) {\n    var idx = bottom ^ 1 << i;\n\n    if (idx === closest || idx === farthest) {\n      continue;\n    }\n\n    if (left < 0) {\n      left = idx;\n    }\n\n    var v = cubeVerts[idx];\n\n    if (v[0] < cubeVerts[left][0]) {\n      left = idx;\n    }\n  }\n\n  var right = -1;\n\n  for (var i = 0; i < 3; ++i) {\n    var idx = bottom ^ 1 << i;\n\n    if (idx === closest || idx === farthest || idx === left) {\n      continue;\n    }\n\n    if (right < 0) {\n      right = idx;\n    }\n\n    var v = cubeVerts[idx];\n\n    if (v[0] > cubeVerts[right][0]) {\n      right = idx;\n    }\n  } //Determine edge axis coordinates\n\n\n  var cubeEdges = CUBE_EDGES;\n  cubeEdges[0] = cubeEdges[1] = cubeEdges[2] = 0;\n  cubeEdges[bits.log2(left ^ bottom)] = bottom & left;\n  cubeEdges[bits.log2(bottom ^ right)] = bottom & right;\n  var top = right ^ 7;\n\n  if (top === closest || top === farthest) {\n    top = left ^ 7;\n    cubeEdges[bits.log2(right ^ top)] = top & right;\n  } else {\n    cubeEdges[bits.log2(left ^ top)] = top & left;\n  } //Determine visible faces\n\n\n  var axis = CUBE_AXIS;\n  var cutCorner = closest;\n\n  for (var d = 0; d < 3; ++d) {\n    if (cutCorner & 1 << d) {\n      axis[d] = -1;\n    } else {\n      axis[d] = 1;\n    }\n  } //Return result\n\n\n  return CUBE_RESULT;\n}","map":null,"metadata":{},"sourceType":"script"}