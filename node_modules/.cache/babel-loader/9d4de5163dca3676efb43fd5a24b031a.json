{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectIter;\n\nvar pool = require('typedarray-pool');\n\nvar bits = require('bit-twiddle');\n\nvar bruteForce = require('./brute');\n\nvar bruteForcePartial = bruteForce.partial;\nvar bruteForceFull = bruteForce.full;\n\nvar sweep = require('./sweep');\n\nvar findMedian = require('./median');\n\nvar genPartition = require('./partition'); //Twiddle parameters\n\n\nvar BRUTE_FORCE_CUTOFF = 128; //Cut off for brute force search\n\nvar SCAN_CUTOFF = 1 << 22; //Cut off for two way scan\n\nvar SCAN_COMPLETE_CUTOFF = 1 << 22; //Partition functions\n\nvar partitionInteriorContainsInterval = genPartition('!(lo>=p0)&&!(p1>=hi)', ['p0', 'p1']);\nvar partitionStartEqual = genPartition('lo===p0', ['p0']);\nvar partitionStartLessThan = genPartition('lo<p0', ['p0']);\nvar partitionEndLessThanEqual = genPartition('hi<=p0', ['p0']);\nvar partitionContainsPoint = genPartition('lo<=p0&&p0<=hi', ['p0']);\nvar partitionContainsPointProper = genPartition('lo<p0&&p0<=hi', ['p0']); //Frame size for iterative loop\n\nvar IFRAME_SIZE = 6;\nvar DFRAME_SIZE = 2; //Data for box statck\n\nvar INIT_CAPACITY = 1024;\nvar BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);\nvar BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY); //Initialize iterative loop queue\n\nfunction iterInit(d, count) {\n  var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;\n  var maxInts = bits.nextPow2(IFRAME_SIZE * levels);\n\n  if (BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK);\n    BOX_ISTACK = pool.mallocInt32(maxInts);\n  }\n\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);\n\n  if (BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK);\n    BOX_DSTACK = pool.mallocDouble(maxDoubles);\n  }\n} //Append item to queue\n\n\nfunction iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {\n  var iptr = IFRAME_SIZE * ptr;\n  BOX_ISTACK[iptr] = axis;\n  BOX_ISTACK[iptr + 1] = redStart;\n  BOX_ISTACK[iptr + 2] = redEnd;\n  BOX_ISTACK[iptr + 3] = blueStart;\n  BOX_ISTACK[iptr + 4] = blueEnd;\n  BOX_ISTACK[iptr + 5] = state;\n  var dptr = DFRAME_SIZE * ptr;\n  BOX_DSTACK[dptr] = lo;\n  BOX_DSTACK[dptr + 1] = hi;\n} //Special case:  Intersect single point with list of intervals\n\n\nfunction onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n\n    if (flip && blueX === r0) {\n      continue;\n    }\n\n    var redId = redIndex[i];\n\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n\n    var retval;\n\n    if (flip) {\n      retval = visit(blueId, redId);\n    } else {\n      retval = visit(redId, blueId);\n    }\n\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n} //Special case:  Intersect one point with list of intervals\n\n\nfunction onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var redId = redIndex[i];\n\n    if (redId === blueId) {\n      continue;\n    }\n\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n\n    var retval = visit(redId, blueId);\n\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n} //The main box intersection routine\n\n\nfunction boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize);\n  var top = 0;\n  var elemSize = 2 * d;\n  var retval;\n  iterPush(top++, 0, 0, xSize, 0, ySize, initFull ? 16 : 0, -Infinity, Infinity);\n\n  if (!initFull) {\n    iterPush(top++, 0, 0, ySize, 0, xSize, 1, -Infinity, Infinity);\n  }\n\n  while (top > 0) {\n    top -= 1;\n    var iptr = top * IFRAME_SIZE;\n    var axis = BOX_ISTACK[iptr];\n    var redStart = BOX_ISTACK[iptr + 1];\n    var redEnd = BOX_ISTACK[iptr + 2];\n    var blueStart = BOX_ISTACK[iptr + 3];\n    var blueEnd = BOX_ISTACK[iptr + 4];\n    var state = BOX_ISTACK[iptr + 5];\n    var dptr = top * DFRAME_SIZE;\n    var lo = BOX_DSTACK[dptr];\n    var hi = BOX_DSTACK[dptr + 1]; //Unpack state info\n\n    var flip = state & 1;\n    var full = !!(state & 16); //Unpack indices\n\n    var red = xBoxes;\n    var redIndex = xIndex;\n    var blue = yBoxes;\n    var blueIndex = yIndex;\n\n    if (flip) {\n      red = yBoxes;\n      redIndex = yIndex;\n      blue = xBoxes;\n      blueIndex = xIndex;\n    }\n\n    if (state & 2) {\n      redEnd = partitionStartLessThan(d, axis, redStart, redEnd, red, redIndex, hi);\n\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n\n    if (state & 4) {\n      redStart = partitionEndLessThanEqual(d, axis, redStart, redEnd, red, redIndex, lo);\n\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n\n    var redCount = redEnd - redStart;\n    var blueCount = blueEnd - blueStart;\n\n    if (full) {\n      if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      }\n    } else {\n      if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      } else if (d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      }\n    } //First, find all red intervals whose interior contains (lo,hi)\n\n\n    var red0 = partitionInteriorContainsInterval(d, axis, redStart, redEnd, red, redIndex, lo, hi); //Lower dimensional case\n\n    if (redStart < red0) {\n      if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(d, axis + 1, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (axis === d - 2) {\n        if (flip) {\n          retval = sweep.sweepBipartite(d, visit, blueStart, blueEnd, blue, blueIndex, redStart, red0, red, redIndex);\n        } else {\n          retval = sweep.sweepBipartite(d, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        }\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else {\n        iterPush(top++, axis + 1, redStart, red0, blueStart, blueEnd, flip, -Infinity, Infinity);\n        iterPush(top++, axis + 1, blueStart, blueEnd, redStart, red0, flip ^ 1, -Infinity, Infinity);\n      }\n    } //Divide and conquer phase\n\n\n    if (red0 < redEnd) {\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(d, axis, blueStart, blueEnd, blue, blueIndex);\n      var mid = blue[elemSize * blue0 + axis];\n      var blue1 = partitionStartEqual(d, axis, blue0, blueEnd, blue, blueIndex, mid); //Right case\n\n      if (blue1 < blueEnd) {\n        iterPush(top++, axis, red0, redEnd, blue1, blueEnd, (flip | 4) + (full ? 16 : 0), mid, hi);\n      } //Left case\n\n\n      if (blueStart < blue0) {\n        iterPush(top++, axis, red0, redEnd, blueStart, blue0, (flip | 2) + (full ? 16 : 0), lo, mid);\n      } //Center case (the hard part)\n\n\n      if (blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if (full) {\n          retval = onePointFull(d, axis, visit, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        } else {\n          retval = onePointPartial(d, axis, visit, flip, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        }\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (blue0 < blue1) {\n        var red1;\n\n        if (full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n\n          if (red0 < red1) {\n            var redX = partitionStartEqual(d, axis, red0, red1, red, redIndex, mid);\n\n            if (axis === d - 2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if (red0 < redX) {\n                retval = sweep.sweepComplete(d, visit, red0, redX, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              } //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n\n\n              if (redX < red1) {\n                retval = sweep.sweepBipartite(d, visit, redX, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            } else {\n              if (red0 < redX) {\n                iterPush(top++, axis + 1, red0, redX, blue0, blue1, 16, -Infinity, Infinity);\n              }\n\n              if (redX < red1) {\n                iterPush(top++, axis + 1, redX, red1, blue0, blue1, 0, -Infinity, Infinity);\n                iterPush(top++, axis + 1, blue0, blue1, redX, red1, 1, -Infinity, Infinity);\n              }\n            }\n          }\n        } else {\n          if (flip) {\n            red1 = partitionContainsPointProper(d, axis, red0, redEnd, red, redIndex, mid);\n          } else {\n            red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n          }\n\n          if (red0 < red1) {\n            if (axis === d - 2) {\n              if (flip) {\n                retval = sweep.sweepBipartite(d, visit, blue0, blue1, blue, blueIndex, red0, red1, red, redIndex);\n              } else {\n                retval = sweep.sweepBipartite(d, visit, red0, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n              }\n            } else {\n              iterPush(top++, axis + 1, red0, red1, blue0, blue1, flip, -Infinity, Infinity);\n              iterPush(top++, axis + 1, blue0, blue1, red0, red1, flip ^ 1, -Infinity, Infinity);\n            }\n          }\n        }\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}