{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\n\nvar m4interp = require('mat4-interpolate');\n\nvar invert44 = require('gl-mat4/invert');\n\nvar rotateX = require('gl-mat4/rotateX');\n\nvar rotateY = require('gl-mat4/rotateY');\n\nvar rotateZ = require('gl-mat4/rotateZ');\n\nvar lookAt = require('gl-mat4/lookAt');\n\nvar translate = require('gl-mat4/translate');\n\nvar scale = require('gl-mat4/scale');\n\nvar normalize = require('gl-vec3/normalize');\n\nvar DEFAULT_CENTER = [0, 0, 0];\nmodule.exports = createMatrixCameraController;\n\nfunction MatrixCameraController(initialMatrix) {\n  this._components = initialMatrix.slice();\n  this._time = [0];\n  this.prevMatrix = initialMatrix.slice();\n  this.nextMatrix = initialMatrix.slice();\n  this.computedMatrix = initialMatrix.slice();\n  this.computedInverse = initialMatrix.slice();\n  this.computedEye = [0, 0, 0];\n  this.computedUp = [0, 0, 0];\n  this.computedCenter = [0, 0, 0];\n  this.computedRadius = [0];\n  this._limits = [-Infinity, Infinity];\n}\n\nvar proto = MatrixCameraController.prototype;\n\nproto.recalcMatrix = function (t) {\n  var time = this._time;\n  var tidx = bsearch.le(time, t);\n  var mat = this.computedMatrix;\n\n  if (tidx < 0) {\n    return;\n  }\n\n  var comps = this._components;\n\n  if (tidx === time.length - 1) {\n    var ptr = 16 * tidx;\n\n    for (var i = 0; i < 16; ++i) {\n      mat[i] = comps[ptr++];\n    }\n  } else {\n    var dt = time[tidx + 1] - time[tidx];\n    var ptr = 16 * tidx;\n    var prev = this.prevMatrix;\n    var allEqual = true;\n\n    for (var i = 0; i < 16; ++i) {\n      prev[i] = comps[ptr++];\n    }\n\n    var next = this.nextMatrix;\n\n    for (var i = 0; i < 16; ++i) {\n      next[i] = comps[ptr++];\n      allEqual = allEqual && prev[i] === next[i];\n    }\n\n    if (dt < 1e-6 || allEqual) {\n      for (var i = 0; i < 16; ++i) {\n        mat[i] = prev[i];\n      }\n    } else {\n      m4interp(mat, prev, next, (t - time[tidx]) / dt);\n    }\n  }\n\n  var up = this.computedUp;\n  up[0] = mat[1];\n  up[1] = mat[5];\n  up[2] = mat[9];\n  normalize(up, up);\n  var imat = this.computedInverse;\n  invert44(imat, mat);\n  var eye = this.computedEye;\n  var w = imat[15];\n  eye[0] = imat[12] / w;\n  eye[1] = imat[13] / w;\n  eye[2] = imat[14] / w;\n  var center = this.computedCenter;\n  var radius = Math.exp(this.computedRadius[0]);\n\n  for (var i = 0; i < 3; ++i) {\n    center[i] = eye[i] - mat[2 + 4 * i] * radius;\n  }\n};\n\nproto.idle = function (t) {\n  if (t < this.lastT()) {\n    return;\n  }\n\n  var mc = this._components;\n  var ptr = mc.length - 16;\n\n  for (var i = 0; i < 16; ++i) {\n    mc.push(mc[ptr++]);\n  }\n\n  this._time.push(t);\n};\n\nproto.flush = function (t) {\n  var idx = bsearch.gt(this._time, t) - 2;\n\n  if (idx < 0) {\n    return;\n  }\n\n  this._time.splice(0, idx);\n\n  this._components.splice(0, 16 * idx);\n};\n\nproto.lastT = function () {\n  return this._time[this._time.length - 1];\n};\n\nproto.lookAt = function (t, eye, center, up) {\n  this.recalcMatrix(t);\n  eye = eye || this.computedEye;\n  center = center || DEFAULT_CENTER;\n  up = up || this.computedUp;\n  this.setMatrix(t, lookAt(this.computedMatrix, eye, center, up));\n  var d2 = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    d2 += Math.pow(center[i] - eye[i], 2);\n  }\n\n  d2 = Math.log(Math.sqrt(d2));\n  this.computedRadius[0] = d2;\n};\n\nproto.rotate = function (t, yaw, pitch, roll) {\n  this.recalcMatrix(t);\n  var mat = this.computedInverse;\n  if (yaw) rotateY(mat, mat, yaw);\n  if (pitch) rotateX(mat, mat, pitch);\n  if (roll) rotateZ(mat, mat, roll);\n  this.setMatrix(t, invert44(this.computedMatrix, mat));\n};\n\nvar tvec = [0, 0, 0];\n\nproto.pan = function (t, dx, dy, dz) {\n  tvec[0] = -(dx || 0.0);\n  tvec[1] = -(dy || 0.0);\n  tvec[2] = -(dz || 0.0);\n  this.recalcMatrix(t);\n  var mat = this.computedInverse;\n  translate(mat, mat, tvec);\n  this.setMatrix(t, invert44(mat, mat));\n};\n\nproto.translate = function (t, dx, dy, dz) {\n  tvec[0] = dx || 0.0;\n  tvec[1] = dy || 0.0;\n  tvec[2] = dz || 0.0;\n  this.recalcMatrix(t);\n  var mat = this.computedMatrix;\n  translate(mat, mat, tvec);\n  this.setMatrix(t, mat);\n};\n\nproto.setMatrix = function (t, mat) {\n  if (t < this.lastT()) {\n    return;\n  }\n\n  this._time.push(t);\n\n  for (var i = 0; i < 16; ++i) {\n    this._components.push(mat[i]);\n  }\n};\n\nproto.setDistance = function (t, d) {\n  this.computedRadius[0] = d;\n};\n\nproto.setDistanceLimits = function (a, b) {\n  var lim = this._limits;\n  lim[0] = a;\n  lim[1] = b;\n};\n\nproto.getDistanceLimits = function (out) {\n  var lim = this._limits;\n\n  if (out) {\n    out[0] = lim[0];\n    out[1] = lim[1];\n    return out;\n  }\n\n  return lim;\n};\n\nfunction createMatrixCameraController(options) {\n  options = options || {};\n  var matrix = options.matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  return new MatrixCameraController(matrix);\n}","map":null,"metadata":{},"sourceType":"script"}