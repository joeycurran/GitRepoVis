{"ast":null,"code":"\"use strict\";\n\nmodule.exports = createSlabDecomposition;\n\nvar bounds = require(\"binary-search-bounds\");\n\nvar createRBTree = require(\"functional-red-black-tree\");\n\nvar orient = require(\"robust-orientation\");\n\nvar orderSegments = require(\"./lib/order-segments\");\n\nfunction SlabDecomposition(slabs, coordinates, horizontal) {\n  this.slabs = slabs;\n  this.coordinates = coordinates;\n  this.horizontal = horizontal;\n}\n\nvar proto = SlabDecomposition.prototype;\n\nfunction compareHorizontal(e, y) {\n  return e.y - y;\n}\n\nfunction searchBucket(root, p) {\n  var lastNode = null;\n\n  while (root) {\n    var seg = root.key;\n    var l, r;\n\n    if (seg[0][0] < seg[1][0]) {\n      l = seg[0];\n      r = seg[1];\n    } else {\n      l = seg[1];\n      r = seg[0];\n    }\n\n    var o = orient(l, r, p);\n\n    if (o < 0) {\n      root = root.left;\n    } else if (o > 0) {\n      if (p[0] !== seg[1][0]) {\n        lastNode = root;\n        root = root.right;\n      } else {\n        var val = searchBucket(root.right, p);\n\n        if (val) {\n          return val;\n        }\n\n        root = root.left;\n      }\n    } else {\n      if (p[0] !== seg[1][0]) {\n        return root;\n      } else {\n        var val = searchBucket(root.right, p);\n\n        if (val) {\n          return val;\n        }\n\n        root = root.left;\n      }\n    }\n  }\n\n  return lastNode;\n}\n\nproto.castUp = function (p) {\n  var bucket = bounds.le(this.coordinates, p[0]);\n\n  if (bucket < 0) {\n    return -1;\n  }\n\n  var root = this.slabs[bucket];\n  var hitNode = searchBucket(this.slabs[bucket], p);\n  var lastHit = -1;\n\n  if (hitNode) {\n    lastHit = hitNode.value;\n  } //Edge case: need to handle horizontal segments (sucks)\n\n\n  if (this.coordinates[bucket] === p[0]) {\n    var lastSegment = null;\n\n    if (hitNode) {\n      lastSegment = hitNode.key;\n    }\n\n    if (bucket > 0) {\n      var otherHitNode = searchBucket(this.slabs[bucket - 1], p);\n\n      if (otherHitNode) {\n        if (lastSegment) {\n          if (orderSegments(otherHitNode.key, lastSegment) > 0) {\n            lastSegment = otherHitNode.key;\n            lastHit = otherHitNode.value;\n          }\n        } else {\n          lastHit = otherHitNode.value;\n          lastSegment = otherHitNode.key;\n        }\n      }\n    }\n\n    var horiz = this.horizontal[bucket];\n\n    if (horiz.length > 0) {\n      var hbucket = bounds.ge(horiz, p[1], compareHorizontal);\n\n      if (hbucket < horiz.length) {\n        var e = horiz[hbucket];\n\n        if (p[1] === e.y) {\n          if (e.closed) {\n            return e.index;\n          } else {\n            while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {\n              hbucket = hbucket + 1;\n              e = horiz[hbucket];\n\n              if (e.closed) {\n                return e.index;\n              }\n            }\n\n            if (e.y === p[1] && !e.start) {\n              hbucket = hbucket + 1;\n\n              if (hbucket >= horiz.length) {\n                return lastHit;\n              }\n\n              e = horiz[hbucket];\n            }\n          }\n        } //Check if e is above/below last segment\n\n\n        if (e.start) {\n          if (lastSegment) {\n            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);\n\n            if (lastSegment[0][0] > lastSegment[1][0]) {\n              o = -o;\n            }\n\n            if (o > 0) {\n              lastHit = e.index;\n            }\n          } else {\n            lastHit = e.index;\n          }\n        } else if (e.y !== p[1]) {\n          lastHit = e.index;\n        }\n      }\n    }\n  }\n\n  return lastHit;\n};\n\nfunction IntervalSegment(y, index, start, closed) {\n  this.y = y;\n  this.index = index;\n  this.start = start;\n  this.closed = closed;\n}\n\nfunction Event(x, segment, create, index) {\n  this.x = x;\n  this.segment = segment;\n  this.create = create;\n  this.index = index;\n}\n\nfunction createSlabDecomposition(segments) {\n  var numSegments = segments.length;\n  var numEvents = 2 * numSegments;\n  var events = new Array(numEvents);\n\n  for (var i = 0; i < numSegments; ++i) {\n    var s = segments[i];\n    var f = s[0][0] < s[1][0];\n    events[2 * i] = new Event(s[0][0], s, f, i);\n    events[2 * i + 1] = new Event(s[1][0], s, !f, i);\n  }\n\n  events.sort(function (a, b) {\n    var d = a.x - b.x;\n\n    if (d) {\n      return d;\n    }\n\n    d = a.create - b.create;\n\n    if (d) {\n      return d;\n    }\n\n    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);\n  });\n  var tree = createRBTree(orderSegments);\n  var slabs = [];\n  var lines = [];\n  var horizontal = [];\n  var lastX = -Infinity;\n\n  for (var i = 0; i < numEvents;) {\n    var x = events[i].x;\n    var horiz = [];\n\n    while (i < numEvents) {\n      var e = events[i];\n\n      if (e.x !== x) {\n        break;\n      }\n\n      i += 1;\n\n      if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {\n        if (e.create) {\n          if (e.segment[0][1] < e.segment[1][1]) {\n            horiz.push(new IntervalSegment(e.segment[0][1], e.index, true, true));\n            horiz.push(new IntervalSegment(e.segment[1][1], e.index, false, false));\n          } else {\n            horiz.push(new IntervalSegment(e.segment[1][1], e.index, true, false));\n            horiz.push(new IntervalSegment(e.segment[0][1], e.index, false, true));\n          }\n        }\n      } else {\n        if (e.create) {\n          tree = tree.insert(e.segment, e.index);\n        } else {\n          tree = tree.remove(e.segment);\n        }\n      }\n    }\n\n    slabs.push(tree.root);\n    lines.push(x);\n    horizontal.push(horiz);\n  }\n\n  return new SlabDecomposition(slabs, lines, horizontal);\n}","map":null,"metadata":{},"sourceType":"script"}