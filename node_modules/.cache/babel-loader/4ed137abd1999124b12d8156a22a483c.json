{"ast":null,"code":"'use strict';\n\nmodule.exports = createGrid;\n\nvar createBuffer = require('gl-buffer');\n\nvar createShader = require('gl-shader');\n\nvar bsearch = require('binary-search-bounds');\n\nvar shaders = require('./shaders');\n\nfunction Grid(plot, vbo, shader, tickShader) {\n  this.plot = plot;\n  this.vbo = vbo;\n  this.shader = shader;\n  this.tickShader = tickShader;\n  this.ticks = [[], []];\n}\n\nfunction compareTickNum(a, b) {\n  return a - b;\n}\n\nvar proto = Grid.prototype;\n\nproto.draw = function () {\n  var DATA_SHIFT = [0, 0];\n  var DATA_SCALE = [0, 0];\n  var DATA_AXIS = [0, 0];\n  return function () {\n    var plot = this.plot;\n    var vbo = this.vbo;\n    var shader = this.shader;\n    var ticks = this.ticks;\n    var gl = plot.gl;\n    var bounds = plot._tickBounds;\n    var dataBox = plot.dataBox;\n    var viewPixels = plot.viewBox;\n    var lineWidth = plot.gridLineWidth;\n    var gridColor = plot.gridLineColor;\n    var gridEnable = plot.gridLineEnable;\n    var pixelRatio = plot.pixelRatio;\n\n    for (var i = 0; i < 2; ++i) {\n      var lo = bounds[i];\n      var hi = bounds[i + 2];\n      var boundScale = hi - lo;\n      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n      var dataWidth = dataBox[i + 2] - dataBox[i];\n      DATA_SCALE[i] = 2.0 * boundScale / dataWidth;\n      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;\n    }\n\n    shader.bind();\n    vbo.bind();\n    shader.attributes.dataCoord.pointer();\n    shader.uniforms.dataShift = DATA_SHIFT;\n    shader.uniforms.dataScale = DATA_SCALE;\n    var offset = 0;\n\n    for (var i = 0; i < 2; ++i) {\n      DATA_AXIS[0] = DATA_AXIS[1] = 0;\n      DATA_AXIS[i] = 1;\n      shader.uniforms.dataAxis = DATA_AXIS;\n      shader.uniforms.lineWidth = lineWidth[i] / (viewPixels[i + 2] - viewPixels[i]) * pixelRatio;\n      shader.uniforms.color = gridColor[i];\n      var size = ticks[i].length * 6;\n\n      if (gridEnable[i] && size) {\n        gl.drawArrays(gl.TRIANGLES, offset, size);\n      }\n\n      offset += size;\n    }\n  };\n}();\n\nproto.drawTickMarks = function () {\n  var DATA_SHIFT = [0, 0];\n  var DATA_SCALE = [0, 0];\n  var X_AXIS = [1, 0];\n  var Y_AXIS = [0, 1];\n  var SCR_OFFSET = [0, 0];\n  var TICK_SCALE = [0, 0];\n  return function () {\n    var plot = this.plot;\n    var vbo = this.vbo;\n    var shader = this.tickShader;\n    var ticks = this.ticks;\n    var gl = plot.gl;\n    var bounds = plot._tickBounds;\n    var dataBox = plot.dataBox;\n    var viewBox = plot.viewBox;\n    var pixelRatio = plot.pixelRatio;\n    var screenBox = plot.screenBox;\n    var screenWidth = screenBox[2] - screenBox[0];\n    var screenHeight = screenBox[3] - screenBox[1];\n    var viewWidth = viewBox[2] - viewBox[0];\n    var viewHeight = viewBox[3] - viewBox[1];\n\n    for (var i = 0; i < 2; ++i) {\n      var lo = bounds[i];\n      var hi = bounds[i + 2];\n      var boundScale = hi - lo;\n      var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n      var dataWidth = dataBox[i + 2] - dataBox[i];\n      DATA_SCALE[i] = 2.0 * boundScale / dataWidth;\n      DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;\n    }\n\n    DATA_SCALE[0] *= viewWidth / screenWidth;\n    DATA_SHIFT[0] *= viewWidth / screenWidth;\n    DATA_SCALE[1] *= viewHeight / screenHeight;\n    DATA_SHIFT[1] *= viewHeight / screenHeight;\n    shader.bind();\n    vbo.bind();\n    shader.attributes.dataCoord.pointer();\n    var uniforms = shader.uniforms;\n    uniforms.dataShift = DATA_SHIFT;\n    uniforms.dataScale = DATA_SCALE;\n    var tickMarkLength = plot.tickMarkLength;\n    var tickMarkWidth = plot.tickMarkWidth;\n    var tickMarkColor = plot.tickMarkColor;\n    var xTicksOffset = 0;\n    var yTicksOffset = ticks[0].length * 6;\n    var xStart = Math.min(bsearch.ge(ticks[0], (dataBox[0] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);\n    var xEnd = Math.min(bsearch.gt(ticks[0], (dataBox[2] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);\n    var xOffset = xTicksOffset + 6 * xStart;\n    var xCount = 6 * Math.max(0, xEnd - xStart);\n    var yStart = Math.min(bsearch.ge(ticks[1], (dataBox[1] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);\n    var yEnd = Math.min(bsearch.gt(ticks[1], (dataBox[3] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);\n    var yOffset = yTicksOffset + 6 * yStart;\n    var yCount = 6 * Math.max(0, yEnd - yStart);\n    SCR_OFFSET[0] = 2.0 * (viewBox[0] - tickMarkLength[1]) / screenWidth - 1.0;\n    SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;\n    TICK_SCALE[0] = tickMarkLength[1] * pixelRatio / screenWidth;\n    TICK_SCALE[1] = tickMarkWidth[1] * pixelRatio / screenHeight;\n\n    if (yCount) {\n      uniforms.color = tickMarkColor[1];\n      uniforms.tickScale = TICK_SCALE;\n      uniforms.dataAxis = Y_AXIS;\n      uniforms.screenOffset = SCR_OFFSET;\n      gl.drawArrays(gl.TRIANGLES, yOffset, yCount);\n    }\n\n    SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;\n    SCR_OFFSET[1] = 2.0 * (viewBox[1] - tickMarkLength[0]) / screenHeight - 1.0;\n    TICK_SCALE[0] = tickMarkWidth[0] * pixelRatio / screenWidth;\n    TICK_SCALE[1] = tickMarkLength[0] * pixelRatio / screenHeight;\n\n    if (xCount) {\n      uniforms.color = tickMarkColor[0];\n      uniforms.tickScale = TICK_SCALE;\n      uniforms.dataAxis = X_AXIS;\n      uniforms.screenOffset = SCR_OFFSET;\n      gl.drawArrays(gl.TRIANGLES, xOffset, xCount);\n    }\n\n    SCR_OFFSET[0] = 2.0 * (viewBox[2] + tickMarkLength[3]) / screenWidth - 1.0;\n    SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;\n    TICK_SCALE[0] = tickMarkLength[3] * pixelRatio / screenWidth;\n    TICK_SCALE[1] = tickMarkWidth[3] * pixelRatio / screenHeight;\n\n    if (yCount) {\n      uniforms.color = tickMarkColor[3];\n      uniforms.tickScale = TICK_SCALE;\n      uniforms.dataAxis = Y_AXIS;\n      uniforms.screenOffset = SCR_OFFSET;\n      gl.drawArrays(gl.TRIANGLES, yOffset, yCount);\n    }\n\n    SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;\n    SCR_OFFSET[1] = 2.0 * (viewBox[3] + tickMarkLength[2]) / screenHeight - 1.0;\n    TICK_SCALE[0] = tickMarkWidth[2] * pixelRatio / screenWidth;\n    TICK_SCALE[1] = tickMarkLength[2] * pixelRatio / screenHeight;\n\n    if (xCount) {\n      uniforms.color = tickMarkColor[2];\n      uniforms.tickScale = TICK_SCALE;\n      uniforms.dataAxis = X_AXIS;\n      uniforms.screenOffset = SCR_OFFSET;\n      gl.drawArrays(gl.TRIANGLES, xOffset, xCount);\n    }\n  };\n}();\n\nproto.update = function () {\n  var OFFSET_X = [1, 1, -1, -1, 1, -1];\n  var OFFSET_Y = [1, -1, 1, 1, -1, -1];\n  return function (options) {\n    var ticks = options.ticks;\n    var bounds = options.bounds;\n    var data = new Float32Array(6 * 3 * (ticks[0].length + ticks[1].length));\n    var zeroLineEnable = this.plot.zeroLineEnable;\n    var ptr = 0;\n    var gridTicks = [[], []];\n\n    for (var dim = 0; dim < 2; ++dim) {\n      var localTicks = gridTicks[dim];\n      var axisTicks = ticks[dim];\n      var lo = bounds[dim];\n      var hi = bounds[dim + 2];\n\n      for (var i = 0; i < axisTicks.length; ++i) {\n        var x = (axisTicks[i].x - lo) / (hi - lo);\n        localTicks.push(x);\n\n        for (var j = 0; j < 6; ++j) {\n          data[ptr++] = x;\n          data[ptr++] = OFFSET_X[j];\n          data[ptr++] = OFFSET_Y[j];\n        }\n      }\n    }\n\n    this.ticks = gridTicks;\n    this.vbo.update(data);\n  };\n}();\n\nproto.dispose = function () {\n  this.vbo.dispose();\n  this.shader.dispose();\n  this.tickShader.dispose();\n};\n\nfunction createGrid(plot) {\n  var gl = plot.gl;\n  var vbo = createBuffer(gl);\n  var shader = createShader(gl, shaders.gridVert, shaders.gridFrag);\n  var tickShader = createShader(gl, shaders.tickVert, shaders.gridFrag);\n  var grid = new Grid(plot, vbo, shader, tickShader);\n  return grid;\n}","map":null,"metadata":{},"sourceType":"script"}