{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\n\nmodule.exports = classifyFaces;\n\nfunction FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n  this.cells = cells;\n  this.neighbor = neighbor;\n  this.flags = flags;\n  this.constraint = constraint;\n  this.active = active;\n  this.next = next;\n  this.boundary = boundary;\n}\n\nvar proto = FaceIndex.prototype;\n\nfunction compareCell(a, b) {\n  return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];\n}\n\nproto.locate = function () {\n  var key = [0, 0, 0];\n  return function (a, b, c) {\n    var x = a,\n        y = b,\n        z = c;\n\n    if (b < c) {\n      if (b < a) {\n        x = b;\n        y = c;\n        z = a;\n      }\n    } else if (c < a) {\n      x = c;\n      y = a;\n      z = b;\n    }\n\n    if (x < 0) {\n      return -1;\n    }\n\n    key[0] = x;\n    key[1] = y;\n    key[2] = z;\n    return bsearch.eq(this.cells, key, compareCell);\n  };\n}();\n\nfunction indexCells(triangulation, infinity) {\n  //First get cells and canonicalize\n  var cells = triangulation.cells();\n  var nc = cells.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    var x = c[0],\n        y = c[1],\n        z = c[2];\n\n    if (y < z) {\n      if (y < x) {\n        c[0] = y;\n        c[1] = z;\n        c[2] = x;\n      }\n    } else if (z < x) {\n      c[0] = z;\n      c[1] = x;\n      c[2] = y;\n    }\n  }\n\n  cells.sort(compareCell); //Initialize flag array\n\n  var flags = new Array(nc);\n\n  for (var i = 0; i < flags.length; ++i) {\n    flags[i] = 0;\n  } //Build neighbor index, initialize queues\n\n\n  var active = [];\n  var next = [];\n  var neighbor = new Array(3 * nc);\n  var constraint = new Array(3 * nc);\n  var boundary = null;\n\n  if (infinity) {\n    boundary = [];\n  }\n\n  var index = new FaceIndex(cells, neighbor, constraint, flags, active, next, boundary);\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < 3; ++j) {\n      var x = c[j],\n          y = c[(j + 1) % 3];\n      var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));\n      var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);\n\n      if (a < 0) {\n        if (b) {\n          next.push(i);\n        } else {\n          active.push(i);\n          flags[i] = 1;\n        }\n\n        if (infinity) {\n          boundary.push([y, x, -1]);\n        }\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction filterCells(cells, flags, target) {\n  var ptr = 0;\n\n  for (var i = 0; i < cells.length; ++i) {\n    if (flags[i] === target) {\n      cells[ptr++] = cells[i];\n    }\n  }\n\n  cells.length = ptr;\n  return cells;\n}\n\nfunction classifyFaces(triangulation, target, infinity) {\n  var index = indexCells(triangulation, infinity);\n\n  if (target === 0) {\n    if (infinity) {\n      return index.cells.concat(index.boundary);\n    } else {\n      return index.cells;\n    }\n  }\n\n  var side = 1;\n  var active = index.active;\n  var next = index.next;\n  var flags = index.flags;\n  var cells = index.cells;\n  var constraint = index.constraint;\n  var neighbor = index.neighbor;\n\n  while (active.length > 0 || next.length > 0) {\n    while (active.length > 0) {\n      var t = active.pop();\n\n      if (flags[t] === -side) {\n        continue;\n      }\n\n      flags[t] = side;\n      var c = cells[t];\n\n      for (var j = 0; j < 3; ++j) {\n        var f = neighbor[3 * t + j];\n\n        if (f >= 0 && flags[f] === 0) {\n          if (constraint[3 * t + j]) {\n            next.push(f);\n          } else {\n            active.push(f);\n            flags[f] = side;\n          }\n        }\n      }\n    } //Swap arrays and loop\n\n\n    var tmp = next;\n    next = active;\n    active = tmp;\n    next.length = 0;\n    side = -side;\n  }\n\n  var result = filterCells(cells, flags, target);\n\n  if (infinity) {\n    return result.concat(index.boundary);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}