{"ast":null,"code":"'use strict';\n\nmodule.exports = findMedian;\n\nvar genPartition = require('./partition');\n\nvar partitionStartLessThan = genPartition('lo<p0', ['p0']);\nvar PARTITION_THRESHOLD = 8; //Cut off for using insertion sort in findMedian\n//Base case for median finding:  Use insertion sort\n\nfunction insertionSort(d, axis, start, end, boxes, ids) {\n  var elemSize = 2 * d;\n  var boxPtr = elemSize * (start + 1) + axis;\n\n  for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {\n    var x = boxes[boxPtr];\n\n    for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {\n      //Swap\n      var aPtr = ptr;\n      var bPtr = ptr + elemSize;\n\n      for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {\n        var y = boxes[aPtr];\n        boxes[aPtr] = boxes[bPtr];\n        boxes[bPtr] = y;\n      }\n\n      var tmp = ids[j];\n      ids[j] = ids[j - 1];\n      ids[j - 1] = tmp;\n    }\n  }\n} //Find median using quick select algorithm\n//  takes O(n) time with high probability\n\n\nfunction findMedian(d, axis, start, end, boxes, ids) {\n  if (end <= start + 1) {\n    return start;\n  }\n\n  var lo = start;\n  var hi = end;\n  var mid = end + start >>> 1;\n  var elemSize = 2 * d;\n  var pivot = mid;\n  var value = boxes[elemSize * mid + axis];\n\n  while (lo < hi) {\n    if (hi - lo < PARTITION_THRESHOLD) {\n      insertionSort(d, axis, lo, hi, boxes, ids);\n      value = boxes[elemSize * mid + axis];\n      break;\n    } //Select pivot using median-of-3\n\n\n    var count = hi - lo;\n    var pivot0 = Math.random() * count + lo | 0;\n    var value0 = boxes[elemSize * pivot0 + axis];\n    var pivot1 = Math.random() * count + lo | 0;\n    var value1 = boxes[elemSize * pivot1 + axis];\n    var pivot2 = Math.random() * count + lo | 0;\n    var value2 = boxes[elemSize * pivot2 + axis];\n\n    if (value0 <= value1) {\n      if (value2 >= value1) {\n        pivot = pivot1;\n        value = value1;\n      } else if (value0 >= value2) {\n        pivot = pivot0;\n        value = value0;\n      } else {\n        pivot = pivot2;\n        value = value2;\n      }\n    } else {\n      if (value1 >= value2) {\n        pivot = pivot1;\n        value = value1;\n      } else if (value2 >= value0) {\n        pivot = pivot0;\n        value = value0;\n      } else {\n        pivot = pivot2;\n        value = value2;\n      }\n    } //Swap pivot to end of array\n\n\n    var aPtr = elemSize * (hi - 1);\n    var bPtr = elemSize * pivot;\n\n    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr];\n      boxes[aPtr] = boxes[bPtr];\n      boxes[bPtr] = x;\n    }\n\n    var y = ids[hi - 1];\n    ids[hi - 1] = ids[pivot];\n    ids[pivot] = y; //Partition using pivot\n\n    pivot = partitionStartLessThan(d, axis, lo, hi - 1, boxes, ids, value); //Swap pivot back\n\n    var aPtr = elemSize * (hi - 1);\n    var bPtr = elemSize * pivot;\n\n    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr];\n      boxes[aPtr] = boxes[bPtr];\n      boxes[bPtr] = x;\n    }\n\n    var y = ids[hi - 1];\n    ids[hi - 1] = ids[pivot];\n    ids[pivot] = y; //Swap pivot to last pivot\n\n    if (mid < pivot) {\n      hi = pivot - 1;\n\n      while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {\n        hi -= 1;\n      }\n\n      hi += 1;\n    } else if (pivot < mid) {\n      lo = pivot + 1;\n\n      while (lo < hi && boxes[elemSize * lo + axis] === value) {\n        lo += 1;\n      }\n    } else {\n      break;\n    }\n  } //Make sure pivot is at start\n\n\n  return partitionStartLessThan(d, axis, start, mid, boxes, ids, boxes[elemSize * mid + axis]);\n}","map":null,"metadata":{},"sourceType":"script"}