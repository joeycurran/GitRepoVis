{"ast":null,"code":"'use strict';\n\nvar ndarray = require('ndarray');\n\nvar ops = require('ndarray-ops');\n\nvar pool = require('typedarray-pool');\n\nmodule.exports = createTexture2D;\nvar linearTypes = null;\nvar filterTypes = null;\nvar wrapTypes = null;\n\nfunction lazyInitLinearTypes(gl) {\n  linearTypes = [gl.LINEAR, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_NEAREST];\n  filterTypes = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n  wrapTypes = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n}\n\nfunction acceptTextureDOM(obj) {\n  return 'undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement || 'undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement || 'undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement || 'undefined' != typeof ImageData && obj instanceof ImageData;\n}\n\nvar convertFloatToUint8 = function (out, inp) {\n  ops.muls(out, inp, 255.0);\n};\n\nfunction reshapeTexture(tex, w, h) {\n  var gl = tex.gl;\n  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n  if (w < 0 || w > maxSize || h < 0 || h > maxSize) {\n    throw new Error('gl-texture2d: Invalid texture size');\n  }\n\n  tex._shape = [w, h];\n  tex.bind();\n  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null);\n  tex._mipLevels = [0];\n  return tex;\n}\n\nfunction Texture2D(gl, handle, width, height, format, type) {\n  this.gl = gl;\n  this.handle = handle;\n  this.format = format;\n  this.type = type;\n  this._shape = [width, height];\n  this._mipLevels = [0];\n  this._magFilter = gl.NEAREST;\n  this._minFilter = gl.NEAREST;\n  this._wrapS = gl.CLAMP_TO_EDGE;\n  this._wrapT = gl.CLAMP_TO_EDGE;\n  this._anisoSamples = 1;\n  var parent = this;\n  var wrapVector = [this._wrapS, this._wrapT];\n  Object.defineProperties(wrapVector, [{\n    get: function () {\n      return parent._wrapS;\n    },\n    set: function (v) {\n      return parent.wrapS = v;\n    }\n  }, {\n    get: function () {\n      return parent._wrapT;\n    },\n    set: function (v) {\n      return parent.wrapT = v;\n    }\n  }]);\n  this._wrapVector = wrapVector;\n  var shapeVector = [this._shape[0], this._shape[1]];\n  Object.defineProperties(shapeVector, [{\n    get: function () {\n      return parent._shape[0];\n    },\n    set: function (v) {\n      return parent.width = v;\n    }\n  }, {\n    get: function () {\n      return parent._shape[1];\n    },\n    set: function (v) {\n      return parent.height = v;\n    }\n  }]);\n  this._shapeVector = shapeVector;\n}\n\nvar proto = Texture2D.prototype;\nObject.defineProperties(proto, {\n  minFilter: {\n    get: function () {\n      return this._minFilter;\n    },\n    set: function (v) {\n      this.bind();\n      var gl = this.gl;\n\n      if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {\n        if (!gl.getExtension('OES_texture_float_linear')) {\n          v = gl.NEAREST;\n        }\n      }\n\n      if (filterTypes.indexOf(v) < 0) {\n        throw new Error('gl-texture2d: Unknown filter mode ' + v);\n      }\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v);\n      return this._minFilter = v;\n    }\n  },\n  magFilter: {\n    get: function () {\n      return this._magFilter;\n    },\n    set: function (v) {\n      this.bind();\n      var gl = this.gl;\n\n      if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {\n        if (!gl.getExtension('OES_texture_float_linear')) {\n          v = gl.NEAREST;\n        }\n      }\n\n      if (filterTypes.indexOf(v) < 0) {\n        throw new Error('gl-texture2d: Unknown filter mode ' + v);\n      }\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v);\n      return this._magFilter = v;\n    }\n  },\n  mipSamples: {\n    get: function () {\n      return this._anisoSamples;\n    },\n    set: function (i) {\n      var psamples = this._anisoSamples;\n      this._anisoSamples = Math.max(i, 1) | 0;\n\n      if (psamples !== this._anisoSamples) {\n        var ext = this.gl.getExtension('EXT_texture_filter_anisotropic');\n\n        if (ext) {\n          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples);\n        }\n      }\n\n      return this._anisoSamples;\n    }\n  },\n  wrapS: {\n    get: function () {\n      return this._wrapS;\n    },\n    set: function (v) {\n      this.bind();\n\n      if (wrapTypes.indexOf(v) < 0) {\n        throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n      }\n\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v);\n      return this._wrapS = v;\n    }\n  },\n  wrapT: {\n    get: function () {\n      return this._wrapT;\n    },\n    set: function (v) {\n      this.bind();\n\n      if (wrapTypes.indexOf(v) < 0) {\n        throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n      }\n\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v);\n      return this._wrapT = v;\n    }\n  },\n  wrap: {\n    get: function () {\n      return this._wrapVector;\n    },\n    set: function (v) {\n      if (!Array.isArray(v)) {\n        v = [v, v];\n      }\n\n      if (v.length !== 2) {\n        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns');\n      }\n\n      for (var i = 0; i < 2; ++i) {\n        if (wrapTypes.indexOf(v[i]) < 0) {\n          throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n        }\n      }\n\n      this._wrapS = v[0];\n      this._wrapT = v[1];\n      var gl = this.gl;\n      this.bind();\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);\n      return v;\n    }\n  },\n  shape: {\n    get: function () {\n      return this._shapeVector;\n    },\n    set: function (x) {\n      if (!Array.isArray(x)) {\n        x = [x | 0, x | 0];\n      } else {\n        if (x.length !== 2) {\n          throw new Error('gl-texture2d: Invalid texture shape');\n        }\n      }\n\n      reshapeTexture(this, x[0] | 0, x[1] | 0);\n      return [x[0] | 0, x[1] | 0];\n    }\n  },\n  width: {\n    get: function () {\n      return this._shape[0];\n    },\n    set: function (w) {\n      w = w | 0;\n      reshapeTexture(this, w, this._shape[1]);\n      return w;\n    }\n  },\n  height: {\n    get: function () {\n      return this._shape[1];\n    },\n    set: function (h) {\n      h = h | 0;\n      reshapeTexture(this, this._shape[0], h);\n      return h;\n    }\n  }\n});\n\nproto.bind = function (unit) {\n  var gl = this.gl;\n\n  if (unit !== undefined) {\n    gl.activeTexture(gl.TEXTURE0 + (unit | 0));\n  }\n\n  gl.bindTexture(gl.TEXTURE_2D, this.handle);\n\n  if (unit !== undefined) {\n    return unit | 0;\n  }\n\n  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;\n};\n\nproto.dispose = function () {\n  this.gl.deleteTexture(this.handle);\n};\n\nproto.generateMipmap = function () {\n  this.bind();\n  this.gl.generateMipmap(this.gl.TEXTURE_2D); //Update mip levels\n\n  var l = Math.min(this._shape[0], this._shape[1]);\n\n  for (var i = 0; l > 0; ++i, l >>>= 1) {\n    if (this._mipLevels.indexOf(i) < 0) {\n      this._mipLevels.push(i);\n    }\n  }\n};\n\nproto.setPixels = function (data, x_off, y_off, mip_level) {\n  var gl = this.gl;\n  this.bind();\n\n  if (Array.isArray(x_off)) {\n    mip_level = y_off;\n    y_off = x_off[1] | 0;\n    x_off = x_off[0] | 0;\n  } else {\n    x_off = x_off || 0;\n    y_off = y_off || 0;\n  }\n\n  mip_level = mip_level || 0;\n  var directData = acceptTextureDOM(data) ? data : data.raw;\n\n  if (directData) {\n    var needsMip = this._mipLevels.indexOf(mip_level) < 0;\n\n    if (needsMip) {\n      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData);\n\n      this._mipLevels.push(mip_level);\n    } else {\n      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData);\n    }\n  } else if (data.shape && data.stride && data.data) {\n    if (data.shape.length < 2 || x_off + data.shape[1] > this._shape[1] >>> mip_level || y_off + data.shape[0] > this._shape[0] >>> mip_level || x_off < 0 || y_off < 0) {\n      throw new Error('gl-texture2d: Texture dimensions are out of bounds');\n    }\n\n    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data);\n  } else {\n    throw new Error('gl-texture2d: Unsupported data type');\n  }\n};\n\nfunction isPacked(shape, stride) {\n  if (shape.length === 3) {\n    return stride[2] === 1 && stride[1] === shape[0] * shape[2] && stride[0] === shape[2];\n  }\n\n  return stride[0] === 1 && stride[1] === shape[0];\n}\n\nfunction texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {\n  var dtype = array.dtype;\n  var shape = array.shape.slice();\n\n  if (shape.length < 2 || shape.length > 3) {\n    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d');\n  }\n\n  var type = 0,\n      format = 0;\n  var packed = isPacked(shape, array.stride.slice());\n\n  if (dtype === 'float32') {\n    type = gl.FLOAT;\n  } else if (dtype === 'float64') {\n    type = gl.FLOAT;\n    packed = false;\n    dtype = 'float32';\n  } else if (dtype === 'uint8') {\n    type = gl.UNSIGNED_BYTE;\n  } else {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n    dtype = 'uint8';\n  }\n\n  var channels = 1;\n\n  if (shape.length === 2) {\n    format = gl.LUMINANCE;\n    shape = [shape[0], shape[1], 1];\n    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);\n  } else if (shape.length === 3) {\n    if (shape[2] === 1) {\n      format = gl.ALPHA;\n    } else if (shape[2] === 2) {\n      format = gl.LUMINANCE_ALPHA;\n    } else if (shape[2] === 3) {\n      format = gl.RGB;\n    } else if (shape[2] === 4) {\n      format = gl.RGBA;\n    } else {\n      throw new Error('gl-texture2d: Invalid shape for pixel coords');\n    }\n\n    channels = shape[2];\n  } else {\n    throw new Error('gl-texture2d: Invalid shape for texture');\n  } //For 1-channel textures allow conversion between formats\n\n\n  if ((format === gl.LUMINANCE || format === gl.ALPHA) && (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {\n    format = cformat;\n  }\n\n  if (format !== cformat) {\n    throw new Error('gl-texture2d: Incompatible texture format for setPixels');\n  }\n\n  var size = array.size;\n  var needsMip = mipLevels.indexOf(mip_level) < 0;\n\n  if (needsMip) {\n    mipLevels.push(mip_level);\n  }\n\n  if (type === ctype && packed) {\n    //Array data types are compatible, can directly copy into texture\n    if (array.offset === 0 && array.data.length === size) {\n      if (needsMip) {\n        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data);\n      } else {\n        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data);\n      }\n    } else {\n      if (needsMip) {\n        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset + size));\n      } else {\n        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset + size));\n      }\n    }\n  } else {\n    //Need to do type conversion to pack data into buffer\n    var pack_buffer;\n\n    if (ctype === gl.FLOAT) {\n      pack_buffer = pool.mallocFloat32(size);\n    } else {\n      pack_buffer = pool.mallocUint8(size);\n    }\n\n    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2] * shape[0], 1]);\n\n    if (type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {\n      convertFloatToUint8(pack_view, array);\n    } else {\n      ops.assign(pack_view, array);\n    }\n\n    if (needsMip) {\n      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size));\n    } else {\n      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size));\n    }\n\n    if (ctype === gl.FLOAT) {\n      pool.freeFloat32(pack_buffer);\n    } else {\n      pool.freeUint8(pack_buffer);\n    }\n  }\n}\n\nfunction initTexture(gl) {\n  var tex = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  return tex;\n}\n\nfunction createTextureShape(gl, width, height, format, type) {\n  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n  if (width < 0 || width > maxTextureSize || height < 0 || height > maxTextureSize) {\n    throw new Error('gl-texture2d: Invalid texture shape');\n  }\n\n  if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {\n    throw new Error('gl-texture2d: Floating point textures not supported on this platform');\n  }\n\n  var tex = initTexture(gl);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);\n  return new Texture2D(gl, tex, width, height, format, type);\n}\n\nfunction createTextureDOM(gl, directData, width, height, format, type) {\n  var tex = initTexture(gl);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData);\n  return new Texture2D(gl, tex, width, height, format, type);\n} //Creates a texture from an ndarray\n\n\nfunction createTextureArray(gl, array) {\n  var dtype = array.dtype;\n  var shape = array.shape.slice();\n  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n  if (shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {\n    throw new Error('gl-texture2d: Invalid texture size');\n  }\n\n  var packed = isPacked(shape, array.stride.slice());\n  var type = 0;\n\n  if (dtype === 'float32') {\n    type = gl.FLOAT;\n  } else if (dtype === 'float64') {\n    type = gl.FLOAT;\n    packed = false;\n    dtype = 'float32';\n  } else if (dtype === 'uint8') {\n    type = gl.UNSIGNED_BYTE;\n  } else {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n    dtype = 'uint8';\n  }\n\n  var format = 0;\n\n  if (shape.length === 2) {\n    format = gl.LUMINANCE;\n    shape = [shape[0], shape[1], 1];\n    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);\n  } else if (shape.length === 3) {\n    if (shape[2] === 1) {\n      format = gl.ALPHA;\n    } else if (shape[2] === 2) {\n      format = gl.LUMINANCE_ALPHA;\n    } else if (shape[2] === 3) {\n      format = gl.RGB;\n    } else if (shape[2] === 4) {\n      format = gl.RGBA;\n    } else {\n      throw new Error('gl-texture2d: Invalid shape for pixel coords');\n    }\n  } else {\n    throw new Error('gl-texture2d: Invalid shape for texture');\n  }\n\n  if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {\n    type = gl.UNSIGNED_BYTE;\n    packed = false;\n  }\n\n  var buffer, buf_store;\n  var size = array.size;\n\n  if (!packed) {\n    var stride = [shape[2], shape[2] * shape[0], 1];\n    buf_store = pool.malloc(size, dtype);\n    var buf_array = ndarray(buf_store, shape, stride, 0);\n\n    if ((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {\n      convertFloatToUint8(buf_array, array);\n    } else {\n      ops.assign(buf_array, array);\n    }\n\n    buffer = buf_store.subarray(0, size);\n  } else if (array.offset === 0 && array.data.length === size) {\n    buffer = array.data;\n  } else {\n    buffer = array.data.subarray(array.offset, array.offset + size);\n  }\n\n  var tex = initTexture(gl);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer);\n\n  if (!packed) {\n    pool.free(buf_store);\n  }\n\n  return new Texture2D(gl, tex, shape[0], shape[1], format, type);\n}\n\nfunction createTexture2D(gl) {\n  if (arguments.length <= 1) {\n    throw new Error('gl-texture2d: Missing arguments for texture2d constructor');\n  }\n\n  if (!linearTypes) {\n    lazyInitLinearTypes(gl);\n  }\n\n  if (typeof arguments[1] === 'number') {\n    return createTextureShape(gl, arguments[1], arguments[2], arguments[3] || gl.RGBA, arguments[4] || gl.UNSIGNED_BYTE);\n  }\n\n  if (Array.isArray(arguments[1])) {\n    return createTextureShape(gl, arguments[1][0] | 0, arguments[1][1] | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);\n  }\n\n  if (typeof arguments[1] === 'object') {\n    var obj = arguments[1];\n    var directData = acceptTextureDOM(obj) ? obj : obj.raw;\n\n    if (directData) {\n      return createTextureDOM(gl, directData, obj.width | 0, obj.height | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);\n    } else if (obj.shape && obj.data && obj.stride) {\n      return createTextureArray(gl, obj);\n    }\n  }\n\n  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor');\n}","map":null,"metadata":{},"sourceType":"script"}