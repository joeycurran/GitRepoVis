{"ast":null,"code":"\"use strict\";\n\nvar pool = require(\"typedarray-pool\");\n\nvar inverse = require(\"invert-permutation\");\n\nfunction rank(permutation) {\n  var n = permutation.length;\n\n  switch (n) {\n    case 0:\n    case 1:\n      return 0;\n\n    case 2:\n      return permutation[1];\n\n    default:\n      break;\n  }\n\n  var p = pool.mallocUint32(n);\n  var pinv = pool.mallocUint32(n);\n  var r = 0,\n      s,\n      t,\n      i;\n  inverse(permutation, pinv);\n\n  for (i = 0; i < n; ++i) {\n    p[i] = permutation[i];\n  }\n\n  for (i = n - 1; i > 0; --i) {\n    t = pinv[i];\n    s = p[i];\n    p[i] = p[t];\n    p[t] = s;\n    pinv[i] = pinv[s];\n    pinv[s] = t;\n    r = (r + s) * i;\n  }\n\n  pool.freeUint32(pinv);\n  pool.freeUint32(p);\n  return r;\n}\n\nfunction unrank(n, r, p) {\n  switch (n) {\n    case 0:\n      if (p) {\n        return p;\n      }\n\n      return [];\n\n    case 1:\n      if (p) {\n        p[0] = 0;\n        return p;\n      } else {\n        return [0];\n      }\n\n    case 2:\n      if (p) {\n        if (r) {\n          p[0] = 0;\n          p[1] = 1;\n        } else {\n          p[0] = 1;\n          p[1] = 0;\n        }\n\n        return p;\n      } else {\n        return r ? [0, 1] : [1, 0];\n      }\n\n    default:\n      break;\n  }\n\n  p = p || new Array(n);\n  var s,\n      t,\n      i,\n      nf = 1;\n  p[0] = 0;\n\n  for (i = 1; i < n; ++i) {\n    p[i] = i;\n    nf = nf * i | 0;\n  }\n\n  for (i = n - 1; i > 0; --i) {\n    s = r / nf | 0;\n    r = r - s * nf | 0;\n    nf = nf / i | 0;\n    t = p[i] | 0;\n    p[i] = p[s] | 0;\n    p[s] = t | 0;\n  }\n\n  return p;\n}\n\nexports.rank = rank;\nexports.unrank = unrank;","map":null,"metadata":{},"sourceType":"script"}