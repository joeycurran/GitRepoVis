{"ast":null,"code":"'use strict';\n\nmodule.exports = cleanPSLG;\n\nvar UnionFind = require('union-find');\n\nvar boxIntersect = require('box-intersect');\n\nvar segseg = require('robust-segment-intersect');\n\nvar rat = require('big-rat');\n\nvar ratCmp = require('big-rat/cmp');\n\nvar ratToFloat = require('big-rat/to-float');\n\nvar ratVec = require('rat-vec');\n\nvar nextafter = require('nextafter');\n\nvar solveIntersection = require('./lib/rat-seg-intersect'); // Bounds on a rational number when rounded to a float\n\n\nfunction boundRat(r) {\n  var f = ratToFloat(r);\n  return [nextafter(f, -Infinity), nextafter(f, Infinity)];\n} // Convert a list of edges in a pslg to bounding boxes\n\n\nfunction boundEdges(points, edges) {\n  var bounds = new Array(edges.length);\n\n  for (var i = 0; i < edges.length; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n    bounds[i] = [nextafter(Math.min(a[0], b[0]), -Infinity), nextafter(Math.min(a[1], b[1]), -Infinity), nextafter(Math.max(a[0], b[0]), Infinity), nextafter(Math.max(a[1], b[1]), Infinity)];\n  }\n\n  return bounds;\n} // Convert a list of points into bounding boxes by duplicating coords\n\n\nfunction boundPoints(points) {\n  var bounds = new Array(points.length);\n\n  for (var i = 0; i < points.length; ++i) {\n    var p = points[i];\n    bounds[i] = [nextafter(p[0], -Infinity), nextafter(p[1], -Infinity), nextafter(p[0], Infinity), nextafter(p[1], Infinity)];\n  }\n\n  return bounds;\n} // Find all pairs of crossing edges in a pslg (given edge bounds)\n\n\nfunction getCrossings(points, edges, edgeBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, function (i, j) {\n    var e = edges[i];\n    var f = edges[j];\n\n    if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {\n      return;\n    }\n\n    var a = points[e[0]];\n    var b = points[e[1]];\n    var c = points[f[0]];\n    var d = points[f[1]];\n\n    if (segseg(a, b, c, d)) {\n      result.push([i, j]);\n    }\n  });\n  return result;\n} // Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\n\n\nfunction getTJunctions(points, edges, edgeBounds, vertBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, vertBounds, function (i, v) {\n    var e = edges[i];\n\n    if (e[0] === v || e[1] === v) {\n      return;\n    }\n\n    var p = points[v];\n    var a = points[e[0]];\n    var b = points[e[1]];\n\n    if (segseg(a, b, p, p)) {\n      result.push([i, v]);\n    }\n  });\n  return result;\n} // Cut edges along crossings/tjunctions\n\n\nfunction cutEdges(floatPoints, edges, crossings, junctions, useColor) {\n  var i, e; // Convert crossings into tjunctions by constructing rational points\n\n  var ratPoints = floatPoints.map(function (p) {\n    return [rat(p[0]), rat(p[1])];\n  });\n\n  for (i = 0; i < crossings.length; ++i) {\n    var crossing = crossings[i];\n    e = crossing[0];\n    var f = crossing[1];\n    var ee = edges[e];\n    var ef = edges[f];\n    var x = solveIntersection(ratVec(floatPoints[ee[0]]), ratVec(floatPoints[ee[1]]), ratVec(floatPoints[ef[0]]), ratVec(floatPoints[ef[1]]));\n\n    if (!x) {\n      // Segments are parallel, should already be handled by t-junctions\n      continue;\n    }\n\n    var idx = floatPoints.length;\n    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);\n    ratPoints.push(x);\n    junctions.push([e, idx], [f, idx]);\n  } // Sort tjunctions\n\n\n  junctions.sort(function (a, b) {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0];\n    }\n\n    var u = ratPoints[a[1]];\n    var v = ratPoints[b[1]];\n    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);\n  }); // Split edges along junctions\n\n  for (i = junctions.length - 1; i >= 0; --i) {\n    var junction = junctions[i];\n    e = junction[0];\n    var edge = edges[e];\n    var s = edge[0];\n    var t = edge[1]; // Check if edge is not lexicographically sorted\n\n    var a = floatPoints[s];\n    var b = floatPoints[t];\n\n    if ((a[0] - b[0] || a[1] - b[1]) < 0) {\n      var tmp = s;\n      s = t;\n      t = tmp;\n    } // Split leading edge\n\n\n    edge[0] = s;\n    var last = edge[1] = junction[1]; // If we are grouping edges by color, remember to track data\n\n    var color;\n\n    if (useColor) {\n      color = edge[2];\n    } // Split other edges\n\n\n    while (i > 0 && junctions[i - 1][0] === e) {\n      var junction = junctions[--i];\n      var next = junction[1];\n\n      if (useColor) {\n        edges.push([last, next, color]);\n      } else {\n        edges.push([last, next]);\n      }\n\n      last = next;\n    } // Add final edge\n\n\n    if (useColor) {\n      edges.push([last, t, color]);\n    } else {\n      edges.push([last, t]);\n    }\n  } // Return constructed rational points\n\n\n  return ratPoints;\n} // Merge overlapping points\n\n\nfunction dedupPoints(floatPoints, ratPoints, floatBounds) {\n  var numPoints = ratPoints.length;\n  var uf = new UnionFind(numPoints); // Compute rational bounds\n\n  var bounds = [];\n\n  for (var i = 0; i < ratPoints.length; ++i) {\n    var p = ratPoints[i];\n    var xb = boundRat(p[0]);\n    var yb = boundRat(p[1]);\n    bounds.push([nextafter(xb[0], -Infinity), nextafter(yb[0], -Infinity), nextafter(xb[1], Infinity), nextafter(yb[1], Infinity)]);\n  } // Link all points with over lapping boxes\n\n\n  boxIntersect(bounds, function (i, j) {\n    uf.link(i, j);\n  }); // Do 1 pass over points to combine points in label sets\n\n  var noDupes = true;\n  var labels = new Array(numPoints);\n\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n\n    if (j !== i) {\n      // Clear no-dupes flag, zero out label\n      noDupes = false; // Make each point the top-left point from its cell\n\n      floatPoints[j] = [Math.min(floatPoints[i][0], floatPoints[j][0]), Math.min(floatPoints[i][1], floatPoints[j][1])];\n    }\n  } // If no duplicates, return null to signal termination\n\n\n  if (noDupes) {\n    return null;\n  }\n\n  var ptr = 0;\n\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n\n    if (j === i) {\n      labels[i] = ptr;\n      floatPoints[ptr++] = floatPoints[i];\n    } else {\n      labels[i] = -1;\n    }\n  }\n\n  floatPoints.length = ptr; // Do a second pass to fix up missing labels\n\n  for (var i = 0; i < numPoints; ++i) {\n    if (labels[i] < 0) {\n      labels[i] = labels[uf.find(i)];\n    }\n  } // Return resulting union-find data structure\n\n\n  return labels;\n}\n\nfunction compareLex2(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\nfunction compareLex3(a, b) {\n  var d = a[0] - b[0] || a[1] - b[1];\n\n  if (d) {\n    return d;\n  }\n\n  if (a[2] < b[2]) {\n    return -1;\n  } else if (a[2] > b[2]) {\n    return 1;\n  }\n\n  return 0;\n} // Remove duplicate edge labels\n\n\nfunction dedupEdges(edges, labels, useColor) {\n  if (edges.length === 0) {\n    return;\n  }\n\n  if (labels) {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = labels[e[0]];\n      var b = labels[e[1]];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  } else {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = e[0];\n      var b = e[1];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  }\n\n  if (useColor) {\n    edges.sort(compareLex3);\n  } else {\n    edges.sort(compareLex2);\n  }\n\n  var ptr = 1;\n\n  for (var i = 1; i < edges.length; ++i) {\n    var prev = edges[i - 1];\n    var next = edges[i];\n\n    if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {\n      continue;\n    }\n\n    edges[ptr++] = next;\n  }\n\n  edges.length = ptr;\n}\n\nfunction preRound(points, edges, useColor) {\n  var labels = dedupPoints(points, [], boundPoints(points));\n  dedupEdges(edges, labels, useColor);\n  return !!labels;\n} // Repeat until convergence\n\n\nfunction snapRound(points, edges, useColor) {\n  // 1. find edge crossings\n  var edgeBounds = boundEdges(points, edges);\n  var crossings = getCrossings(points, edges, edgeBounds); // 2. find t-junctions\n\n  var vertBounds = boundPoints(points);\n  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds); // 3. cut edges, construct rational points\n\n  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor); // 4. dedupe verts\n\n  var labels = dedupPoints(points, ratPoints, vertBounds); // 5. dedupe edges\n\n  dedupEdges(edges, labels, useColor); // 6. check termination\n\n  if (!labels) {\n    return crossings.length > 0 || tjunctions.length > 0;\n  } // More iterations necessary\n\n\n  return true;\n} // Main loop, runs PSLG clean up until completion\n\n\nfunction cleanPSLG(points, edges, colors) {\n  // If using colors, augment edges with color data\n  var prevEdges;\n\n  if (colors) {\n    prevEdges = edges;\n    var augEdges = new Array(edges.length);\n\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      augEdges[i] = [e[0], e[1], colors[i]];\n    }\n\n    edges = augEdges;\n  } // First round: remove duplicate edges and points\n\n\n  var modified = preRound(points, edges, !!colors); // Run snap rounding until convergence\n\n  while (snapRound(points, edges, !!colors)) {\n    modified = true;\n  } // Strip color tags\n\n\n  if (!!colors && modified) {\n    prevEdges.length = 0;\n    colors.length = 0;\n\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      prevEdges.push([e[0], e[1]]);\n      colors.push(e[2]);\n    }\n  }\n\n  return modified;\n}","map":null,"metadata":{},"sourceType":"script"}