{"ast":null,"code":"'use strict';\n\nvar createShader = require('gl-shader');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar invert = require('gl-mat4/invert');\n\nvar ndarray = require('ndarray');\n\nvar colormap = require('colormap');\n\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nfunction VectorMesh(gl, texture, triShader, pickShader, trianglePositions, triangleVectors, triangleIds, triangleColors, triangleUVs, triangleVAO, traceType) {\n  this.gl = gl;\n  this.pixelRatio = 1;\n  this.cells = [];\n  this.positions = [];\n  this.intensity = [];\n  this.texture = texture;\n  this.dirty = true;\n  this.triShader = triShader;\n  this.pickShader = pickShader;\n  this.trianglePositions = trianglePositions;\n  this.triangleVectors = triangleVectors;\n  this.triangleColors = triangleColors;\n  this.triangleUVs = triangleUVs;\n  this.triangleIds = triangleIds;\n  this.triangleVAO = triangleVAO;\n  this.triangleCount = 0;\n  this.pickId = 1;\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.lightPosition = [1e5, 1e5, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.opacity = 1;\n  this.traceType = traceType;\n  this.tubeScale = 1; // used in streamtube\n\n  this.coneScale = 2; // used in cone\n\n  this.vectorScale = 1; // used in cone\n\n  this.coneOffset = 0.25; // used in cone\n\n  this._model = IDENTITY;\n  this._view = IDENTITY;\n  this._projection = IDENTITY;\n  this._resolution = [1, 1];\n}\n\nvar proto = VectorMesh.prototype;\n\nproto.isOpaque = function () {\n  return this.opacity >= 1;\n};\n\nproto.isTransparent = function () {\n  return this.opacity < 1;\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nfunction genColormap(param) {\n  var colors = colormap({\n    colormap: param,\n    nshades: 256,\n    format: 'rgba'\n  });\n  var result = new Uint8Array(256 * 4);\n\n  for (var i = 0; i < 256; ++i) {\n    var c = colors[i];\n\n    for (var j = 0; j < 3; ++j) {\n      result[4 * i + j] = c[j];\n    }\n\n    result[4 * i + 3] = c[3] * 255;\n  }\n\n  return ndarray(result, [256, 256, 4], [4, 0, 1]);\n}\n\nfunction takeZComponent(array) {\n  var n = array.length;\n  var result = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    result[i] = array[i][2];\n  }\n\n  return result;\n}\n\nproto.update = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  this.dirty = true;\n\n  if ('lightPosition' in params) {\n    this.lightPosition = params.lightPosition;\n  }\n\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n  }\n\n  if ('ambient' in params) {\n    this.ambientLight = params.ambient;\n  }\n\n  if ('diffuse' in params) {\n    this.diffuseLight = params.diffuse;\n  }\n\n  if ('specular' in params) {\n    this.specularLight = params.specular;\n  }\n\n  if ('roughness' in params) {\n    this.roughness = params.roughness;\n  }\n\n  if ('fresnel' in params) {\n    this.fresnel = params.fresnel;\n  } // use in streamtube\n\n\n  if (params.tubeScale !== undefined) {\n    this.tubeScale = params.tubeScale;\n  } // used in cone\n\n\n  if (params.vectorScale !== undefined) {\n    this.vectorScale = params.vectorScale;\n  }\n\n  if (params.coneScale !== undefined) {\n    this.coneScale = params.coneScale;\n  }\n\n  if (params.coneOffset !== undefined) {\n    this.coneOffset = params.coneOffset;\n  }\n\n  if (params.colormap) {\n    this.texture.shape = [256, 256];\n    this.texture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n    this.texture.magFilter = gl.LINEAR;\n    this.texture.setPixels(genColormap(params.colormap));\n    this.texture.generateMipmap();\n  }\n\n  var cells = params.cells;\n  var positions = params.positions;\n  var vectors = params.vectors;\n\n  if (!positions || !cells || !vectors) {\n    return;\n  }\n\n  var tPos = [];\n  var tVec = [];\n  var tCol = [];\n  var tUVs = [];\n  var tIds = []; //Save geometry data for picking calculations\n\n  this.cells = cells;\n  this.positions = positions;\n  this.vectors = vectors; //Compute colors\n\n  var meshColor = params.meshColor || [1, 1, 1, 1]; //UVs\n\n  var vertexIntensity = params.vertexIntensity;\n  var intensityLo = Infinity;\n  var intensityHi = -Infinity;\n\n  if (vertexIntensity) {\n    if (params.vertexIntensityBounds) {\n      intensityLo = +params.vertexIntensityBounds[0];\n      intensityHi = +params.vertexIntensityBounds[1];\n    } else {\n      for (var i = 0; i < vertexIntensity.length; ++i) {\n        var f = vertexIntensity[i];\n        intensityLo = Math.min(intensityLo, f);\n        intensityHi = Math.max(intensityHi, f);\n      }\n    }\n  } else {\n    for (var i = 0; i < positions.length; ++i) {\n      var f = positions[i][2];\n      intensityLo = Math.min(intensityLo, f);\n      intensityHi = Math.max(intensityHi, f);\n    }\n  }\n\n  if (vertexIntensity) {\n    this.intensity = vertexIntensity;\n  } else {\n    this.intensity = takeZComponent(positions);\n  } //Update bounds\n\n\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n  for (var i = 0; i < positions.length; ++i) {\n    var p = positions[i];\n\n    for (var j = 0; j < 3; ++j) {\n      if (isNaN(p[j]) || !isFinite(p[j])) {\n        continue;\n      }\n\n      this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);\n      this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);\n    }\n  } //Pack cells into buffers\n\n\n  var triangleCount = 0;\n\n  fill_loop: for (var i = 0; i < cells.length; ++i) {\n    var cell = cells[i];\n\n    switch (cell.length) {\n      case 3:\n        //Check NaNs\n        for (var j = 0; j < 3; ++j) {\n          var v = cell[j];\n          var p = positions[v];\n\n          for (var k = 0; k < 3; ++k) {\n            if (isNaN(p[k]) || !isFinite(p[k])) {\n              continue fill_loop;\n            }\n          }\n        }\n\n        for (var j = 0; j < 3; ++j) {\n          var v = cell[2 - j];\n          var p = positions[v];\n          tPos.push(p[0], p[1], p[2], p[3]);\n          var w = vectors[v];\n          tVec.push(w[0], w[1], w[2], w[3] || 0);\n          var c = meshColor;\n\n          if (c.length === 3) {\n            tCol.push(c[0], c[1], c[2], 1);\n          } else {\n            tCol.push(c[0], c[1], c[2], c[3]);\n          }\n\n          var uv;\n\n          if (vertexIntensity) {\n            uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n          } else {\n            uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n          }\n\n          tUVs.push(uv[0], uv[1]);\n          tIds.push(i);\n        }\n\n        triangleCount += 1;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  this.triangleCount = triangleCount;\n  this.trianglePositions.update(tPos);\n  this.triangleVectors.update(tVec);\n  this.triangleColors.update(tCol);\n  this.triangleUVs.update(tUVs);\n  this.triangleIds.update(new Uint32Array(tIds));\n};\n\nproto.drawTransparent = proto.draw = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  var model = params.model || IDENTITY;\n  var view = params.view || IDENTITY;\n  var projection = params.projection || IDENTITY;\n  var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n  for (var i = 0; i < 3; ++i) {\n    clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n    clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n  }\n\n  var uniforms = {\n    model: model,\n    view: view,\n    projection: projection,\n    inverseModel: IDENTITY.slice(),\n    clipBounds: clipBounds,\n    kambient: this.ambientLight,\n    kdiffuse: this.diffuseLight,\n    kspecular: this.specularLight,\n    roughness: this.roughness,\n    fresnel: this.fresnel,\n    eyePosition: [0, 0, 0],\n    lightPosition: [0, 0, 0],\n    opacity: this.opacity,\n    tubeScale: this.tubeScale,\n    vectorScale: this.vectorScale,\n    coneScale: this.coneScale,\n    coneOffset: this.coneOffset,\n    texture: 0\n  };\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n  gl.disable(gl.CULL_FACE);\n  this.texture.bind(0);\n  var invCameraMatrix = new Array(16);\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n\n  for (var i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n\n  var w = invCameraMatrix[15];\n\n  for (var i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n\n    for (var j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n\n    uniforms.lightPosition[i] = s / w;\n  }\n\n  if (this.triangleCount > 0) {\n    var shader = this.triShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    this.triangleVAO.bind();\n    gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n    this.triangleVAO.unbind();\n  }\n};\n\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  var model = params.model || IDENTITY;\n  var view = params.view || IDENTITY;\n  var projection = params.projection || IDENTITY;\n  var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n  for (var i = 0; i < 3; ++i) {\n    clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n    clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n  } //Save camera parameters\n\n\n  this._model = [].slice.call(model);\n  this._view = [].slice.call(view);\n  this._projection = [].slice.call(projection);\n  this._resolution = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  var uniforms = {\n    model: model,\n    view: view,\n    projection: projection,\n    clipBounds: clipBounds,\n    tubeScale: this.tubeScale,\n    vectorScale: this.vectorScale,\n    coneScale: this.coneScale,\n    coneOffset: this.coneOffset,\n    pickId: this.pickId / 255.0\n  };\n  var shader = this.pickShader;\n  shader.bind();\n  shader.uniforms = uniforms;\n\n  if (this.triangleCount > 0) {\n    this.triangleVAO.bind();\n    gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n    this.triangleVAO.unbind();\n  }\n};\n\nproto.pick = function (pickData) {\n  if (!pickData) {\n    return null;\n  }\n\n  if (pickData.id !== this.pickId) {\n    return null;\n  }\n\n  var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];\n  var cell = this.cells[cellId];\n  var pos = this.positions[cell[1]].slice(0, 3);\n  var result = {\n    position: pos,\n    dataCoordinate: pos,\n    index: Math.floor(cell[1] / 48)\n  };\n\n  if (this.traceType === 'cone') {\n    result.index = Math.floor(cell[1] / 48);\n  } else if (this.traceType === 'streamtube') {\n    result.intensity = this.intensity[cell[1]];\n    result.velocity = this.vectors[cell[1]].slice(0, 3);\n    result.divergence = this.vectors[cell[1]][3];\n    result.index = cellId;\n  }\n\n  return result;\n};\n\nproto.dispose = function () {\n  this.texture.dispose();\n  this.triShader.dispose();\n  this.pickShader.dispose();\n  this.triangleVAO.dispose();\n  this.trianglePositions.dispose();\n  this.triangleVectors.dispose();\n  this.triangleColors.dispose();\n  this.triangleUVs.dispose();\n  this.triangleIds.dispose();\n};\n\nfunction createMeshShader(gl, shaders) {\n  var shader = createShader(gl, shaders.meshShader.vertex, shaders.meshShader.fragment, null, shaders.meshShader.attributes);\n  shader.attributes.position.location = 0;\n  shader.attributes.color.location = 2;\n  shader.attributes.uv.location = 3;\n  shader.attributes.vector.location = 4;\n  return shader;\n}\n\nfunction createPickShader(gl, shaders) {\n  var shader = createShader(gl, shaders.pickShader.vertex, shaders.pickShader.fragment, null, shaders.pickShader.attributes);\n  shader.attributes.position.location = 0;\n  shader.attributes.id.location = 1;\n  shader.attributes.vector.location = 4;\n  return shader;\n}\n\nfunction createVectorMesh(gl, params, opts) {\n  var shaders = opts.shaders;\n\n  if (arguments.length === 1) {\n    params = gl;\n    gl = params.gl;\n  }\n\n  var triShader = createMeshShader(gl, shaders);\n  var pickShader = createPickShader(gl, shaders);\n  var meshTexture = createTexture(gl, ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4]));\n  meshTexture.generateMipmap();\n  meshTexture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n  meshTexture.magFilter = gl.LINEAR;\n  var trianglePositions = createBuffer(gl);\n  var triangleVectors = createBuffer(gl);\n  var triangleColors = createBuffer(gl);\n  var triangleUVs = createBuffer(gl);\n  var triangleIds = createBuffer(gl);\n  var triangleVAO = createVAO(gl, [{\n    buffer: trianglePositions,\n    type: gl.FLOAT,\n    size: 4\n  }, {\n    buffer: triangleIds,\n    type: gl.UNSIGNED_BYTE,\n    size: 4,\n    normalized: true\n  }, {\n    buffer: triangleColors,\n    type: gl.FLOAT,\n    size: 4\n  }, {\n    buffer: triangleUVs,\n    type: gl.FLOAT,\n    size: 2\n  }, {\n    buffer: triangleVectors,\n    type: gl.FLOAT,\n    size: 4\n  }]);\n  var mesh = new VectorMesh(gl, meshTexture, triShader, pickShader, trianglePositions, triangleVectors, triangleIds, triangleColors, triangleUVs, triangleVAO, opts.traceType || 'cone');\n  mesh.update(params);\n  return mesh;\n}\n\nmodule.exports = createVectorMesh;","map":null,"metadata":{},"sourceType":"script"}