{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar createMesh = require('gl-mesh3d');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar findNearestOnAxis = require('../isosurface/convert').findNearestOnAxis;\n\nvar generateIsoMeshes = require('../isosurface/convert').generateIsoMeshes;\n\nfunction VolumeTrace(scene, mesh, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = mesh;\n  this.name = '';\n  this.data = null;\n  this.showContour = false;\n}\n\nvar proto = VolumeTrace.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.mesh) {\n    var rawId = selection.data.index;\n    var x = this.data._x[rawId];\n    var y = this.data._y[rawId];\n    var z = this.data._z[rawId];\n    var height = this.data._Ys.length;\n    var depth = this.data._Zs.length;\n    var i = findNearestOnAxis(x, this.data._Xs).id;\n    var j = findNearestOnAxis(y, this.data._Ys).id;\n    var k = findNearestOnAxis(z, this.data._Zs).id;\n    var selectIndex = selection.index = k + depth * j + depth * height * i;\n    selection.traceCoordinate = [this.data._x[selectIndex], this.data._y[selectIndex], this.data._z[selectIndex], this.data.value[selectIndex]];\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[selectIndex] !== undefined) {\n      selection.textLabel = text[selectIndex];\n    } else if (text) {\n      selection.textLabel = text;\n    }\n\n    return true;\n  }\n};\n\nproto.update = function (data) {\n  var scene = this.scene;\n  var layout = scene.fullSceneLayout;\n  this.data = generateIsoMeshes(data); // Unpack position data\n\n  function toDataCoords(axis, coord, scale, calendar) {\n    return coord.map(function (x) {\n      return axis.d2l(x, 0, calendar) * scale;\n    });\n  }\n\n  var positions = zip3(toDataCoords(layout.xaxis, data._x, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data._y, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data._z, scene.dataScale[2], data.zcalendar));\n  var cells = zip3(data._i, data._j, data._k);\n  var config = {\n    positions: positions,\n    cells: cells,\n    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n    ambient: data.lighting.ambient,\n    diffuse: data.lighting.diffuse,\n    specular: data.lighting.specular,\n    roughness: data.lighting.roughness,\n    fresnel: data.lighting.fresnel,\n    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n    faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n    opacity: data.opacity,\n    opacityscale: data.opacityscale,\n    contourEnable: data.contour.show,\n    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n    contourWidth: data.contour.width,\n    useFacetNormals: data.flatshading\n  };\n  var cOpts = extractOpts(data);\n  config.vertexIntensity = data._intensity;\n  config.vertexIntensityBounds = [cOpts.min, cOpts.max];\n  config.colormap = parseColorScale(data); // Update mesh\n\n  this.mesh.update(config);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createVolumeTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var mesh = createMesh({\n    gl: gl\n  });\n  var result = new VolumeTrace(scene, mesh, data.uid);\n  mesh._trace = result;\n  result.update(data);\n  scene.glplot.add(mesh);\n  return result;\n}\n\nmodule.exports = createVolumeTrace;","map":null,"metadata":{},"sourceType":"script"}