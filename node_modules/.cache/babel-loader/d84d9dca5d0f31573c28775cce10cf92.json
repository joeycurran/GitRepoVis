{"ast":null,"code":"'use strict';\n\nmodule.exports = {\n  init: sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete: sweepComplete,\n  scanBipartite: scanBipartite,\n  scanComplete: scanComplete\n};\n\nvar pool = require('typedarray-pool');\n\nvar bits = require('bit-twiddle');\n\nvar isort = require('./sort'); //Flag for blue\n\n\nvar BLUE_FLAG = 1 << 28; //1D sweep event queue stuff (use pool to save space)\n\nvar INIT_CAPACITY = 1024;\nvar RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8); //Reserves memory for the 1D sweep data structures\n\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count);\n\n  if (RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE);\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX);\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  if (BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE);\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX);\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  if (COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE);\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n\n  if (COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX);\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n\n  var eventLength = 8 * rcount;\n\n  if (SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS);\n    SWEEP_EVENTS = pool.mallocDouble(eventLength);\n  }\n} //Remove an item from the active queue in O(1)\n\n\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item];\n  var top = queue[count - 1];\n  queue[idx] = top;\n  index[top] = idx;\n} //Insert an item into the active queue in O(1)\n\n\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item;\n  index[item] = count;\n} //Recursion base case: use 1D sweep algorithm\n\n\nfunction sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i];\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -(idx + 1);\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + BLUE_FLAG;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e >= BLUE_FLAG) {\n      //blue destroy event\n      e = e - BLUE_FLAG | 0;\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);\n    } else if (e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);\n    } else if (e <= -BLUE_FLAG) {\n      //blue create event\n      e = -e - BLUE_FLAG | 0;\n\n      for (var j = 0; j < redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);\n    } else {\n      //red create event\n      e = -e - 1 | 0;\n\n      for (var j = 0; j < blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j]);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);\n    }\n  }\n} //Complete sweep\n\n\nfunction sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i] + 1 << 1;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + 1 << 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx | 1;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx | 1;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n  var commonActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    var color = e & 1;\n\n    if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {\n      color = 2;\n      i += 1;\n    }\n\n    if (e < 0) {\n      //Create event\n      var id = -(e >> 1) - 1; //Intersect with common\n\n      for (var j = 0; j < commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n\n      if (color !== 0) {\n        //Intersect with red\n        for (var j = 0; j < redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n\n      if (color !== 1) {\n        //Intersect with blue\n        for (var j = 0; j < blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n\n      if (color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);\n      } else if (color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);\n      } else if (color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);\n      }\n    } else {\n      //Destroy event\n      var id = (e >> 1) - 1;\n\n      if (color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);\n      } else if (color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);\n      } else if (color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);\n      }\n    }\n  }\n} //Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\n\n\nfunction scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n  var redShift = 1;\n  var blueShift = 1;\n\n  if (flip) {\n    blueShift = BLUE_FLAG;\n  } else {\n    redShift = BLUE_FLAG;\n  }\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + redShift;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + blueShift;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e < 0) {\n      var idx = -e;\n      var isRed = false;\n\n      if (idx >= BLUE_FLAG) {\n        isRed = !flip;\n        idx -= BLUE_FLAG;\n      } else {\n        isRed = !!flip;\n        idx -= 1;\n      }\n\n      if (isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);\n      } else {\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redPtr = elemSize * oidx;\n\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n\n          var redId = redIndex[oidx];\n          var retval;\n\n          if (flip) {\n            retval = visit(blueId, redId);\n          } else {\n            retval = visit(redId, blueId);\n          }\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);\n    }\n  }\n}\n\nfunction scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + BLUE_FLAG;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  } //process events from left->right\n\n\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n    if (e < 0) {\n      var idx = -e;\n\n      if (idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;\n      } else {\n        idx -= 1;\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redId = redIndex[oidx];\n\n          if (redId === blueId) {\n            break;\n          }\n\n          var redPtr = elemSize * oidx;\n\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n\n          var retval = visit(redId, blueId);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG;\n\n      for (var j = redActive - 1; j >= 0; --j) {\n        if (RED_SWEEP_QUEUE[j] === idx) {\n          for (var k = j + 1; k < redActive; ++k) {\n            RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];\n          }\n\n          break;\n        }\n      }\n\n      --redActive;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}