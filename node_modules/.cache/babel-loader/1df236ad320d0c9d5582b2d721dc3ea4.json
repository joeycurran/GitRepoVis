{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Registry = require('../../registry');\n\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar style = require('./style');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {\n  return d.id;\n}\n\nfunction getKeyFunc(trace) {\n  if (trace.ids) {\n    return keyFunc;\n  }\n}\n\nfunction dirSign(a, b) {\n  return a < b ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, opts, makeOnCompleteCallback) {\n  if (hasTransition(opts)) {\n    var onComplete;\n\n    if (makeOnCompleteCallback) {\n      onComplete = makeOnCompleteCallback();\n    }\n\n    return selection.transition().duration(opts.duration).ease(opts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n  } else {\n    return selection;\n  }\n}\n\nfunction hasTransition(transitionOpts) {\n  return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n\n  if (!opts) {\n    opts = {\n      mode: fullLayout.barmode,\n      norm: fullLayout.barmode,\n      gap: fullLayout.bargap,\n      groupgap: fullLayout.bargroupgap\n    };\n  }\n\n  var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var isWaterfall = trace.type === 'waterfall';\n    var isFunnel = trace.type === 'funnel';\n    var isBar = trace.type === 'bar';\n    var shouldDisplayZeros = isBar || isFunnel;\n    var adjustPixel = 0;\n\n    if (isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n      adjustPixel = trace.connector.line.width / 2;\n    }\n\n    var isHorizontal = trace.orientation === 'h';\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var keyFunc = getKeyFunc(trace);\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this); // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x0 = xy[0][0];\n      var x1 = xy[0][1];\n      var y0 = xy[1][0];\n      var y1 = xy[1][1];\n      var isBlank = x0 === x1 || y0 === y1 || !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1); // display zeros if line.width > 0\n\n      if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di) && (isHorizontal ? x1 - x0 === 0 : y1 - y0 === 0)) {\n        isBlank = false;\n      }\n\n      di.isBlank = isBlank;\n      if (isBlank && isHorizontal) x1 = x0;\n      if (isBlank && !isHorizontal) y1 = y0; // in waterfall mode `between` we need to adjust bar end points to match the connector width\n\n      if (adjustPixel && !isBlank) {\n        if (isHorizontal) {\n          x0 -= dirSign(x0, x1) * adjustPixel;\n          x1 += dirSign(x0, x1) * adjustPixel;\n        } else {\n          y0 -= dirSign(y0, y1) * adjustPixel;\n          y1 += dirSign(y0, y1) * adjustPixel;\n        }\n      }\n\n      var lw;\n      var mc;\n\n      if (trace.type === 'waterfall') {\n        if (!isBlank) {\n          var cont = trace[di.dir].marker;\n          lw = cont.line.width;\n          mc = cont.color;\n        }\n      } else {\n        lw = helpers.getLineWidth(trace, di);\n        mc = di.mc || trace.marker.color;\n      }\n\n      var offset = d3.round(lw / 2 % 1, 2);\n\n      function roundWithLine(v) {\n        // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n        return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n\n      function expandToVisible(v, vc) {\n        // if it's not in danger of disappearing entirely,\n        // round more precisely\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) : // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n        var op = Color.opacity(mc);\n        var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n        x0 = fixpx(x0, x1);\n        x1 = fixpx(x1, x0);\n        y0 = fixpx(y0, y1);\n        y1 = fixpx(y1, y0);\n      }\n\n      var sel = transition(Lib.ensureSingle(bar, 'path'), opts, makeOnCompleteCallback);\n      sel.style('vector-effect', 'non-scaling-stroke').attr('d', 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z').call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n      if (hasTransition(opts)) {\n        var styleFns = Drawing.makePointStyleFns(trace);\n        Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n      }\n\n      appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    }); // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  }); // error bars are on the top\n\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, calcTrace, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var textPosition;\n\n  function appendTextNode(bar, text, textFont) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      'class': 'bartext bartext-' + textPosition,\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, textFont).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  } // get trace attributes\n\n\n  var trace = calcTrace[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var text = getText(fullLayout, calcTrace, i, xa, ya);\n  textPosition = getTextPosition(trace, i); // compute text position\n\n  var inStackOrRelativeMode = opts.mode === 'stack' || opts.mode === 'relative';\n  var calcBar = calcTrace[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n  if (!text || textPosition === 'none' || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === 'auto' || textPosition === 'inside')) {\n    bar.select('text').remove();\n    return;\n  }\n\n  var layoutFont = fullLayout.font;\n  var barColor = style.getBarColor(calcTrace[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont); // Special case: don't use the c2p(v, true) value on log size axes,\n  // so that we can get correctly inside text scaling\n\n  var di = bar.datum();\n\n  if (isHorizontal) {\n    if (xa.type === 'log' && di.s0 <= 0) {\n      if (xa.range[0] < xa.range[1]) {\n        x0 = 0;\n      } else {\n        x0 = xa._length;\n      }\n    }\n  } else {\n    if (ya.type === 'log' && di.s0 <= 0) {\n      if (ya.range[0] < ya.range[1]) {\n        y0 = ya._length;\n      } else {\n        y0 = 0;\n      }\n    }\n  } // padding excluded\n\n\n  var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n  var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      textSelection = appendTextNode(bar, text, insideTextFont);\n      textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n      var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n      var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n\n      if (textHasSize && (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else {\n      textPosition = 'inside';\n    }\n  }\n\n  if (!textSelection) {\n    textSelection = appendTextNode(bar, text, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    var currentTransform = textSelection.attr('transform');\n    textSelection.attr('transform', '');\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    textSelection.attr('transform', currentTransform);\n\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  } // compute text transform\n\n\n  var transform, constrained;\n\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = Lib.getTextTransform(toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: trace.textangle\n    }));\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = Lib.getTextTransform(toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: trace.textangle,\n      anchor: trace.insidetextanchor\n    }));\n  }\n\n  transition(textSelection, opts, makeOnCompleteCallback).attr('transform', transform);\n}\n\nfunction getRotateFromAngle(angle) {\n  return angle === 'auto' ? 0 : angle;\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var anchor = opts.anchor || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  lx -= 2 * textpad;\n  ly -= 2 * textpad;\n  var autoRotate = angle === 'auto';\n  var isAutoRotated = false;\n\n  if (autoRotate && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {\n    isAutoRotated = true;\n  }\n\n  if (isAutoRotated) {\n    // don't rotate yet only swap bar width with height\n    var tmp = ly;\n    ly = lx;\n    lx = tmp;\n  }\n\n  var rotate = getRotateFromAngle(angle);\n  var absSin = Math.abs(Math.sin(Math.PI / 180 * rotate));\n  var absCos = Math.abs(Math.cos(Math.PI / 180 * rotate)); // compute and apply text padding\n\n  var dx = Math.max(lx * absCos, ly * absSin);\n  var dy = Math.max(lx * absSin, ly * absCos);\n  var scale = constrained ? Math.min(dx / textWidth, dy / textHeight) : Math.max(absCos, absSin);\n  scale = Math.min(1, scale); // compute text and target positions\n\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n\n  if (anchor !== 'middle') {\n    // case of 'start' or 'end'\n    var targetWidth = scale * (isHorizontal !== isAutoRotated ? textHeight : textWidth);\n    var targetHeight = scale * (isHorizontal !== isAutoRotated ? textWidth : textHeight);\n    textpad += 0.5 * (targetWidth * absSin + targetHeight * absCos);\n\n    if (isHorizontal) {\n      textpad *= dirSign(x0, x1);\n      targetX = anchor === 'start' ? x0 + textpad : x1 - textpad;\n    } else {\n      textpad *= dirSign(y0, y1);\n      targetY = anchor === 'start' ? y0 + textpad : y1 - textpad;\n    }\n  }\n\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2; // lastly apply auto rotation\n\n  if (isAutoRotated) rotate += 90;\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad; // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n\n  if (isHorizontal) {\n    textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  } else {\n    textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;\n  } // compute rotate and scale\n\n\n  var scale = 1;\n\n  if (constrained) {\n    scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);\n  }\n\n  var rotate = getRotateFromAngle(angle);\n  var absSin = Math.abs(Math.sin(Math.PI / 180 * rotate));\n  var absCos = Math.abs(Math.cos(Math.PI / 180 * rotate)); // compute text and target positions\n\n  var targetWidth = scale * (isHorizontal ? textHeight : textWidth);\n  var targetHeight = scale * (isHorizontal ? textWidth : textHeight);\n  textpad += 0.5 * (targetWidth * absSin + targetHeight * absCos);\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n\n  if (isHorizontal) {\n    targetX = x1 - textpad * dirSign(x1, x0);\n  } else {\n    targetY = y1 + textpad * dirSign(y0, y1);\n  }\n\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction getText(fullLayout, calcTrace, index, xa, ya) {\n  var trace = calcTrace[0].trace;\n  var texttemplate = trace.texttemplate;\n  var value;\n\n  if (texttemplate) {\n    value = calcTexttemplate(fullLayout, calcTrace, index, xa, ya);\n  } else if (trace.textinfo) {\n    value = calcTextinfo(calcTrace, index, xa, ya);\n  } else {\n    value = helpers.getValue(trace.text, index);\n  }\n\n  return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, calcTrace, index, xa, ya) {\n  var trace = calcTrace[0].trace;\n  var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n  if (!texttemplate) return '';\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n\n  var cdi = calcTrace[index];\n  var obj = {};\n  obj.label = cdi.p;\n  obj.labelLabel = formatLabel(cdi.p);\n  var tx = Lib.castOption(trace, cdi.i, 'text');\n  if (tx === 0 || tx) obj.text = tx;\n  obj.value = cdi.s;\n  obj.valueLabel = formatNumber(cdi.s);\n  var pt = {};\n  appendArrayPointValue(pt, trace, cdi.i);\n\n  if (isWaterfall) {\n    obj.delta = +cdi.rawS || cdi.s;\n    obj.deltaLabel = formatNumber(obj.delta);\n    obj.final = cdi.v;\n    obj.finalLabel = formatNumber(obj.final);\n    obj.initial = obj.final - obj.delta;\n    obj.initialLabel = formatNumber(obj.initial);\n  }\n\n  if (isFunnel) {\n    obj.value = cdi.s;\n    obj.valueLabel = formatNumber(obj.value);\n    obj.percentInitial = cdi.begR;\n    obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n    obj.percentPrevious = cdi.difR;\n    obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n    obj.percentTotal = cdi.sumR;\n    obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n  }\n\n  var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  if (customdata) obj.customdata = customdata;\n  return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(calcTrace, index, xa, ya) {\n  var trace = calcTrace[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n\n  var textinfo = trace.textinfo;\n  var cdi = calcTrace[index];\n  var parts = textinfo.split('+');\n  var text = [];\n  var tx;\n\n  var hasFlag = function (flag) {\n    return parts.indexOf(flag) !== -1;\n  };\n\n  if (hasFlag('label')) {\n    text.push(formatLabel(calcTrace[index].p));\n  }\n\n  if (hasFlag('text')) {\n    tx = Lib.castOption(trace, cdi.i, 'text');\n    if (tx === 0 || tx) text.push(tx);\n  }\n\n  if (isWaterfall) {\n    var delta = +cdi.rawS || cdi.s;\n    var final = cdi.v;\n    var initial = final - delta;\n    if (hasFlag('initial')) text.push(formatNumber(initial));\n    if (hasFlag('delta')) text.push(formatNumber(delta));\n    if (hasFlag('final')) text.push(formatNumber(final));\n  }\n\n  if (isFunnel) {\n    if (hasFlag('value')) text.push(formatNumber(cdi.s));\n    var nPercent = 0;\n    if (hasFlag('percent initial')) nPercent++;\n    if (hasFlag('percent previous')) nPercent++;\n    if (hasFlag('percent total')) nPercent++;\n    var hasMultiplePercents = nPercent > 1;\n\n    if (hasFlag('percent initial')) {\n      tx = Lib.formatPercent(cdi.begR);\n      if (hasMultiplePercents) tx += ' of initial';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent previous')) {\n      tx = Lib.formatPercent(cdi.difR);\n      if (hasMultiplePercents) tx += ' of previous';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent total')) {\n      tx = Lib.formatPercent(cdi.sumR);\n      if (hasMultiplePercents) tx += ' of total';\n      text.push(tx);\n    }\n  }\n\n  return text.join('<br>');\n}\n\nmodule.exports = {\n  plot: plot,\n  toMoveInsideBar: toMoveInsideBar,\n  toMoveOutsideBar: toMoveOutsideBar\n};","map":null,"metadata":{},"sourceType":"script"}