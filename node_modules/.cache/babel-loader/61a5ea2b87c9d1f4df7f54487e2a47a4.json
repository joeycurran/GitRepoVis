{"ast":null,"code":"'use strict';\n\nvar createCamera = require('./camera.js');\n\nvar createAxes = require('gl-axes3d');\n\nvar axesRanges = require('gl-axes3d/properties');\n\nvar createSpikes = require('gl-spikes3d');\n\nvar createSelect = require('gl-select-static');\n\nvar createFBO = require('gl-fbo');\n\nvar drawTriangle = require('a-big-triangle');\n\nvar mouseChange = require('mouse-change');\n\nvar perspective = require('gl-mat4/perspective');\n\nvar ortho = require('gl-mat4/ortho');\n\nvar createShader = require('./lib/shader');\n\nvar isMobile = require('is-mobile')({\n  tablet: true\n});\n\nmodule.exports = {\n  createScene: createScene,\n  createCamera: createCamera\n};\n\nfunction MouseSelect() {\n  this.mouse = [-1, -1];\n  this.screen = null;\n  this.distance = Infinity;\n  this.index = null;\n  this.dataCoordinate = null;\n  this.dataPosition = null;\n  this.object = null;\n  this.data = null;\n}\n\nfunction getContext(canvas, options) {\n  var gl = null;\n\n  try {\n    gl = canvas.getContext('webgl', options);\n\n    if (!gl) {\n      gl = canvas.getContext('experimental-webgl', options);\n    }\n  } catch (e) {\n    return null;\n  }\n\n  return gl;\n}\n\nfunction roundUpPow10(x) {\n  var y = Math.round(Math.log(Math.abs(x)) / Math.log(10));\n\n  if (y < 0) {\n    var base = Math.round(Math.pow(10, -y));\n    return Math.ceil(x * base) / base;\n  } else if (y > 0) {\n    var base = Math.round(Math.pow(10, y));\n    return Math.ceil(x / base) * base;\n  }\n\n  return Math.ceil(x);\n}\n\nfunction defaultBool(x) {\n  if (typeof x === 'boolean') {\n    return x;\n  }\n\n  return true;\n}\n\nfunction createScene(options) {\n  options = options || {};\n  options.camera = options.camera || {};\n  var canvas = options.canvas;\n\n  if (!canvas) {\n    canvas = document.createElement('canvas');\n\n    if (options.container) {\n      var container = options.container;\n      container.appendChild(canvas);\n    } else {\n      document.body.appendChild(canvas);\n    }\n  }\n\n  var gl = options.gl;\n\n  if (!gl) {\n    gl = getContext(canvas, options.glOptions || {\n      premultipliedAlpha: true,\n      antialias: true,\n      preserveDrawingBuffer: isMobile\n    });\n  }\n\n  if (!gl) {\n    throw new Error('webgl not supported');\n  } //Initial bounds\n\n\n  var bounds = options.bounds || [[-10, -10, -10], [10, 10, 10]]; //Create selection\n\n  var selection = new MouseSelect(); //Accumulation buffer\n\n  var accumBuffer = createFBO(gl, [gl.drawingBufferWidth, gl.drawingBufferHeight], {\n    preferFloat: !isMobile\n  });\n  var accumShader = createShader(gl);\n  var isOrtho = options.cameraObject && options.cameraObject._ortho === true || options.camera.projection && options.camera.projection.type === 'orthographic' || false; //Create a camera\n\n  var cameraOptions = {\n    eye: options.camera.eye || [2, 0, 0],\n    center: options.camera.center || [0, 0, 0],\n    up: options.camera.up || [0, 1, 0],\n    zoomMin: options.camera.zoomMax || 0.1,\n    zoomMax: options.camera.zoomMin || 100,\n    mode: options.camera.mode || 'turntable',\n    _ortho: isOrtho\n  }; //Create axes\n\n  var axesOptions = options.axes || {};\n  var axes = createAxes(gl, axesOptions);\n  axes.enable = !axesOptions.disable; //Create spikes\n\n  var spikeOptions = options.spikes || {};\n  var spikes = createSpikes(gl, spikeOptions); //Object list is empty initially\n\n  var objects = [];\n  var pickBufferIds = [];\n  var pickBufferCount = [];\n  var pickBuffers = []; //Dirty flag, skip redraw if scene static\n\n  var dirty = true;\n  var pickDirty = true;\n  var projection = new Array(16);\n  var model = new Array(16);\n  var cameraParams = {\n    view: null,\n    projection: projection,\n    model: model,\n    _ortho: false\n  };\n  var pickDirty = true;\n  var viewShape = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  var camera = options.cameraObject || createCamera(canvas, cameraOptions); //Create scene object\n\n  var scene = {\n    gl: gl,\n    contextLost: false,\n    pixelRatio: options.pixelRatio || 1,\n    canvas: canvas,\n    selection: selection,\n    camera: camera,\n    axes: axes,\n    axesPixels: null,\n    spikes: spikes,\n    bounds: bounds,\n    objects: objects,\n    shape: viewShape,\n    aspect: options.aspectRatio || [1, 1, 1],\n    pickRadius: options.pickRadius || 10,\n    zNear: options.zNear || 0.01,\n    zFar: options.zFar || 1000,\n    fovy: options.fovy || Math.PI / 4,\n    clearColor: options.clearColor || [0, 0, 0, 0],\n    autoResize: defaultBool(options.autoResize),\n    autoBounds: defaultBool(options.autoBounds),\n    autoScale: !!options.autoScale,\n    autoCenter: defaultBool(options.autoCenter),\n    clipToBounds: defaultBool(options.clipToBounds),\n    snapToData: !!options.snapToData,\n    onselect: options.onselect || null,\n    onrender: options.onrender || null,\n    onclick: options.onclick || null,\n    cameraParams: cameraParams,\n    oncontextloss: null,\n    mouseListener: null,\n    _stopped: false,\n    getAspectratio: function () {\n      return {\n        x: this.aspect[0],\n        y: this.aspect[1],\n        z: this.aspect[2]\n      };\n    },\n    setAspectratio: function (aspectratio) {\n      this.aspect[0] = aspectratio.x;\n      this.aspect[1] = aspectratio.y;\n      this.aspect[2] = aspectratio.z;\n    }\n  };\n  var pickShape = [gl.drawingBufferWidth / scene.pixelRatio | 0, gl.drawingBufferHeight / scene.pixelRatio | 0];\n\n  function resizeListener() {\n    if (scene._stopped) {\n      return;\n    }\n\n    if (!scene.autoResize) {\n      return;\n    }\n\n    var parent = canvas.parentNode;\n    var width = 1;\n    var height = 1;\n\n    if (parent && parent !== document.body) {\n      width = parent.clientWidth;\n      height = parent.clientHeight;\n    } else {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    }\n\n    var nextWidth = Math.ceil(width * scene.pixelRatio) | 0;\n    var nextHeight = Math.ceil(height * scene.pixelRatio) | 0;\n\n    if (nextWidth !== canvas.width || nextHeight !== canvas.height) {\n      canvas.width = nextWidth;\n      canvas.height = nextHeight;\n      var style = canvas.style;\n      style.position = style.position || 'absolute';\n      style.left = '0px';\n      style.top = '0px';\n      style.width = width + 'px';\n      style.height = height + 'px';\n      dirty = true;\n    }\n  }\n\n  if (scene.autoResize) {\n    resizeListener();\n  }\n\n  window.addEventListener('resize', resizeListener);\n\n  function reallocPickIds() {\n    var numObjs = objects.length;\n    var numPick = pickBuffers.length;\n\n    for (var i = 0; i < numPick; ++i) {\n      pickBufferCount[i] = 0;\n    }\n\n    obj_loop: for (var i = 0; i < numObjs; ++i) {\n      var obj = objects[i];\n      var pickCount = obj.pickSlots;\n\n      if (!pickCount) {\n        pickBufferIds[i] = -1;\n        continue;\n      }\n\n      for (var j = 0; j < numPick; ++j) {\n        if (pickBufferCount[j] + pickCount < 255) {\n          pickBufferIds[i] = j;\n          obj.setPickBase(pickBufferCount[j] + 1);\n          pickBufferCount[j] += pickCount;\n          continue obj_loop;\n        }\n      } //Create new pick buffer\n\n\n      var nbuffer = createSelect(gl, viewShape);\n      pickBufferIds[i] = numPick;\n      pickBuffers.push(nbuffer);\n      pickBufferCount.push(pickCount);\n      obj.setPickBase(1);\n      numPick += 1;\n    }\n\n    while (numPick > 0 && pickBufferCount[numPick - 1] === 0) {\n      pickBufferCount.pop();\n      pickBuffers.pop().dispose();\n    }\n  }\n\n  scene.update = function (options) {\n    if (scene._stopped) {\n      return;\n    }\n\n    options = options || {};\n    dirty = true;\n    pickDirty = true;\n  };\n\n  scene.add = function (obj) {\n    if (scene._stopped) {\n      return;\n    }\n\n    obj.axes = axes;\n    objects.push(obj);\n    pickBufferIds.push(-1);\n    dirty = true;\n    pickDirty = true;\n    reallocPickIds();\n  };\n\n  scene.remove = function (obj) {\n    if (scene._stopped) {\n      return;\n    }\n\n    var idx = objects.indexOf(obj);\n\n    if (idx < 0) {\n      return;\n    }\n\n    objects.splice(idx, 1);\n    pickBufferIds.pop();\n    dirty = true;\n    pickDirty = true;\n    reallocPickIds();\n  };\n\n  scene.dispose = function () {\n    if (scene._stopped) {\n      return;\n    }\n\n    scene._stopped = true;\n    window.removeEventListener('resize', resizeListener);\n    canvas.removeEventListener('webglcontextlost', checkContextLoss);\n    scene.mouseListener.enabled = false;\n\n    if (scene.contextLost) {\n      return;\n    } //Destroy objects\n\n\n    axes.dispose();\n    spikes.dispose();\n\n    for (var i = 0; i < objects.length; ++i) {\n      objects[i].dispose();\n    } //Clean up buffers\n\n\n    accumBuffer.dispose();\n\n    for (var i = 0; i < pickBuffers.length; ++i) {\n      pickBuffers[i].dispose();\n    } //Clean up shaders\n\n\n    accumShader.dispose(); //Release all references\n\n    gl = null;\n    axes = null;\n    spikes = null;\n    objects = [];\n  }; //Update mouse position\n\n\n  scene._mouseRotating = false;\n  scene._prevButtons = 0;\n\n  scene.enableMouseListeners = function () {\n    scene.mouseListener = mouseChange(canvas, function (buttons, x, y) {\n      if (scene._stopped) {\n        return;\n      }\n\n      var numPick = pickBuffers.length;\n      var numObjs = objects.length;\n      var prevObj = selection.object;\n      selection.distance = Infinity;\n      selection.mouse[0] = x;\n      selection.mouse[1] = y;\n      selection.object = null;\n      selection.screen = null;\n      selection.dataCoordinate = selection.dataPosition = null;\n      var change = false;\n\n      if (buttons && scene._prevButtons) {\n        scene._mouseRotating = true;\n      } else {\n        if (scene._mouseRotating) {\n          pickDirty = true;\n        }\n\n        scene._mouseRotating = false;\n\n        for (var i = 0; i < numPick; ++i) {\n          var result = pickBuffers[i].query(x, pickShape[1] - y - 1, scene.pickRadius);\n\n          if (result) {\n            if (result.distance > selection.distance) {\n              continue;\n            }\n\n            for (var j = 0; j < numObjs; ++j) {\n              var obj = objects[j];\n\n              if (pickBufferIds[j] !== i) {\n                continue;\n              }\n\n              var objPick = obj.pick(result);\n\n              if (objPick) {\n                selection.buttons = buttons;\n                selection.screen = result.coord;\n                selection.distance = result.distance;\n                selection.object = obj;\n                selection.index = objPick.distance;\n                selection.dataPosition = objPick.position;\n                selection.dataCoordinate = objPick.dataCoordinate;\n                selection.data = objPick;\n                change = true;\n              }\n            }\n          }\n        }\n      }\n\n      if (prevObj && prevObj !== selection.object) {\n        if (prevObj.highlight) {\n          prevObj.highlight(null);\n        }\n\n        dirty = true;\n      }\n\n      if (selection.object) {\n        if (selection.object.highlight) {\n          selection.object.highlight(selection.data);\n        }\n\n        dirty = true;\n      }\n\n      change = change || selection.object !== prevObj;\n\n      if (change && scene.onselect) {\n        scene.onselect(selection);\n      }\n\n      if (buttons & 1 && !(scene._prevButtons & 1) && scene.onclick) {\n        scene.onclick(selection);\n      }\n\n      scene._prevButtons = buttons;\n    });\n  };\n\n  function checkContextLoss() {\n    if (scene.contextLost) {\n      return true;\n    }\n\n    if (gl.isContextLost()) {\n      scene.contextLost = true;\n      scene.mouseListener.enabled = false;\n      scene.selection.object = null;\n\n      if (scene.oncontextloss) {\n        scene.oncontextloss();\n      }\n    }\n  }\n\n  canvas.addEventListener('webglcontextlost', checkContextLoss); //Render the scene for mouse picking\n\n  function renderPick() {\n    if (checkContextLoss()) {\n      return;\n    }\n\n    gl.colorMask(true, true, true, true);\n    gl.depthMask(true);\n    gl.disable(gl.BLEND);\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LEQUAL);\n    var numObjs = objects.length;\n    var numPick = pickBuffers.length;\n\n    for (var j = 0; j < numPick; ++j) {\n      var buf = pickBuffers[j];\n      buf.shape = pickShape;\n      buf.begin();\n\n      for (var i = 0; i < numObjs; ++i) {\n        if (pickBufferIds[i] !== j) {\n          continue;\n        }\n\n        var obj = objects[i];\n\n        if (obj.drawPick) {\n          obj.pixelRatio = 1;\n          obj.drawPick(cameraParams);\n        }\n      }\n\n      buf.end();\n    }\n  }\n\n  var nBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  var prevBounds = [nBounds[0].slice(), nBounds[1].slice()];\n\n  function redraw() {\n    if (checkContextLoss()) {\n      return;\n    }\n\n    resizeListener(); //Tick camera\n\n    var cameraMoved = scene.camera.tick();\n    cameraParams.view = scene.camera.matrix;\n    dirty = dirty || cameraMoved;\n    pickDirty = pickDirty || cameraMoved; //Set pixel ratio\n\n    axes.pixelRatio = scene.pixelRatio;\n    spikes.pixelRatio = scene.pixelRatio; //Check if any objects changed, recalculate bounds\n\n    var numObjs = objects.length;\n    var lo = nBounds[0];\n    var hi = nBounds[1];\n    lo[0] = lo[1] = lo[2] = Infinity;\n    hi[0] = hi[1] = hi[2] = -Infinity;\n\n    for (var i = 0; i < numObjs; ++i) {\n      var obj = objects[i]; //Set the axes properties for each object\n\n      obj.pixelRatio = scene.pixelRatio;\n      obj.axes = scene.axes;\n      dirty = dirty || !!obj.dirty;\n      pickDirty = pickDirty || !!obj.dirty;\n      var obb = obj.bounds;\n\n      if (obb) {\n        var olo = obb[0];\n        var ohi = obb[1];\n\n        for (var j = 0; j < 3; ++j) {\n          lo[j] = Math.min(lo[j], olo[j]);\n          hi[j] = Math.max(hi[j], ohi[j]);\n        }\n      }\n    } //Recalculate bounds\n\n\n    var bounds = scene.bounds;\n\n    if (scene.autoBounds) {\n      for (var j = 0; j < 3; ++j) {\n        if (hi[j] < lo[j]) {\n          lo[j] = -1;\n          hi[j] = 1;\n        } else {\n          if (lo[j] === hi[j]) {\n            lo[j] -= 1;\n            hi[j] += 1;\n          }\n\n          var padding = 0.05 * (hi[j] - lo[j]);\n          lo[j] = lo[j] - padding;\n          hi[j] = hi[j] + padding;\n        }\n\n        bounds[0][j] = lo[j];\n        bounds[1][j] = hi[j];\n      }\n    }\n\n    var boundsChanged = false;\n\n    for (var j = 0; j < 3; ++j) {\n      boundsChanged = boundsChanged || prevBounds[0][j] !== bounds[0][j] || prevBounds[1][j] !== bounds[1][j];\n      prevBounds[0][j] = bounds[0][j];\n      prevBounds[1][j] = bounds[1][j];\n    } //Recalculate bounds\n\n\n    pickDirty = pickDirty || boundsChanged;\n    dirty = dirty || boundsChanged;\n\n    if (!dirty) {\n      return;\n    }\n\n    if (boundsChanged) {\n      var tickSpacing = [0, 0, 0];\n\n      for (var i = 0; i < 3; ++i) {\n        tickSpacing[i] = roundUpPow10((bounds[1][i] - bounds[0][i]) / 10.0);\n      }\n\n      if (axes.autoTicks) {\n        axes.update({\n          bounds: bounds,\n          tickSpacing: tickSpacing\n        });\n      } else {\n        axes.update({\n          bounds: bounds\n        });\n      }\n    } //Get scene\n\n\n    var width = gl.drawingBufferWidth;\n    var height = gl.drawingBufferHeight;\n    viewShape[0] = width;\n    viewShape[1] = height;\n    pickShape[0] = Math.max(width / scene.pixelRatio, 1) | 0;\n    pickShape[1] = Math.max(height / scene.pixelRatio, 1) | 0; //Compute camera parameters\n\n    if (isOrtho) {\n      ortho(projection, -width / height, width / height, -1, 1, scene.zNear, scene.zFar);\n      cameraParams._ortho = true;\n    } else {\n      perspective(projection, scene.fovy, width / height, scene.zNear, scene.zFar);\n      cameraParams._ortho = false;\n    } //Compute model matrix\n\n\n    for (var i = 0; i < 16; ++i) {\n      model[i] = 0;\n    }\n\n    model[15] = 1;\n    var maxS = 0;\n\n    for (var i = 0; i < 3; ++i) {\n      maxS = Math.max(maxS, bounds[1][i] - bounds[0][i]);\n    }\n\n    for (var i = 0; i < 3; ++i) {\n      if (scene.autoScale) {\n        model[5 * i] = scene.aspect[i] / (bounds[1][i] - bounds[0][i]);\n      } else {\n        model[5 * i] = 1 / maxS;\n      }\n\n      if (scene.autoCenter) {\n        model[12 + i] = -model[5 * i] * 0.5 * (bounds[0][i] + bounds[1][i]);\n      }\n    } //Apply axes/clip bounds\n\n\n    for (var i = 0; i < numObjs; ++i) {\n      var obj = objects[i]; //Set axes bounds\n\n      obj.axesBounds = bounds; //Set clip bounds\n\n      if (scene.clipToBounds) {\n        obj.clipBounds = bounds;\n      }\n    } //Set spike parameters\n\n\n    if (selection.object) {\n      if (scene.snapToData) {\n        spikes.position = selection.dataCoordinate;\n      } else {\n        spikes.position = selection.dataPosition;\n      }\n\n      spikes.bounds = bounds;\n    } //If state changed, then redraw pick buffers\n\n\n    if (pickDirty) {\n      pickDirty = false;\n      renderPick();\n    } //Recalculate pixel data\n\n\n    scene.axesPixels = axesRanges(scene.axes, cameraParams, width, height); //Call render callback\n\n    if (scene.onrender) {\n      scene.onrender();\n    } //Read value\n\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, width, height); //General strategy: 3 steps\n    //  1. render non-transparent objects\n    //  2. accumulate transparent objects into separate fbo\n    //  3. composite final scene\n    //Clear FBO\n\n    var clearColor = scene.clearColor;\n    gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.depthMask(true);\n    gl.colorMask(true, true, true, true);\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LEQUAL);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.CULL_FACE); //most visualization surfaces are 2 sided\n    //Render opaque pass\n\n    var hasTransparent = false;\n\n    if (axes.enable) {\n      hasTransparent = hasTransparent || axes.isTransparent();\n      axes.draw(cameraParams);\n    }\n\n    spikes.axes = axes;\n\n    if (selection.object) {\n      spikes.draw(cameraParams);\n    }\n\n    gl.disable(gl.CULL_FACE); //most visualization surfaces are 2 sided\n\n    for (var i = 0; i < numObjs; ++i) {\n      var obj = objects[i];\n      obj.axes = axes;\n      obj.pixelRatio = scene.pixelRatio;\n\n      if (obj.isOpaque && obj.isOpaque()) {\n        obj.draw(cameraParams);\n      }\n\n      if (obj.isTransparent && obj.isTransparent()) {\n        hasTransparent = true;\n      }\n    }\n\n    if (hasTransparent) {\n      //Render transparent pass\n      accumBuffer.shape = viewShape;\n      accumBuffer.bind();\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n      gl.colorMask(false, false, false, false);\n      gl.depthMask(true);\n      gl.depthFunc(gl.LESS); //Render forward facing objects\n\n      if (axes.enable && axes.isTransparent()) {\n        axes.drawTransparent(cameraParams);\n      }\n\n      for (var i = 0; i < numObjs; ++i) {\n        var obj = objects[i];\n\n        if (obj.isOpaque && obj.isOpaque()) {\n          obj.draw(cameraParams);\n        }\n      } //Render transparent pass\n\n\n      gl.enable(gl.BLEND);\n      gl.blendEquation(gl.FUNC_ADD);\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.colorMask(true, true, true, true);\n      gl.depthMask(false);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      if (axes.isTransparent()) {\n        axes.drawTransparent(cameraParams);\n      }\n\n      for (var i = 0; i < numObjs; ++i) {\n        var obj = objects[i];\n\n        if (obj.isTransparent && obj.isTransparent()) {\n          obj.drawTransparent(cameraParams);\n        }\n      } //Unbind framebuffer\n\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null); //Draw composite pass\n\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.disable(gl.DEPTH_TEST);\n      accumShader.bind();\n      accumBuffer.color[0].bind(0);\n      accumShader.uniforms.accumBuffer = 0;\n      drawTriangle(gl); //Turn off blending\n\n      gl.disable(gl.BLEND);\n    } //Clear dirty flags\n\n\n    dirty = false;\n\n    for (var i = 0; i < numObjs; ++i) {\n      objects[i].dirty = false;\n    }\n  } //Draw the whole scene\n\n\n  function render() {\n    if (scene._stopped || scene.contextLost) {\n      return;\n    } // this order is important: ios safari sometimes has sync raf\n\n\n    redraw();\n    requestAnimationFrame(render);\n  }\n\n  scene.enableMouseListeners();\n  render(); //Force redraw of whole scene\n\n  scene.redraw = function () {\n    if (scene._stopped) {\n      return;\n    }\n\n    dirty = true;\n    redraw();\n  };\n\n  return scene;\n}","map":null,"metadata":{},"sourceType":"script"}