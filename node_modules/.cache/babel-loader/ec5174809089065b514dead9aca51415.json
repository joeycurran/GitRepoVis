{"ast":null,"code":"/*jshint unused:true*/\n\n/*\nInput:  matrix      ; a 4x4 matrix\nOutput: translation ; a 3 component vector\n        scale       ; a 3 component vector\n        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector\n        perspective ; a 4 component vector\n        quaternion  ; a 4 component vector\nReturns false if the matrix cannot be decomposed, true if it can\n\n\nReferences:\nhttps://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js\nhttps://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc\nhttp://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix\n*/\nvar normalize = require('./normalize');\n\nvar create = require('gl-mat4/create');\n\nvar clone = require('gl-mat4/clone');\n\nvar determinant = require('gl-mat4/determinant');\n\nvar invert = require('gl-mat4/invert');\n\nvar transpose = require('gl-mat4/transpose');\n\nvar vec3 = {\n  length: require('gl-vec3/length'),\n  normalize: require('gl-vec3/normalize'),\n  dot: require('gl-vec3/dot'),\n  cross: require('gl-vec3/cross')\n};\nvar tmp = create();\nvar perspectiveMatrix = create();\nvar tmpVec4 = [0, 0, 0, 0];\nvar row = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\nvar pdum3 = [0, 0, 0];\n\nmodule.exports = function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {\n  if (!translation) translation = [0, 0, 0];\n  if (!scale) scale = [0, 0, 0];\n  if (!skew) skew = [0, 0, 0];\n  if (!perspective) perspective = [0, 0, 0, 1];\n  if (!quaternion) quaternion = [0, 0, 0, 1]; //normalize, if not possible then bail out early\n\n  if (!normalize(tmp, matrix)) return false; // perspectiveMatrix is used to solve for perspective, but it also provides\n  // an easy way to test for singularity of the upper 3x3 component.\n\n  clone(perspectiveMatrix, tmp);\n  perspectiveMatrix[3] = 0;\n  perspectiveMatrix[7] = 0;\n  perspectiveMatrix[11] = 0;\n  perspectiveMatrix[15] = 1; // If the perspectiveMatrix is not invertible, we are also unable to\n  // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.\n\n  if (Math.abs(determinant(perspectiveMatrix) < 1e-8)) return false;\n  var a03 = tmp[3],\n      a13 = tmp[7],\n      a23 = tmp[11],\n      a30 = tmp[12],\n      a31 = tmp[13],\n      a32 = tmp[14],\n      a33 = tmp[15]; // First, isolate perspective.\n\n  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {\n    tmpVec4[0] = a03;\n    tmpVec4[1] = a13;\n    tmpVec4[2] = a23;\n    tmpVec4[3] = a33; // Solve the equation by inverting perspectiveMatrix and multiplying\n    // rightHandSide by the inverse.\n    // resuing the perspectiveMatrix here since it's no longer needed\n\n    var ret = invert(perspectiveMatrix, perspectiveMatrix);\n    if (!ret) return false;\n    transpose(perspectiveMatrix, perspectiveMatrix); //multiply by transposed inverse perspective matrix, into perspective vec4\n\n    vec4multMat4(perspective, tmpVec4, perspectiveMatrix);\n  } else {\n    //no perspective\n    perspective[0] = perspective[1] = perspective[2] = 0;\n    perspective[3] = 1;\n  } // Next take care of translation\n\n\n  translation[0] = a30;\n  translation[1] = a31;\n  translation[2] = a32; // Now get scale and shear. 'row' is a 3 element array of 3 component vectors\n\n  mat3from4(row, tmp); // Compute X scale factor and normalize first row.\n\n  scale[0] = vec3.length(row[0]);\n  vec3.normalize(row[0], row[0]); // Compute XY shear factor and make 2nd row orthogonal to 1st.\n\n  skew[0] = vec3.dot(row[0], row[1]);\n  combine(row[1], row[1], row[0], 1.0, -skew[0]); // Now, compute Y scale and normalize 2nd row.\n\n  scale[1] = vec3.length(row[1]);\n  vec3.normalize(row[1], row[1]);\n  skew[0] /= scale[1]; // Compute XZ and YZ shears, orthogonalize 3rd row\n\n  skew[1] = vec3.dot(row[0], row[2]);\n  combine(row[2], row[2], row[0], 1.0, -skew[1]);\n  skew[2] = vec3.dot(row[1], row[2]);\n  combine(row[2], row[2], row[1], 1.0, -skew[2]); // Next, get Z scale and normalize 3rd row.\n\n  scale[2] = vec3.length(row[2]);\n  vec3.normalize(row[2], row[2]);\n  skew[1] /= scale[2];\n  skew[2] /= scale[2]; // At this point, the matrix (in rows) is orthonormal.\n  // Check for a coordinate system flip.  If the determinant\n  // is -1, then negate the matrix and the scaling factors.\n\n  vec3.cross(pdum3, row[1], row[2]);\n\n  if (vec3.dot(row[0], pdum3) < 0) {\n    for (var i = 0; i < 3; i++) {\n      scale[i] *= -1;\n      row[i][0] *= -1;\n      row[i][1] *= -1;\n      row[i][2] *= -1;\n    }\n  } // Now, get the rotations out\n\n\n  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));\n  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));\n  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));\n  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));\n  if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];\n  if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];\n  if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];\n  return true;\n}; //will be replaced by gl-vec4 eventually\n\n\nfunction vec4multMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n} //gets upper-left of a 4x4 matrix into a 3x3 of vectors\n\n\nfunction mat3from4(out, mat4x4) {\n  out[0][0] = mat4x4[0];\n  out[0][1] = mat4x4[1];\n  out[0][2] = mat4x4[2];\n  out[1][0] = mat4x4[4];\n  out[1][1] = mat4x4[5];\n  out[1][2] = mat4x4[6];\n  out[2][0] = mat4x4[8];\n  out[2][1] = mat4x4[9];\n  out[2][2] = mat4x4[10];\n}\n\nfunction combine(out, a, b, scale1, scale2) {\n  out[0] = a[0] * scale1 + b[0] * scale2;\n  out[1] = a[1] * scale1 + b[1] * scale2;\n  out[2] = a[2] * scale1 + b[2] * scale2;\n}","map":null,"metadata":{},"sourceType":"script"}