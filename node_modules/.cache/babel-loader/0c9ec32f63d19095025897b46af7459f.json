{"ast":null,"code":"/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n'use strict';\n\nvar _slicedToArray = require(\"/Users/joeycurran/Desktop/College/GitHub/GitRepoVis/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst search = require('binary-search-bounds');\n\nconst clamp = require('clamp');\n\nconst rect = require('parse-rect');\n\nconst getBounds = require('array-bounds');\n\nconst pick = require('pick-by-alias');\n\nconst defined = require('defined');\n\nconst flatten = require('flatten-vertex-data');\n\nconst isObj = require('is-obj');\n\nconst dtype = require('dtype');\n\nconst log2 = require('math-log2');\n\nconst MAX_GROUP_ID = 1073741824;\n\nmodule.exports = function cluster(srcPoints, options) {\n  if (!options) options = {};\n  srcPoints = flatten(srcPoints, 'float64');\n  options = pick(options, {\n    bounds: 'range bounds dataBox databox',\n    maxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n    dtype: 'type dtype format out dst output destination' // sort: 'sortBy sortby sort',\n    // pick: 'pick levelPoint',\n    // nodeSize: 'node nodeSize minNodeSize minSize size'\n\n  }); // let nodeSize = defined(options.nodeSize, 1)\n\n  let maxDepth = defined(options.maxDepth, 255);\n  let bounds = defined(options.bounds, getBounds(srcPoints, 2));\n  if (bounds[0] === bounds[2]) bounds[2]++;\n  if (bounds[1] === bounds[3]) bounds[3]++;\n  let points = normalize(srcPoints, bounds); // init variables\n\n  let n = srcPoints.length >>> 1;\n  let ids;\n  if (!options.dtype) options.dtype = 'array';\n\n  if (typeof options.dtype === 'string') {\n    ids = new (dtype(options.dtype))(n);\n  } else if (options.dtype) {\n    ids = options.dtype;\n    if (Array.isArray(ids)) ids.length = n;\n  }\n\n  for (let i = 0; i < n; ++i) {\n    ids[i] = i;\n  } // representative point indexes for levels\n\n\n  let levels = []; // starting indexes of subranges in sub levels, levels.length * 4\n\n  let sublevels = []; // unique group ids, sorted in z-curve fashion within levels by shifting bits\n\n  let groups = []; // level offsets in `ids`\n\n  let offsets = []; // sort points\n\n  sort(0, 0, 1, ids, 0, 1); // return reordered ids with provided methods\n  // save level offsets in output buffer\n\n  let offset = 0;\n\n  for (let level = 0; level < levels.length; level++) {\n    let levelItems = levels[level];\n    if (ids.set) ids.set(levelItems, offset);else {\n      for (let i = 0, l = levelItems.length; i < l; i++) {\n        ids[i + offset] = levelItems[i];\n      }\n    }\n    let nextOffset = offset + levels[level].length;\n    offsets[level] = [offset, nextOffset];\n    offset = nextOffset;\n  }\n\n  ids.range = range;\n  return ids; // FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n\n  function sort(x, y, diam, ids, level, group) {\n    if (!ids.length) return null; // save first point as level representative\n\n    let levelItems = levels[level] || (levels[level] = []);\n    let levelGroups = groups[level] || (groups[level] = []);\n    let sublevel = sublevels[level] || (sublevels[level] = []);\n    let offset = levelItems.length;\n    level++; // max depth reached - put all items into a first group\n    // alternatively - if group id overflow - avoid proceeding\n\n    if (level > maxDepth || group > MAX_GROUP_ID) {\n      for (let i = 0; i < ids.length; i++) {\n        levelItems.push(ids[i]);\n        levelGroups.push(group);\n        sublevel.push(null, null, null, null);\n      }\n\n      return offset;\n    }\n\n    levelItems.push(ids[0]);\n    levelGroups.push(group);\n\n    if (ids.length <= 1) {\n      sublevel.push(null, null, null, null);\n      return offset;\n    }\n\n    let d2 = diam * .5;\n    let cx = x + d2,\n        cy = y + d2; // distribute points by 4 buckets\n\n    let lolo = [],\n        lohi = [],\n        hilo = [],\n        hihi = [];\n\n    for (let i = 1, l = ids.length; i < l; i++) {\n      let idx = ids[i],\n          x = points[idx * 2],\n          y = points[idx * 2 + 1];\n      x < cx ? y < cy ? lolo.push(idx) : lohi.push(idx) : y < cy ? hilo.push(idx) : hihi.push(idx);\n    }\n\n    group <<= 2;\n    sublevel.push(sort(x, y, d2, lolo, level, group), sort(x, cy, d2, lohi, level, group + 1), sort(cx, y, d2, hilo, level, group + 2), sort(cx, cy, d2, hihi, level, group + 3));\n    return offset;\n  } // get all points within the passed range\n\n\n  function range(...args) {\n    let options;\n\n    if (isObj(args[args.length - 1])) {\n      let arg = args.pop(); // detect if that was a rect object\n\n      if (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n        args = [arg];\n        options = {};\n      }\n\n      options = pick(arg, {\n        level: 'level maxLevel',\n        d: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n        lod: 'lod details ranges offsets'\n      });\n    } else {\n      options = {};\n    }\n\n    if (!args.length) args = bounds;\n    let box = rect(...args);\n    let _ref = [Math.min(box.x, box.x + box.width), Math.min(box.y, box.y + box.height), Math.max(box.x, box.x + box.width), Math.max(box.y, box.y + box.height)],\n        minX = _ref[0],\n        minY = _ref[1],\n        maxX = _ref[2],\n        maxY = _ref[3];\n\n    let _normalize = normalize([minX, minY, maxX, maxY], bounds),\n        _normalize2 = _slicedToArray(_normalize, 4),\n        nminX = _normalize2[0],\n        nminY = _normalize2[1],\n        nmaxX = _normalize2[2],\n        nmaxY = _normalize2[3];\n\n    let maxLevel = defined(options.level, levels.length); // limit maxLevel by px size\n\n    if (options.d != null) {\n      let d;\n      if (typeof options.d === 'number') d = [options.d, options.d];else if (options.d.length) d = options.d;\n      maxLevel = Math.min(Math.max(Math.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))), Math.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))), maxLevel);\n    }\n\n    maxLevel = Math.min(maxLevel, levels.length); // return levels of details\n\n    if (options.lod) {\n      return lod(nminX, nminY, nmaxX, nmaxY, maxLevel);\n    } // do selection ids\n\n\n    let selection = []; // FIXME: probably we can do LOD here beforehead\n\n    select(0, 0, 1, 0, 0, 1);\n\n    function select(lox, loy, d, level, from, to) {\n      if (from === null || to === null) return;\n      let hix = lox + d;\n      let hiy = loy + d; // if box does not intersect level - ignore\n\n      if (nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy) return;\n      if (level >= maxLevel) return;\n      if (from === to) return; // if points fall into box range - take it\n\n      let levelItems = levels[level];\n      if (to === undefined) to = levelItems.length;\n\n      for (let i = from; i < to; i++) {\n        let id = levelItems[i];\n        let px = srcPoints[id * 2];\n        let py = srcPoints[id * 2 + 1];\n\n        if (px >= minX && px <= maxX && py >= minY && py <= maxY) {\n          selection.push(id);\n        }\n      } // for every subsection do select\n\n\n      let offsets = sublevels[level];\n      let off0 = offsets[from * 4 + 0];\n      let off1 = offsets[from * 4 + 1];\n      let off2 = offsets[from * 4 + 2];\n      let off3 = offsets[from * 4 + 3];\n      let end = nextOffset(offsets, from + 1);\n      let d2 = d * .5;\n      let nextLevel = level + 1;\n      select(lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end);\n      select(lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end);\n      select(lox + d2, loy, d2, nextLevel, off2, off3 || end);\n      select(lox + d2, loy + d2, d2, nextLevel, off3, end);\n    }\n\n    function nextOffset(offsets, from) {\n      let offset = null,\n          i = 0;\n\n      while (offset === null) {\n        offset = offsets[from * 4 + i];\n        i++;\n        if (i > offsets.length) return null;\n      }\n\n      return offset;\n    }\n\n    return selection;\n  } // get range offsets within levels to render lods appropriate for zoom level\n  // TODO: it is possible to store minSize of a point to optimize neede level calc\n\n\n  function lod(lox, loy, hix, hiy, maxLevel) {\n    let ranges = [];\n\n    for (let level = 0; level < maxLevel; level++) {\n      let levelGroups = groups[level];\n      let from = offsets[level][0];\n      let levelGroupStart = group(lox, loy, level);\n      let levelGroupEnd = group(hix, hiy, level); // FIXME: utilize sublevels to speed up search range here\n\n      let startOffset = search.ge(levelGroups, levelGroupStart);\n      let endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1);\n      ranges[level] = [startOffset + from, endOffset + from];\n    }\n\n    return ranges;\n  } // get group id closest to the x,y coordinate, corresponding to a level\n\n\n  function group(x, y, level) {\n    let group = 1;\n    let cx = .5,\n        cy = .5;\n    let diam = .5;\n\n    for (let i = 0; i < level; i++) {\n      group <<= 2;\n      group += x < cx ? y < cy ? 0 : 1 : y < cy ? 2 : 3;\n      diam *= .5;\n      cx += x < cx ? -diam : diam;\n      cy += y < cy ? -diam : diam;\n    }\n\n    return group;\n  }\n}; // normalize points by bounds\n\n\nfunction normalize(pts, bounds) {\n  let _bounds = _slicedToArray(bounds, 4),\n      lox = _bounds[0],\n      loy = _bounds[1],\n      hix = _bounds[2],\n      hiy = _bounds[3];\n\n  let scaleX = 1.0 / (hix - lox);\n  let scaleY = 1.0 / (hiy - loy);\n  let result = new Array(pts.length);\n\n  for (let i = 0, n = pts.length / 2; i < n; i++) {\n    result[2 * i] = clamp((pts[2 * i] - lox) * scaleX, 0, 1);\n    result[2 * i + 1] = clamp((pts[2 * i + 1] - loy) * scaleY, 0, 1);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}