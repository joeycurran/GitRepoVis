{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nvar constants = require('./constants');\n\nmodule.exports = function plot(gd, plotinfo, cdimage, imageLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(imageLayer, cdimage, 'im').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var z = cd0.z;\n    var x0 = cd0.x0;\n    var y0 = cd0.y0;\n    var w = cd0.w;\n    var h = cd0.h;\n    var dx = trace.dx;\n    var dy = trace.dy;\n    var left, right, temp, top, bottom, i; // in case of log of a negative\n\n    i = 0;\n\n    while (left === undefined && i < w) {\n      left = xa.c2p(x0 + i * dx);\n      i++;\n    }\n\n    i = w;\n\n    while (right === undefined && i > 0) {\n      right = xa.c2p(x0 + i * dx);\n      i--;\n    }\n\n    i = 0;\n\n    while (top === undefined && i < h) {\n      top = ya.c2p(y0 + i * dy);\n      i++;\n    }\n\n    i = h;\n\n    while (bottom === undefined && i > 0) {\n      bottom = ya.c2p(y0 + i * dy);\n      i--;\n    }\n\n    if (right < left) {\n      temp = right;\n      right = left;\n      left = temp;\n    }\n\n    if (bottom < top) {\n      temp = top;\n      top = bottom;\n      bottom = temp;\n    } // Reduce image size when zoomed in to save memory\n\n\n    var extra = 0.5; // half the axis size\n\n    left = Math.max(-extra * xa._length, left);\n    right = Math.min((1 + extra) * xa._length, right);\n    top = Math.max(-extra * ya._length, top);\n    bottom = Math.min((1 + extra) * ya._length, bottom);\n    var imageWidth = Math.round(right - left);\n    var imageHeight = Math.round(bottom - top); // if image is entirely off-screen, don't even draw it\n\n    var isOffScreen = imageWidth <= 0 || imageHeight <= 0;\n\n    if (isOffScreen) {\n      var noImage = plotGroup.selectAll('image').data([]);\n      noImage.exit().remove();\n      return;\n    } // Draw each pixel\n\n\n    var canvas = document.createElement('canvas');\n    canvas.width = imageWidth;\n    canvas.height = imageHeight;\n    var context = canvas.getContext('2d');\n\n    var ipx = function (i) {\n      return Lib.constrain(Math.round(xa.c2p(x0 + i * dx) - left), 0, imageWidth);\n    };\n\n    var jpx = function (j) {\n      return Lib.constrain(Math.round(ya.c2p(y0 + j * dy) - top), 0, imageHeight);\n    };\n\n    var fmt = constants.colormodel[trace.colormodel].fmt;\n    var c;\n\n    for (i = 0; i < cd0.w; i++) {\n      var ipx0 = ipx(i);\n      var ipx1 = ipx(i + 1);\n      if (ipx1 === ipx0 || isNaN(ipx1) || isNaN(ipx0)) continue;\n\n      for (var j = 0; j < cd0.h; j++) {\n        var jpx0 = jpx(j);\n        var jpx1 = jpx(j + 1);\n        if (jpx1 === jpx0 || isNaN(jpx1) || isNaN(jpx0) || !z[j][i]) continue;\n        c = trace._scaler(z[j][i]);\n\n        if (c) {\n          context.fillStyle = trace.colormodel + '(' + fmt(c).join(',') + ')';\n        } else {\n          // Return a transparent pixel\n          context.fillStyle = 'rgba(0,0,0,0)';\n        }\n\n        context.fillRect(ipx0, jpx0, ipx1 - ipx0, jpx1 - jpx0);\n      }\n    }\n\n    var image3 = plotGroup.selectAll('image').data(cd);\n    image3.enter().append('svg:image').attr({\n      xmlns: xmlnsNamespaces.svg,\n      preserveAspectRatio: 'none'\n    });\n    image3.attr({\n      height: imageHeight,\n      width: imageWidth,\n      x: left,\n      y: top,\n      'xlink:href': canvas.toDataURL('image/png')\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}