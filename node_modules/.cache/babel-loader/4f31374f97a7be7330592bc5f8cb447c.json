{"ast":null,"code":"'use strict';\n\nmodule.exports = extractContour;\n\nvar ndarray = require('ndarray');\n\nvar pool = require('typedarray-pool');\n\nvar ndsort = require('ndarray-sort');\n\nvar contourAlgorithm = require('./lib/codegen');\n\nfunction getDimension(cells) {\n  var numCells = cells.length;\n  var d = 0;\n\n  for (var i = 0; i < numCells; ++i) {\n    d = Math.max(d, cells[i].length) | 0;\n  }\n\n  return d - 1;\n}\n\nfunction getSigns(values, level) {\n  var numVerts = values.length;\n  var vertexSigns = pool.mallocUint8(numVerts);\n\n  for (var i = 0; i < numVerts; ++i) {\n    vertexSigns[i] = values[i] < level | 0;\n  }\n\n  return vertexSigns;\n}\n\nfunction getEdges(cells, d) {\n  var numCells = cells.length;\n  var maxEdges = d * (d + 1) / 2 * numCells | 0;\n  var edges = pool.mallocUint32(maxEdges * 2);\n  var ePtr = 0;\n\n  for (var i = 0; i < numCells; ++i) {\n    var c = cells[i];\n    var d = c.length;\n\n    for (var j = 0; j < d; ++j) {\n      for (var k = 0; k < j; ++k) {\n        var a = c[k];\n        var b = c[j];\n        edges[ePtr++] = Math.min(a, b) | 0;\n        edges[ePtr++] = Math.max(a, b) | 0;\n      }\n    }\n  }\n\n  var nedges = ePtr / 2 | 0;\n  ndsort(ndarray(edges, [nedges, 2]));\n  var ptr = 2;\n\n  for (var i = 2; i < ePtr; i += 2) {\n    if (edges[i - 2] === edges[i] && edges[i - 1] === edges[i + 1]) {\n      continue;\n    }\n\n    edges[ptr++] = edges[i];\n    edges[ptr++] = edges[i + 1];\n  }\n\n  return ndarray(edges, [ptr / 2 | 0, 2]);\n}\n\nfunction getCrossingWeights(edges, values, signs, level) {\n  var edata = edges.data;\n  var numEdges = edges.shape[0];\n  var weights = pool.mallocDouble(numEdges);\n  var ptr = 0;\n\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n    var b = edata[2 * i + 1];\n\n    if (signs[a] === signs[b]) {\n      continue;\n    }\n\n    var va = values[a];\n    var vb = values[b];\n    edata[2 * ptr] = a;\n    edata[2 * ptr + 1] = b;\n    weights[ptr++] = (vb - level) / (vb - va);\n  }\n\n  edges.shape[0] = ptr;\n  return ndarray(weights, [ptr]);\n}\n\nfunction getCascade(edges, numVerts) {\n  var result = pool.mallocInt32(numVerts * 2);\n  var numEdges = edges.shape[0];\n  var edata = edges.data;\n  result[0] = 0;\n  var lastV = 0;\n\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n\n    if (a !== lastV) {\n      result[2 * lastV + 1] = i;\n\n      while (++lastV < a) {\n        result[2 * lastV] = i;\n        result[2 * lastV + 1] = i;\n      }\n\n      result[2 * lastV] = i;\n    }\n  }\n\n  result[2 * lastV + 1] = numEdges;\n\n  while (++lastV < numVerts) {\n    result[2 * lastV] = result[2 * lastV + 1] = numEdges;\n  }\n\n  return result;\n}\n\nfunction unpackEdges(edges) {\n  var ne = edges.shape[0] | 0;\n  var edata = edges.data;\n  var result = new Array(ne);\n\n  for (var i = 0; i < ne; ++i) {\n    result[i] = [edata[2 * i], edata[2 * i + 1]];\n  }\n\n  return result;\n}\n\nfunction extractContour(cells, values, level, d) {\n  level = level || 0.0; //If user didn't specify `d`, use brute force scan\n\n  if (typeof d === 'undefined') {\n    d = getDimension(cells);\n  } //Count number of cells\n\n\n  var numCells = cells.length;\n\n  if (numCells === 0 || d < 1) {\n    return {\n      cells: [],\n      vertexIds: [],\n      vertexWeights: []\n    };\n  } //Read in vertex signs\n\n\n  var vertexSigns = getSigns(values, +level); //First get 1-skeleton, find all crossings\n\n  var edges = getEdges(cells, d);\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level); //Build vertex cascade to speed up binary search\n\n  var vcascade = getCascade(edges, values.length | 0); //Then construct cells\n\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns); //Unpack data into pretty format\n\n  var uedges = unpackEdges(edges);\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0]); //Release data\n\n  pool.free(vertexSigns);\n  pool.free(edges.data);\n  pool.free(weights.data);\n  pool.free(vcascade);\n  return {\n    cells: faces,\n    vertexIds: uedges,\n    vertexWeights: uweights\n  };\n}","map":null,"metadata":{},"sourceType":"script"}