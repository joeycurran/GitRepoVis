{"ast":null,"code":"var DEFAULT_NORMALS_EPSILON = 1e-6;\nvar DEFAULT_FACE_EPSILON = 1e-6; //Estimate the vertex normals of a mesh\n\nexports.vertexNormals = function (faces, positions, specifiedEpsilon) {\n  var N = positions.length;\n  var normals = new Array(N);\n  var epsilon = specifiedEpsilon === void 0 ? DEFAULT_NORMALS_EPSILON : specifiedEpsilon; //Initialize normal array\n\n  for (var i = 0; i < N; ++i) {\n    normals[i] = [0.0, 0.0, 0.0];\n  } //Walk over all the faces and add per-vertex contribution to normal weights\n\n\n  for (var i = 0; i < faces.length; ++i) {\n    var f = faces[i];\n    var p = 0;\n    var c = f[f.length - 1];\n    var n = f[0];\n\n    for (var j = 0; j < f.length; ++j) {\n      //Shift indices back\n      p = c;\n      c = n;\n      n = f[(j + 1) % f.length];\n      var v0 = positions[p];\n      var v1 = positions[c];\n      var v2 = positions[n]; //Compute infineteismal arcs\n\n      var d01 = new Array(3);\n      var m01 = 0.0;\n      var d21 = new Array(3);\n      var m21 = 0.0;\n\n      for (var k = 0; k < 3; ++k) {\n        d01[k] = v0[k] - v1[k];\n        m01 += d01[k] * d01[k];\n        d21[k] = v2[k] - v1[k];\n        m21 += d21[k] * d21[k];\n      } //Accumulate values in normal\n\n\n      if (m01 * m21 > epsilon) {\n        var norm = normals[c];\n        var w = 1.0 / Math.sqrt(m01 * m21);\n\n        for (var k = 0; k < 3; ++k) {\n          var u = (k + 1) % 3;\n          var v = (k + 2) % 3;\n          norm[k] += w * (d21[u] * d01[v] - d21[v] * d01[u]);\n        }\n      }\n    }\n  } //Scale all normals to unit length\n\n\n  for (var i = 0; i < N; ++i) {\n    var norm = normals[i];\n    var m = 0.0;\n\n    for (var k = 0; k < 3; ++k) {\n      m += norm[k] * norm[k];\n    }\n\n    if (m > epsilon) {\n      var w = 1.0 / Math.sqrt(m);\n\n      for (var k = 0; k < 3; ++k) {\n        norm[k] *= w;\n      }\n    } else {\n      for (var k = 0; k < 3; ++k) {\n        norm[k] = 0.0;\n      }\n    }\n  } //Return the resulting set of patches\n\n\n  return normals;\n}; //Compute face normals of a mesh\n\n\nexports.faceNormals = function (faces, positions, specifiedEpsilon) {\n  var N = faces.length;\n  var normals = new Array(N);\n  var epsilon = specifiedEpsilon === void 0 ? DEFAULT_FACE_EPSILON : specifiedEpsilon;\n\n  for (var i = 0; i < N; ++i) {\n    var f = faces[i];\n    var pos = new Array(3);\n\n    for (var j = 0; j < 3; ++j) {\n      pos[j] = positions[f[j]];\n    }\n\n    var d01 = new Array(3);\n    var d21 = new Array(3);\n\n    for (var j = 0; j < 3; ++j) {\n      d01[j] = pos[1][j] - pos[0][j];\n      d21[j] = pos[2][j] - pos[0][j];\n    }\n\n    var n = new Array(3);\n    var l = 0.0;\n\n    for (var j = 0; j < 3; ++j) {\n      var u = (j + 1) % 3;\n      var v = (j + 2) % 3;\n      n[j] = d01[u] * d21[v] - d01[v] * d21[u];\n      l += n[j] * n[j];\n    }\n\n    if (l > epsilon) {\n      l = 1.0 / Math.sqrt(l);\n    } else {\n      l = 0.0;\n    }\n\n    for (var j = 0; j < 3; ++j) {\n      n[j] *= l;\n    }\n\n    normals[i] = n;\n  }\n\n  return normals;\n};","map":null,"metadata":{},"sourceType":"script"}