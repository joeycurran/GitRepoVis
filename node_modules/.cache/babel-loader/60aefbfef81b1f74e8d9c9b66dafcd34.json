{"ast":null,"code":"'use strict';\n\nvar createTexture = require('gl-texture2d');\n\nmodule.exports = createFBO;\nvar colorAttachmentArrays = null;\nvar FRAMEBUFFER_UNSUPPORTED;\nvar FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\nvar FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\nvar FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\n\nfunction saveFBOState(gl) {\n  var fbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n  var rbo = gl.getParameter(gl.RENDERBUFFER_BINDING);\n  var tex = gl.getParameter(gl.TEXTURE_BINDING_2D);\n  return [fbo, rbo, tex];\n}\n\nfunction restoreFBOState(gl, data) {\n  gl.bindFramebuffer(gl.FRAMEBUFFER, data[0]);\n  gl.bindRenderbuffer(gl.RENDERBUFFER, data[1]);\n  gl.bindTexture(gl.TEXTURE_2D, data[2]);\n}\n\nfunction lazyInitColorAttachments(gl, ext) {\n  var maxColorAttachments = gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);\n  colorAttachmentArrays = new Array(maxColorAttachments + 1);\n\n  for (var i = 0; i <= maxColorAttachments; ++i) {\n    var x = new Array(maxColorAttachments);\n\n    for (var j = 0; j < i; ++j) {\n      x[j] = gl.COLOR_ATTACHMENT0 + j;\n    }\n\n    for (var j = i; j < maxColorAttachments; ++j) {\n      x[j] = gl.NONE;\n    }\n\n    colorAttachmentArrays[i] = x;\n  }\n} //Throw an appropriate error\n\n\nfunction throwFBOError(status) {\n  switch (status) {\n    case FRAMEBUFFER_UNSUPPORTED:\n      throw new Error('gl-fbo: Framebuffer unsupported');\n\n    case FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      throw new Error('gl-fbo: Framebuffer incomplete attachment');\n\n    case FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      throw new Error('gl-fbo: Framebuffer incomplete dimensions');\n\n    case FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      throw new Error('gl-fbo: Framebuffer incomplete missing attachment');\n\n    default:\n      throw new Error('gl-fbo: Framebuffer failed for unspecified reason');\n  }\n} //Initialize a texture object\n\n\nfunction initTexture(gl, width, height, type, format, attachment) {\n  if (!type) {\n    return null;\n  }\n\n  var result = createTexture(gl, width, height, format, type);\n  result.magFilter = gl.NEAREST;\n  result.minFilter = gl.NEAREST;\n  result.mipSamples = 1;\n  result.bind();\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, result.handle, 0);\n  return result;\n} //Initialize a render buffer object\n\n\nfunction initRenderBuffer(gl, width, height, component, attachment) {\n  var result = gl.createRenderbuffer();\n  gl.bindRenderbuffer(gl.RENDERBUFFER, result);\n  gl.renderbufferStorage(gl.RENDERBUFFER, component, width, height);\n  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, result);\n  return result;\n} //Rebuild the frame buffer\n\n\nfunction rebuildFBO(fbo) {\n  //Save FBO state\n  var state = saveFBOState(fbo.gl);\n  var gl = fbo.gl;\n  var handle = fbo.handle = gl.createFramebuffer();\n  var width = fbo._shape[0];\n  var height = fbo._shape[1];\n  var numColors = fbo.color.length;\n  var ext = fbo._ext;\n  var useStencil = fbo._useStencil;\n  var useDepth = fbo._useDepth;\n  var colorType = fbo._colorType; //Bind the fbo\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, handle); //Allocate color buffers\n\n  for (var i = 0; i < numColors; ++i) {\n    fbo.color[i] = initTexture(gl, width, height, colorType, gl.RGBA, gl.COLOR_ATTACHMENT0 + i);\n  }\n\n  if (numColors === 0) {\n    fbo._color_rb = initRenderBuffer(gl, width, height, gl.RGBA4, gl.COLOR_ATTACHMENT0);\n\n    if (ext) {\n      ext.drawBuffersWEBGL(colorAttachmentArrays[0]);\n    }\n  } else if (numColors > 1) {\n    ext.drawBuffersWEBGL(colorAttachmentArrays[numColors]);\n  } //Allocate depth/stencil buffers\n\n\n  var WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');\n\n  if (WEBGL_depth_texture) {\n    if (useStencil) {\n      fbo.depth = initTexture(gl, width, height, WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);\n    } else if (useDepth) {\n      fbo.depth = initTexture(gl, width, height, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, gl.DEPTH_ATTACHMENT);\n    }\n  } else {\n    if (useDepth && useStencil) {\n      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);\n    } else if (useDepth) {\n      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_COMPONENT16, gl.DEPTH_ATTACHMENT);\n    } else if (useStencil) {\n      fbo._depth_rb = initRenderBuffer(gl, width, height, gl.STENCIL_INDEX, gl.STENCIL_ATTACHMENT);\n    }\n  } //Check frame buffer state\n\n\n  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    //Release all partially allocated resources\n    fbo._destroyed = true; //Release all resources\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(fbo.handle);\n    fbo.handle = null;\n\n    if (fbo.depth) {\n      fbo.depth.dispose();\n      fbo.depth = null;\n    }\n\n    if (fbo._depth_rb) {\n      gl.deleteRenderbuffer(fbo._depth_rb);\n      fbo._depth_rb = null;\n    }\n\n    for (var i = 0; i < fbo.color.length; ++i) {\n      fbo.color[i].dispose();\n      fbo.color[i] = null;\n    }\n\n    if (fbo._color_rb) {\n      gl.deleteRenderbuffer(fbo._color_rb);\n      fbo._color_rb = null;\n    }\n\n    restoreFBOState(gl, state); //Throw the frame buffer error\n\n    throwFBOError(status);\n  } //Everything ok, let's get on with life\n\n\n  restoreFBOState(gl, state);\n}\n\nfunction Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, ext) {\n  //Handle and set properties\n  this.gl = gl;\n  this._shape = [width | 0, height | 0];\n  this._destroyed = false;\n  this._ext = ext; //Allocate buffers\n\n  this.color = new Array(numColors);\n\n  for (var i = 0; i < numColors; ++i) {\n    this.color[i] = null;\n  }\n\n  this._color_rb = null;\n  this.depth = null;\n  this._depth_rb = null; //Save depth and stencil flags\n\n  this._colorType = colorType;\n  this._useDepth = useDepth;\n  this._useStencil = useStencil; //Shape vector for resizing\n\n  var parent = this;\n  var shapeVector = [width | 0, height | 0];\n  Object.defineProperties(shapeVector, {\n    0: {\n      get: function () {\n        return parent._shape[0];\n      },\n      set: function (w) {\n        return parent.width = w;\n      }\n    },\n    1: {\n      get: function () {\n        return parent._shape[1];\n      },\n      set: function (h) {\n        return parent.height = h;\n      }\n    }\n  });\n  this._shapeVector = shapeVector; //Initialize all attachments\n\n  rebuildFBO(this);\n}\n\nvar proto = Framebuffer.prototype;\n\nfunction reshapeFBO(fbo, w, h) {\n  //If fbo is invalid, just skip this\n  if (fbo._destroyed) {\n    throw new Error('gl-fbo: Can\\'t resize destroyed FBO');\n  } //Don't resize if no change in shape\n\n\n  if (fbo._shape[0] === w && fbo._shape[1] === h) {\n    return;\n  }\n\n  var gl = fbo.gl; //Check parameter ranges\n\n  var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\n  if (w < 0 || w > maxFBOSize || h < 0 || h > maxFBOSize) {\n    throw new Error('gl-fbo: Can\\'t resize FBO, invalid dimensions');\n  } //Update shape\n\n\n  fbo._shape[0] = w;\n  fbo._shape[1] = h; //Save framebuffer state\n\n  var state = saveFBOState(gl); //Resize framebuffer attachments\n\n  for (var i = 0; i < fbo.color.length; ++i) {\n    fbo.color[i].shape = fbo._shape;\n  }\n\n  if (fbo._color_rb) {\n    gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._color_rb);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, fbo._shape[0], fbo._shape[1]);\n  }\n\n  if (fbo.depth) {\n    fbo.depth.shape = fbo._shape;\n  }\n\n  if (fbo._depth_rb) {\n    gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._depth_rb);\n\n    if (fbo._useDepth && fbo._useStencil) {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, fbo._shape[0], fbo._shape[1]);\n    } else if (fbo._useDepth) {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, fbo._shape[0], fbo._shape[1]);\n    } else if (fbo._useStencil) {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX, fbo._shape[0], fbo._shape[1]);\n    }\n  } //Check FBO status after resize, if something broke then die in a fire\n\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.handle);\n  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    fbo.dispose();\n    restoreFBOState(gl, state);\n    throwFBOError(status);\n  } //Restore framebuffer state\n\n\n  restoreFBOState(gl, state);\n}\n\nObject.defineProperties(proto, {\n  'shape': {\n    get: function () {\n      if (this._destroyed) {\n        return [0, 0];\n      }\n\n      return this._shapeVector;\n    },\n    set: function (x) {\n      if (!Array.isArray(x)) {\n        x = [x | 0, x | 0];\n      }\n\n      if (x.length !== 2) {\n        throw new Error('gl-fbo: Shape vector must be length 2');\n      }\n\n      var w = x[0] | 0;\n      var h = x[1] | 0;\n      reshapeFBO(this, w, h);\n      return [w, h];\n    },\n    enumerable: false\n  },\n  'width': {\n    get: function () {\n      if (this._destroyed) {\n        return 0;\n      }\n\n      return this._shape[0];\n    },\n    set: function (w) {\n      w = w | 0;\n      reshapeFBO(this, w, this._shape[1]);\n      return w;\n    },\n    enumerable: false\n  },\n  'height': {\n    get: function () {\n      if (this._destroyed) {\n        return 0;\n      }\n\n      return this._shape[1];\n    },\n    set: function (h) {\n      h = h | 0;\n      reshapeFBO(this, this._shape[0], h);\n      return h;\n    },\n    enumerable: false\n  }\n});\n\nproto.bind = function () {\n  if (this._destroyed) {\n    return;\n  }\n\n  var gl = this.gl;\n  gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);\n  gl.viewport(0, 0, this._shape[0], this._shape[1]);\n};\n\nproto.dispose = function () {\n  if (this._destroyed) {\n    return;\n  }\n\n  this._destroyed = true;\n  var gl = this.gl;\n  gl.deleteFramebuffer(this.handle);\n  this.handle = null;\n\n  if (this.depth) {\n    this.depth.dispose();\n    this.depth = null;\n  }\n\n  if (this._depth_rb) {\n    gl.deleteRenderbuffer(this._depth_rb);\n    this._depth_rb = null;\n  }\n\n  for (var i = 0; i < this.color.length; ++i) {\n    this.color[i].dispose();\n    this.color[i] = null;\n  }\n\n  if (this._color_rb) {\n    gl.deleteRenderbuffer(this._color_rb);\n    this._color_rb = null;\n  }\n};\n\nfunction createFBO(gl, width, height, options) {\n  //Update frame buffer error code values\n  if (!FRAMEBUFFER_UNSUPPORTED) {\n    FRAMEBUFFER_UNSUPPORTED = gl.FRAMEBUFFER_UNSUPPORTED;\n    FRAMEBUFFER_INCOMPLETE_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\n    FRAMEBUFFER_INCOMPLETE_DIMENSIONS = gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\n    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\n  } //Lazily initialize color attachment arrays\n\n\n  var WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');\n\n  if (!colorAttachmentArrays && WEBGL_draw_buffers) {\n    lazyInitColorAttachments(gl, WEBGL_draw_buffers);\n  } //Special case: Can accept an array as argument\n\n\n  if (Array.isArray(width)) {\n    options = height;\n    height = width[1] | 0;\n    width = width[0] | 0;\n  }\n\n  if (typeof width !== 'number') {\n    throw new Error('gl-fbo: Missing shape parameter');\n  } //Validate width/height properties\n\n\n  var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\n  if (width < 0 || width > maxFBOSize || height < 0 || height > maxFBOSize) {\n    throw new Error('gl-fbo: Parameters are too large for FBO');\n  } //Handle each option type\n\n\n  options = options || {}; //Figure out number of color buffers to use\n\n  var numColors = 1;\n\n  if ('color' in options) {\n    numColors = Math.max(options.color | 0, 0);\n\n    if (numColors < 0) {\n      throw new Error('gl-fbo: Must specify a nonnegative number of colors');\n    }\n\n    if (numColors > 1) {\n      //Check if multiple render targets supported\n      if (!WEBGL_draw_buffers) {\n        throw new Error('gl-fbo: Multiple draw buffer extension not supported');\n      } else if (numColors > gl.getParameter(WEBGL_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL)) {\n        throw new Error('gl-fbo: Context does not support ' + numColors + ' draw buffers');\n      }\n    }\n  } //Determine whether to use floating point textures\n\n\n  var colorType = gl.UNSIGNED_BYTE;\n  var OES_texture_float = gl.getExtension('OES_texture_float');\n\n  if (options.float && numColors > 0) {\n    if (!OES_texture_float) {\n      throw new Error('gl-fbo: Context does not support floating point textures');\n    }\n\n    colorType = gl.FLOAT;\n  } else if (options.preferFloat && numColors > 0) {\n    if (OES_texture_float) {\n      colorType = gl.FLOAT;\n    }\n  } //Check if we should use depth buffer\n\n\n  var useDepth = true;\n\n  if ('depth' in options) {\n    useDepth = !!options.depth;\n  } //Check if we should use a stencil buffer\n\n\n  var useStencil = false;\n\n  if ('stencil' in options) {\n    useStencil = !!options.stencil;\n  }\n\n  return new Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, WEBGL_draw_buffers);\n}","map":null,"metadata":{},"sourceType":"script"}