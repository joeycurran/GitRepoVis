{"ast":null,"code":"'use strict';\n\nmodule.exports = createLines;\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createShader = require('./shaders').line;\n\nvar MAJOR_AXIS = [0, 0, 0];\nvar MINOR_AXIS = [0, 0, 0];\nvar SCREEN_AXIS = [0, 0, 0];\nvar OFFSET_VEC = [0, 0, 0];\nvar SHAPE = [1, 1];\n\nfunction zeroVec(a) {\n  a[0] = a[1] = a[2] = 0;\n  return a;\n}\n\nfunction copyVec(a, b) {\n  a[0] = b[0];\n  a[1] = b[1];\n  a[2] = b[2];\n  return a;\n}\n\nfunction Lines(gl, vertBuffer, vao, shader, tickCount, tickOffset, gridCount, gridOffset) {\n  this.gl = gl;\n  this.vertBuffer = vertBuffer;\n  this.vao = vao;\n  this.shader = shader;\n  this.tickCount = tickCount;\n  this.tickOffset = tickOffset;\n  this.gridCount = gridCount;\n  this.gridOffset = gridOffset;\n}\n\nvar proto = Lines.prototype;\n\nproto.bind = function (model, view, projection) {\n  this.shader.bind();\n  this.shader.uniforms.model = model;\n  this.shader.uniforms.view = view;\n  this.shader.uniforms.projection = projection;\n  SHAPE[0] = this.gl.drawingBufferWidth;\n  SHAPE[1] = this.gl.drawingBufferHeight;\n  this.shader.uniforms.screenShape = SHAPE;\n  this.vao.bind();\n};\n\nproto.unbind = function () {\n  this.vao.unbind();\n};\n\nproto.drawAxisLine = function (j, bounds, offset, color, lineWidth) {\n  var minorAxis = zeroVec(MINOR_AXIS);\n  this.shader.uniforms.majorAxis = MINOR_AXIS;\n  minorAxis[j] = bounds[1][j] - bounds[0][j];\n  this.shader.uniforms.minorAxis = minorAxis;\n  var noffset = copyVec(OFFSET_VEC, offset);\n  noffset[j] += bounds[0][j];\n  this.shader.uniforms.offset = noffset;\n  this.shader.uniforms.lineWidth = lineWidth;\n  this.shader.uniforms.color = color;\n  var screenAxis = zeroVec(SCREEN_AXIS);\n  screenAxis[(j + 2) % 3] = 1;\n  this.shader.uniforms.screenAxis = screenAxis;\n  this.vao.draw(this.gl.TRIANGLES, 6);\n  var screenAxis = zeroVec(SCREEN_AXIS);\n  screenAxis[(j + 1) % 3] = 1;\n  this.shader.uniforms.screenAxis = screenAxis;\n  this.vao.draw(this.gl.TRIANGLES, 6);\n};\n\nproto.drawAxisTicks = function (j, offset, minorAxis, color, lineWidth) {\n  if (!this.tickCount[j]) {\n    return;\n  }\n\n  var majorAxis = zeroVec(MAJOR_AXIS);\n  majorAxis[j] = 1;\n  this.shader.uniforms.majorAxis = majorAxis;\n  this.shader.uniforms.offset = offset;\n  this.shader.uniforms.minorAxis = minorAxis;\n  this.shader.uniforms.color = color;\n  this.shader.uniforms.lineWidth = lineWidth;\n  var screenAxis = zeroVec(SCREEN_AXIS);\n  screenAxis[j] = 1;\n  this.shader.uniforms.screenAxis = screenAxis;\n  this.vao.draw(this.gl.TRIANGLES, this.tickCount[j], this.tickOffset[j]);\n};\n\nproto.drawGrid = function (i, j, bounds, offset, color, lineWidth) {\n  if (!this.gridCount[i]) {\n    return;\n  }\n\n  var minorAxis = zeroVec(MINOR_AXIS);\n  minorAxis[j] = bounds[1][j] - bounds[0][j];\n  this.shader.uniforms.minorAxis = minorAxis;\n  var noffset = copyVec(OFFSET_VEC, offset);\n  noffset[j] += bounds[0][j];\n  this.shader.uniforms.offset = noffset;\n  var majorAxis = zeroVec(MAJOR_AXIS);\n  majorAxis[i] = 1;\n  this.shader.uniforms.majorAxis = majorAxis;\n  var screenAxis = zeroVec(SCREEN_AXIS);\n  screenAxis[i] = 1;\n  this.shader.uniforms.screenAxis = screenAxis;\n  this.shader.uniforms.lineWidth = lineWidth;\n  this.shader.uniforms.color = color;\n  this.vao.draw(this.gl.TRIANGLES, this.gridCount[i], this.gridOffset[i]);\n};\n\nproto.drawZero = function (j, i, bounds, offset, color, lineWidth) {\n  var minorAxis = zeroVec(MINOR_AXIS);\n  this.shader.uniforms.majorAxis = minorAxis;\n  minorAxis[j] = bounds[1][j] - bounds[0][j];\n  this.shader.uniforms.minorAxis = minorAxis;\n  var noffset = copyVec(OFFSET_VEC, offset);\n  noffset[j] += bounds[0][j];\n  this.shader.uniforms.offset = noffset;\n  var screenAxis = zeroVec(SCREEN_AXIS);\n  screenAxis[i] = 1;\n  this.shader.uniforms.screenAxis = screenAxis;\n  this.shader.uniforms.lineWidth = lineWidth;\n  this.shader.uniforms.color = color;\n  this.vao.draw(this.gl.TRIANGLES, 6);\n};\n\nproto.dispose = function () {\n  this.vao.dispose();\n  this.vertBuffer.dispose();\n  this.shader.dispose();\n};\n\nfunction createLines(gl, bounds, ticks) {\n  var vertices = [];\n  var tickOffset = [0, 0, 0];\n  var tickCount = [0, 0, 0]; //Create grid lines for each axis/direction\n\n  var gridOffset = [0, 0, 0];\n  var gridCount = [0, 0, 0]; //Add zero line\n\n  vertices.push(0, 0, 1, 0, 1, 1, 0, 0, -1, 0, 0, -1, 0, 1, 1, 0, 1, -1);\n\n  for (var i = 0; i < 3; ++i) {\n    //Axis tick marks\n    var start = vertices.length / 3 | 0;\n\n    for (var j = 0; j < ticks[i].length; ++j) {\n      var x = +ticks[i][j].x;\n      vertices.push(x, 0, 1, x, 1, 1, x, 0, -1, x, 0, -1, x, 1, 1, x, 1, -1);\n    }\n\n    var end = vertices.length / 3 | 0;\n    tickOffset[i] = start;\n    tickCount[i] = end - start; //Grid lines\n\n    var start = vertices.length / 3 | 0;\n\n    for (var k = 0; k < ticks[i].length; ++k) {\n      var x = +ticks[i][k].x;\n      vertices.push(x, 0, 1, x, 1, 1, x, 0, -1, x, 0, -1, x, 1, 1, x, 1, -1);\n    }\n\n    var end = vertices.length / 3 | 0;\n    gridOffset[i] = start;\n    gridCount[i] = end - start;\n  } //Create cube VAO\n\n\n  var vertBuf = createBuffer(gl, new Float32Array(vertices));\n  var vao = createVAO(gl, [{\n    \"buffer\": vertBuf,\n    \"type\": gl.FLOAT,\n    \"size\": 3,\n    \"stride\": 0,\n    \"offset\": 0\n  }]);\n  var shader = createShader(gl);\n  shader.attributes.position.location = 0;\n  return new Lines(gl, vertBuf, vao, shader, tickCount, tickOffset, gridCount, gridOffset);\n}","map":null,"metadata":{},"sourceType":"script"}