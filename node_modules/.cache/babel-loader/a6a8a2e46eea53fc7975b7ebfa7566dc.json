{"ast":null,"code":"\"use strict\";\n\"use restrict\";\n\nvar bits = require(\"bit-twiddle\"),\n    UnionFind = require(\"union-find\"); //Returns the dimension of a cell complex\n\n\nfunction dimension(cells) {\n  var d = 0,\n      max = Math.max;\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    d = max(d, cells[i].length);\n  }\n\n  return d - 1;\n}\n\nexports.dimension = dimension; //Counts the number of vertices in faces\n\nfunction countVertices(cells) {\n  var vc = -1,\n      max = Math.max;\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, jl = c.length; j < jl; ++j) {\n      vc = max(vc, c[j]);\n    }\n  }\n\n  return vc + 1;\n}\n\nexports.countVertices = countVertices; //Returns a deep copy of cells\n\nfunction cloneCells(cells) {\n  var ncells = new Array(cells.length);\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    ncells[i] = cells[i].slice(0);\n  }\n\n  return ncells;\n}\n\nexports.cloneCells = cloneCells; //Ranks a pair of cells up to permutation\n\nfunction compareCells(a, b) {\n  var n = a.length,\n      t = a.length - b.length,\n      min = Math.min;\n\n  if (t) {\n    return t;\n  }\n\n  switch (n) {\n    case 0:\n      return 0;\n\n    case 1:\n      return a[0] - b[0];\n\n    case 2:\n      var d = a[0] + a[1] - b[0] - b[1];\n\n      if (d) {\n        return d;\n      }\n\n      return min(a[0], a[1]) - min(b[0], b[1]);\n\n    case 3:\n      var l1 = a[0] + a[1],\n          m1 = b[0] + b[1];\n      d = l1 + a[2] - (m1 + b[2]);\n\n      if (d) {\n        return d;\n      }\n\n      var l0 = min(a[0], a[1]),\n          m0 = min(b[0], b[1]),\n          d = min(l0, a[2]) - min(m0, b[2]);\n\n      if (d) {\n        return d;\n      }\n\n      return min(l0 + a[2], l1) - min(m0 + b[2], m1);\n    //TODO: Maybe optimize n=4 as well?\n\n    default:\n      var as = a.slice(0);\n      as.sort();\n      var bs = b.slice(0);\n      bs.sort();\n\n      for (var i = 0; i < n; ++i) {\n        t = as[i] - bs[i];\n\n        if (t) {\n          return t;\n        }\n      }\n\n      return 0;\n  }\n}\n\nexports.compareCells = compareCells;\n\nfunction compareZipped(a, b) {\n  return compareCells(a[0], b[0]);\n} //Puts a cell complex into normal order for the purposes of findCell queries\n\n\nfunction normalize(cells, attr) {\n  if (attr) {\n    var len = cells.length;\n    var zipped = new Array(len);\n\n    for (var i = 0; i < len; ++i) {\n      zipped[i] = [cells[i], attr[i]];\n    }\n\n    zipped.sort(compareZipped);\n\n    for (var i = 0; i < len; ++i) {\n      cells[i] = zipped[i][0];\n      attr[i] = zipped[i][1];\n    }\n\n    return cells;\n  } else {\n    cells.sort(compareCells);\n    return cells;\n  }\n}\n\nexports.normalize = normalize; //Removes all duplicate cells in the complex\n\nfunction unique(cells) {\n  if (cells.length === 0) {\n    return [];\n  }\n\n  var ptr = 1,\n      len = cells.length;\n\n  for (var i = 1; i < len; ++i) {\n    var a = cells[i];\n\n    if (compareCells(a, cells[i - 1])) {\n      if (i === ptr) {\n        ptr++;\n        continue;\n      }\n\n      cells[ptr++] = a;\n    }\n  }\n\n  cells.length = ptr;\n  return cells;\n}\n\nexports.unique = unique; //Finds a cell in a normalized cell complex\n\nfunction findCell(cells, c) {\n  var lo = 0,\n      hi = cells.length - 1,\n      r = -1;\n\n  while (lo <= hi) {\n    var mid = lo + hi >> 1,\n        s = compareCells(cells[mid], c);\n\n    if (s <= 0) {\n      if (s === 0) {\n        r = mid;\n      }\n\n      lo = mid + 1;\n    } else if (s > 0) {\n      hi = mid - 1;\n    }\n  }\n\n  return r;\n}\n\nexports.findCell = findCell; //Builds an index for an n-cell.  This is more general than dual, but less efficient\n\nfunction incidence(from_cells, to_cells) {\n  var index = new Array(from_cells.length);\n\n  for (var i = 0, il = index.length; i < il; ++i) {\n    index[i] = [];\n  }\n\n  var b = [];\n\n  for (var i = 0, n = to_cells.length; i < n; ++i) {\n    var c = to_cells[i];\n    var cl = c.length;\n\n    for (var k = 1, kn = 1 << cl; k < kn; ++k) {\n      b.length = bits.popCount(k);\n      var l = 0;\n\n      for (var j = 0; j < cl; ++j) {\n        if (k & 1 << j) {\n          b[l++] = c[j];\n        }\n      }\n\n      var idx = findCell(from_cells, b);\n\n      if (idx < 0) {\n        continue;\n      }\n\n      while (true) {\n        index[idx++].push(i);\n\n        if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {\n          break;\n        }\n      }\n    }\n  }\n\n  return index;\n}\n\nexports.incidence = incidence; //Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices\n\nfunction dual(cells, vertex_count) {\n  if (!vertex_count) {\n    return incidence(unique(skeleton(cells, 0)), cells, 0);\n  }\n\n  var res = new Array(vertex_count);\n\n  for (var i = 0; i < vertex_count; ++i) {\n    res[i] = [];\n  }\n\n  for (var i = 0, len = cells.length; i < len; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, cl = c.length; j < cl; ++j) {\n      res[c[j]].push(i);\n    }\n  }\n\n  return res;\n}\n\nexports.dual = dual; //Enumerates all cells in the complex\n\nfunction explode(cells) {\n  var result = [];\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i],\n        cl = c.length | 0;\n\n    for (var j = 1, jl = 1 << cl; j < jl; ++j) {\n      var b = [];\n\n      for (var k = 0; k < cl; ++k) {\n        if (j >>> k & 1) {\n          b.push(c[k]);\n        }\n      }\n\n      result.push(b);\n    }\n  }\n\n  return normalize(result);\n}\n\nexports.explode = explode; //Enumerates all of the n-cells of a cell complex\n\nfunction skeleton(cells, n) {\n  if (n < 0) {\n    return [];\n  }\n\n  var result = [],\n      k0 = (1 << n + 1) - 1;\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {\n      var b = new Array(n + 1),\n          l = 0;\n\n      for (var j = 0; j < c.length; ++j) {\n        if (k & 1 << j) {\n          b[l++] = c[j];\n        }\n      }\n\n      result.push(b);\n    }\n  }\n\n  return normalize(result);\n}\n\nexports.skeleton = skeleton; //Computes the boundary of all cells, does not remove duplicates\n\nfunction boundary(cells) {\n  var res = [];\n\n  for (var i = 0, il = cells.length; i < il; ++i) {\n    var c = cells[i];\n\n    for (var j = 0, cl = c.length; j < cl; ++j) {\n      var b = new Array(c.length - 1);\n\n      for (var k = 0, l = 0; k < cl; ++k) {\n        if (k !== j) {\n          b[l++] = c[k];\n        }\n      }\n\n      res.push(b);\n    }\n  }\n\n  return normalize(res);\n}\n\nexports.boundary = boundary; //Computes connected components for a dense cell complex\n\nfunction connectedComponents_dense(cells, vertex_count) {\n  var labels = new UnionFind(vertex_count);\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      for (var k = j + 1; k < c.length; ++k) {\n        labels.link(c[j], c[k]);\n      }\n    }\n  }\n\n  var components = [],\n      component_labels = labels.ranks;\n\n  for (var i = 0; i < component_labels.length; ++i) {\n    component_labels[i] = -1;\n  }\n\n  for (var i = 0; i < cells.length; ++i) {\n    var l = labels.find(cells[i][0]);\n\n    if (component_labels[l] < 0) {\n      component_labels[l] = components.length;\n      components.push([cells[i].slice(0)]);\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0));\n    }\n  }\n\n  return components;\n} //Computes connected components for a sparse graph\n\n\nfunction connectedComponents_sparse(cells) {\n  var vertices = unique(normalize(skeleton(cells, 0))),\n      labels = new UnionFind(vertices.length);\n\n  for (var i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      var vj = findCell(vertices, [c[j]]);\n\n      for (var k = j + 1; k < c.length; ++k) {\n        labels.link(vj, findCell(vertices, [c[k]]));\n      }\n    }\n  }\n\n  var components = [],\n      component_labels = labels.ranks;\n\n  for (var i = 0; i < component_labels.length; ++i) {\n    component_labels[i] = -1;\n  }\n\n  for (var i = 0; i < cells.length; ++i) {\n    var l = labels.find(findCell(vertices, [cells[i][0]]));\n\n    if (component_labels[l] < 0) {\n      component_labels[l] = components.length;\n      components.push([cells[i].slice(0)]);\n    } else {\n      components[component_labels[l]].push(cells[i].slice(0));\n    }\n  }\n\n  return components;\n} //Computes connected components for a cell complex\n\n\nfunction connectedComponents(cells, vertex_count) {\n  if (vertex_count) {\n    return connectedComponents_dense(cells, vertex_count);\n  }\n\n  return connectedComponents_sparse(cells);\n}\n\nexports.connectedComponents = connectedComponents;","map":null,"metadata":{},"sourceType":"script"}