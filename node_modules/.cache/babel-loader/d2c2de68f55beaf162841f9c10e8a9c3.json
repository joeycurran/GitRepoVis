{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nvar vec4 = require('gl-vec4');\n\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\nvar streamToTube = function (stream, maxDivergence, minDistance, maxNorm) {\n  var points = stream.points;\n  var velocities = stream.velocities;\n  var divergences = stream.divergences;\n  var verts = [];\n  var faces = [];\n  var vectors = [];\n  var previousVerts = [];\n  var currentVerts = [];\n  var intensities = [];\n  var previousIntensity = 0;\n  var currentIntensity = 0;\n  var currentVector = vec4.create();\n  var previousVector = vec4.create();\n  var facets = 8;\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    var fwd = velocities[i];\n    var r = divergences[i];\n\n    if (maxDivergence === 0) {\n      r = minDistance * 0.05;\n    }\n\n    currentIntensity = vec3.length(fwd) / maxNorm;\n    currentVector = vec4.create();\n    vec3.copy(currentVector, fwd);\n    currentVector[3] = r;\n\n    for (var a = 0; a < facets; a++) {\n      currentVerts[a] = [p[0], p[1], p[2], a];\n    }\n\n    if (previousVerts.length > 0) {\n      for (var a = 0; a < facets; a++) {\n        var a1 = (a + 1) % facets;\n        verts.push(previousVerts[a], currentVerts[a], currentVerts[a1], currentVerts[a1], previousVerts[a1], previousVerts[a]);\n        vectors.push(previousVector, currentVector, currentVector, currentVector, previousVector, previousVector);\n        intensities.push(previousIntensity, currentIntensity, currentIntensity, currentIntensity, previousIntensity, previousIntensity);\n        var len = verts.length;\n        faces.push([len - 6, len - 5, len - 4], [len - 3, len - 2, len - 1]);\n      }\n    }\n\n    var tmp1 = previousVerts;\n    previousVerts = currentVerts;\n    currentVerts = tmp1;\n    var tmp2 = previousVector;\n    previousVector = currentVector;\n    currentVector = tmp2;\n    var tmp3 = previousIntensity;\n    previousIntensity = currentIntensity;\n    currentIntensity = tmp3;\n  }\n\n  return {\n    positions: verts,\n    cells: faces,\n    vectors: vectors,\n    vertexIntensity: intensities\n  };\n};\n\nvar createTubes = function (streams, colormap, maxDivergence, minDistance) {\n  var maxNorm = 0;\n\n  for (var i = 0; i < streams.length; i++) {\n    var velocities = streams[i].velocities;\n\n    for (var j = 0; j < velocities.length; j++) {\n      maxNorm = Math.max(maxNorm, vec3.length(velocities[j]));\n    }\n  }\n\n  var tubes = streams.map(function (s) {\n    return streamToTube(s, maxDivergence, minDistance, maxNorm);\n  });\n  var positions = [];\n  var cells = [];\n  var vectors = [];\n  var vertexIntensity = [];\n\n  for (var i = 0; i < tubes.length; i++) {\n    var tube = tubes[i];\n    var offset = positions.length;\n    positions = positions.concat(tube.positions);\n    vectors = vectors.concat(tube.vectors);\n    vertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n\n    for (var j = 0; j < tube.cells.length; j++) {\n      var cell = tube.cells[j];\n      var newCell = [];\n      cells.push(newCell);\n\n      for (var k = 0; k < cell.length; k++) {\n        newCell.push(cell[k] + offset);\n      }\n    }\n  }\n\n  return {\n    positions: positions,\n    cells: cells,\n    vectors: vectors,\n    vertexIntensity: vertexIntensity,\n    colormap: colormap\n  };\n};\n\nvar findLastSmallerIndex = function (points, v) {\n  var len = points.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    var p = points[i];\n    if (p === v) return i;else if (p > v) return i - 1;\n  }\n\n  return i;\n};\n\nvar clamp = function (v, min, max) {\n  return v < min ? min : v > max ? max : v;\n};\n\nvar sampleMeshgrid = function (point, vectorField, gridInfo) {\n  var vectors = vectorField.vectors;\n  var meshgrid = vectorField.meshgrid;\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = meshgrid[0].length;\n  var h = meshgrid[1].length;\n  var d = meshgrid[2].length; // Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n  // The nearest smaller value index for x is the index x0 such that\n  // meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\n  var x0 = findLastSmallerIndex(meshgrid[0], x);\n  var y0 = findLastSmallerIndex(meshgrid[1], y);\n  var z0 = findLastSmallerIndex(meshgrid[2], z); // Get the nearest larger meshgrid value indices.\n  // From the above \"nearest smaller value\", we know that\n  //   meshgrid[0][x0] < x\n  //   meshgrid[0][x0+1] >= x\n\n  var x1 = x0 + 1;\n  var y1 = y0 + 1;\n  var z1 = z0 + 1;\n  x0 = clamp(x0, 0, w - 1);\n  x1 = clamp(x1, 0, w - 1);\n  y0 = clamp(y0, 0, h - 1);\n  y1 = clamp(y1, 0, h - 1);\n  z0 = clamp(z0, 0, d - 1);\n  z1 = clamp(z1, 0, d - 1); // Reject points outside the meshgrid, return a zero vector.\n\n  if (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w - 1 || y1 > h - 1 || z1 > d - 1) {\n    return vec3.create();\n  } // Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\n\n  var mX0 = meshgrid[0][x0];\n  var mX1 = meshgrid[0][x1];\n  var mY0 = meshgrid[1][y0];\n  var mY1 = meshgrid[1][y1];\n  var mZ0 = meshgrid[2][z0];\n  var mZ1 = meshgrid[2][z1];\n  var xf = (x - mX0) / (mX1 - mX0);\n  var yf = (y - mY0) / (mY1 - mY0);\n  var zf = (z - mZ0) / (mZ1 - mZ0);\n  if (!isFinite(xf)) xf = 0.5;\n  if (!isFinite(yf)) yf = 0.5;\n  if (!isFinite(zf)) zf = 0.5;\n  var x0off;\n  var x1off;\n  var y0off;\n  var y1off;\n  var z0off;\n  var z1off;\n\n  if (gridInfo.reversedX) {\n    x0 = w - 1 - x0;\n    x1 = w - 1 - x1;\n  }\n\n  if (gridInfo.reversedY) {\n    y0 = h - 1 - y0;\n    y1 = h - 1 - y1;\n  }\n\n  if (gridInfo.reversedZ) {\n    z0 = d - 1 - z0;\n    z1 = d - 1 - z1;\n  }\n\n  switch (gridInfo.filled) {\n    case 5:\n      // 'zyx'\n      z0off = z0;\n      z1off = z1;\n      y0off = y0 * d;\n      y1off = y1 * d;\n      x0off = x0 * d * h;\n      x1off = x1 * d * h;\n      break;\n\n    case 4:\n      // 'zxy'\n      z0off = z0;\n      z1off = z1;\n      x0off = x0 * d;\n      x1off = x1 * d;\n      y0off = y0 * d * w;\n      y1off = y1 * d * w;\n      break;\n\n    case 3:\n      // 'yzx'\n      y0off = y0;\n      y1off = y1;\n      z0off = z0 * h;\n      z1off = z1 * h;\n      x0off = x0 * h * d;\n      x1off = x1 * h * d;\n      break;\n\n    case 2:\n      // 'yxz'\n      y0off = y0;\n      y1off = y1;\n      x0off = x0 * h;\n      x1off = x1 * h;\n      z0off = z0 * h * w;\n      z1off = z1 * h * w;\n      break;\n\n    case 1:\n      // 'xzy'\n      x0off = x0;\n      x1off = x1;\n      z0off = z0 * w;\n      z1off = z1 * w;\n      y0off = y0 * w * d;\n      y1off = y1 * w * d;\n      break;\n\n    default:\n      // case 0: // 'xyz'\n      x0off = x0;\n      x1off = x1;\n      y0off = y0 * w;\n      y1off = y1 * w;\n      z0off = z0 * w * h;\n      z1off = z1 * w * h;\n      break;\n  } // Sample data vectors around the (x,y,z) point.\n\n\n  var v000 = vectors[x0off + y0off + z0off];\n  var v001 = vectors[x0off + y0off + z1off];\n  var v010 = vectors[x0off + y1off + z0off];\n  var v011 = vectors[x0off + y1off + z1off];\n  var v100 = vectors[x1off + y0off + z0off];\n  var v101 = vectors[x1off + y0off + z1off];\n  var v110 = vectors[x1off + y1off + z0off];\n  var v111 = vectors[x1off + y1off + z1off];\n  var c00 = vec3.create();\n  var c01 = vec3.create();\n  var c10 = vec3.create();\n  var c11 = vec3.create();\n  vec3.lerp(c00, v000, v100, xf);\n  vec3.lerp(c01, v001, v101, xf);\n  vec3.lerp(c10, v010, v110, xf);\n  vec3.lerp(c11, v011, v111, xf);\n  var c0 = vec3.create();\n  var c1 = vec3.create();\n  vec3.lerp(c0, c00, c10, yf);\n  vec3.lerp(c1, c01, c11, yf);\n  var c = vec3.create();\n  vec3.lerp(c, c0, c1, zf);\n  return c;\n};\n\nvar vabs = function (dst, v) {\n  var x = v[0];\n  var y = v[1];\n  var z = v[2];\n  dst[0] = x < 0 ? -x : x;\n  dst[1] = y < 0 ? -y : y;\n  dst[2] = z < 0 ? -z : z;\n  return dst;\n};\n\nvar findMinSeparation = function (xs) {\n  var minSeparation = Infinity;\n  xs.sort(function (a, b) {\n    return a - b;\n  });\n  var len = xs.length;\n\n  for (var i = 1; i < len; i++) {\n    var d = Math.abs(xs[i] - xs[i - 1]);\n\n    if (d < minSeparation) {\n      minSeparation = d;\n    }\n  }\n\n  return minSeparation;\n}; // Finds the minimum per-component distance in positions.\n//\n\n\nvar calculateMinPositionDistance = function (positions) {\n  var xs = [],\n      ys = [],\n      zs = [];\n  var xi = {},\n      yi = {},\n      zi = {};\n  var len = positions.length;\n\n  for (var i = 0; i < len; i++) {\n    var p = positions[i];\n    var x = p[0],\n        y = p[1],\n        z = p[2]; // Split the positions array into arrays of unique component values.\n    //\n    // Why go through the trouble of using a uniqueness hash table vs\n    // sort and uniq:\n    //\n    // Suppose you've got a million positions in a 100x100x100 grid.\n    //\n    // Using a uniqueness hash table, you're doing 1M array reads,\n    // 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n    // sorting three 100-element arrays and iterating over them.\n    // Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n    //          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n    //          =~ 15M\n    //\n    // Sort and uniq solution would do 1M array reads, 3M array inserts,\n    // sort three 1M-element arrays and iterate over them.\n    // Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n    //          1M + 3M + 41.4M + 3M\n    //          =~ 48.4M\n    //\n    // Guessing that a hard-coded sort & uniq would be faster due to not having\n    // to run a hashing function on everything. More memory usage though\n    // (bunch of small hash tables vs. duplicating the input array.)\n    //\n    // In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n    // maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n    // Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n    //\n    // ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n    //\n\n    if (!xi[x]) {\n      xs.push(x);\n      xi[x] = true;\n    }\n\n    if (!yi[y]) {\n      ys.push(y);\n      yi[y] = true;\n    }\n\n    if (!zi[z]) {\n      zs.push(z);\n      zi[z] = true;\n    }\n  }\n\n  var xSep = findMinSeparation(xs);\n  var ySep = findMinSeparation(ys);\n  var zSep = findMinSeparation(zs);\n  var minSeparation = Math.min(xSep, ySep, zSep);\n  return isFinite(minSeparation) ? minSeparation : 1;\n};\n\nmodule.exports = function (vectorField, bounds) {\n  var positions = vectorField.startingPositions;\n  var maxLength = vectorField.maxLength || 1000;\n  var tubeSize = vectorField.tubeSize || 1;\n  var absoluteTubeSize = vectorField.absoluteTubeSize;\n  var gridFill = vectorField.gridFill || '+x+y+z';\n  var gridInfo = {};\n\n  if (gridFill.indexOf('-x') !== -1) {\n    gridInfo.reversedX = true;\n  }\n\n  if (gridFill.indexOf('-y') !== -1) {\n    gridInfo.reversedY = true;\n  }\n\n  if (gridFill.indexOf('-z') !== -1) {\n    gridInfo.reversedZ = true;\n  }\n\n  gridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n  var getVelocity = vectorField.getVelocity || function (p) {\n    return sampleMeshgrid(p, vectorField, gridInfo);\n  };\n\n  var getDivergence = vectorField.getDivergence || function (p, v0) {\n    var dp = vec3.create();\n    var e = 0.0001;\n    vec3.add(dp, p, [e, 0, 0]);\n    var vx = getVelocity(dp);\n    vec3.subtract(vx, vx, v0);\n    vec3.scale(vx, vx, 1 / e);\n    vec3.add(dp, p, [0, e, 0]);\n    var vy = getVelocity(dp);\n    vec3.subtract(vy, vy, v0);\n    vec3.scale(vy, vy, 1 / e);\n    vec3.add(dp, p, [0, 0, e]);\n    var vz = getVelocity(dp);\n    vec3.subtract(vz, vz, v0);\n    vec3.scale(vz, vz, 1 / e);\n    vec3.add(dp, vx, vy);\n    vec3.add(dp, dp, vz);\n    return dp;\n  };\n\n  var streams = [];\n  var minX = bounds[0][0],\n      minY = bounds[0][1],\n      minZ = bounds[0][2];\n  var maxX = bounds[1][0],\n      maxY = bounds[1][1],\n      maxZ = bounds[1][2];\n\n  var inBounds = function (p) {\n    var x = p[0];\n    var y = p[1];\n    var z = p[2];\n    return !(x < minX || x > maxX || y < minY || y > maxY || z < minZ || z > maxZ);\n  };\n\n  var boundsSize = vec3.distance(bounds[0], bounds[1]);\n  var maxStepSize = 10 * boundsSize / maxLength;\n  var maxStepSizeSq = maxStepSize * maxStepSize;\n  var minDistance = 1;\n  var maxDivergence = 0; // For component-wise divergence vec3.create();\n  // In case we need to do component-wise divergence visualization\n  // var tmp = vec3.create();\n\n  var len = positions.length;\n\n  if (len > 1) {\n    minDistance = calculateMinPositionDistance(positions);\n  }\n\n  for (var i = 0; i < len; i++) {\n    var p = vec3.create();\n    vec3.copy(p, positions[i]);\n    var stream = [p];\n    var velocities = [];\n    var v = getVelocity(p);\n    var op = p;\n    velocities.push(v);\n    var divergences = [];\n    var dv = getDivergence(p, v);\n    var dvLength = vec3.length(dv);\n\n    if (isFinite(dvLength) && dvLength > maxDivergence) {\n      maxDivergence = dvLength;\n    } // In case we need to do component-wise divergence visualization\n    // vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n    divergences.push(dvLength);\n    streams.push({\n      points: stream,\n      velocities: velocities,\n      divergences: divergences\n    });\n    var j = 0;\n\n    while (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n      j++;\n      var np = vec3.clone(v);\n      var sqLen = vec3.squaredLength(np);\n\n      if (sqLen === 0) {\n        break;\n      } else if (sqLen > maxStepSizeSq) {\n        vec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n      }\n\n      vec3.add(np, np, p);\n      v = getVelocity(np);\n\n      if (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n        stream.push(np);\n        op = np;\n        velocities.push(v);\n        var dv = getDivergence(np, v);\n        var dvLength = vec3.length(dv);\n\n        if (isFinite(dvLength) && dvLength > maxDivergence) {\n          maxDivergence = dvLength;\n        } // In case we need to do component-wise divergence visualization\n        //vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n        divergences.push(dvLength);\n      }\n\n      p = np;\n    }\n  }\n\n  var tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n\n  if (absoluteTubeSize) {\n    tubes.tubeScale = absoluteTubeSize;\n  } else {\n    // Avoid division by zero.\n    if (maxDivergence === 0) {\n      maxDivergence = 1;\n    }\n\n    tubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n  }\n\n  return tubes;\n};\n\nvar shaders = require('./lib/shaders');\n\nvar createMesh = require('gl-cone3d').createMesh;\n\nmodule.exports.createTubeMesh = function (gl, params) {\n  return createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'streamtube'\n  });\n};","map":null,"metadata":{},"sourceType":"script"}