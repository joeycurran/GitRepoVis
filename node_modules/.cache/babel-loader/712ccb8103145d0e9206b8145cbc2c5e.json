{"ast":null,"code":"'use strict';\n\nvar createShader = require('gl-shader');\n\nvar createBuffer = require('gl-buffer');\n\nvar pool = require('typedarray-pool');\n\nvar SHADERS = require('./lib/shader');\n\nmodule.exports = createPointcloud2D;\n\nfunction Pointcloud2D(plot, offsetBuffer, pickBuffer, shader, pickShader) {\n  this.plot = plot;\n  this.offsetBuffer = offsetBuffer;\n  this.pickBuffer = pickBuffer;\n  this.shader = shader;\n  this.pickShader = pickShader;\n  this.sizeMin = 0.5;\n  this.sizeMinCap = 2;\n  this.sizeMax = 20;\n  this.areaRatio = 1.0;\n  this.pointCount = 0;\n  this.color = [1, 0, 0, 1];\n  this.borderColor = [0, 0, 0, 1];\n  this.blend = false;\n  this.pickOffset = 0;\n  this.points = null;\n}\n\nvar proto = Pointcloud2D.prototype;\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.pickShader.dispose();\n  this.offsetBuffer.dispose();\n  this.pickBuffer.dispose();\n  this.plot.removeObject(this);\n};\n\nproto.update = function (options) {\n  var i;\n  options = options || {};\n\n  function dflt(opt, value) {\n    if (opt in options) {\n      return options[opt];\n    }\n\n    return value;\n  }\n\n  this.sizeMin = dflt('sizeMin', 0.5); // this.sizeMinCap      = dflt('sizeMinCap', 2)\n\n  this.sizeMax = dflt('sizeMax', 20);\n  this.color = dflt('color', [1, 0, 0, 1]).slice();\n  this.areaRatio = dflt('areaRatio', 1);\n  this.borderColor = dflt('borderColor', [0, 0, 0, 1]).slice();\n  this.blend = dflt('blend', false); //Update point data\n  // Attempt straight-through processing (STP) to avoid allocation and copy\n  // TODO eventually abstract out STP logic, maybe into `pool` or a layer above\n\n  var pointCount = options.positions.length >>> 1;\n  var dataStraightThrough = options.positions instanceof Float32Array;\n  var idStraightThrough = options.idToIndex instanceof Int32Array && options.idToIndex.length >= pointCount; // permit larger to help reuse\n\n  var data = options.positions;\n  var packed = dataStraightThrough ? data : pool.mallocFloat32(data.length);\n  var packedId = idStraightThrough ? options.idToIndex : pool.mallocInt32(pointCount);\n\n  if (!dataStraightThrough) {\n    packed.set(data);\n  }\n\n  if (!idStraightThrough) {\n    packed.set(data);\n\n    for (i = 0; i < pointCount; i++) {\n      packedId[i] = i;\n    }\n  }\n\n  this.points = data;\n  this.offsetBuffer.update(packed);\n  this.pickBuffer.update(packedId);\n\n  if (!dataStraightThrough) {\n    pool.free(packed);\n  }\n\n  if (!idStraightThrough) {\n    pool.free(packedId);\n  }\n\n  this.pointCount = pointCount;\n  this.pickOffset = 0;\n};\n\nfunction count(points, dataBox) {\n  var visiblePointCountEstimate = 0;\n  var length = points.length >>> 1;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    var x = points[i * 2];\n    var y = points[i * 2 + 1];\n    if (x >= dataBox[0] && x <= dataBox[2] && y >= dataBox[1] && y <= dataBox[3]) visiblePointCountEstimate++;\n  }\n\n  return visiblePointCountEstimate;\n}\n\nproto.unifiedDraw = function () {\n  var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var PICK_VEC4 = [0, 0, 0, 0];\n  return function (pickOffset) {\n    var pick = pickOffset !== void 0;\n    var shader = pick ? this.pickShader : this.shader;\n    var gl = this.plot.gl;\n    var dataBox = this.plot.dataBox;\n\n    if (this.pointCount === 0) {\n      return pickOffset;\n    }\n\n    var dataX = dataBox[2] - dataBox[0];\n    var dataY = dataBox[3] - dataBox[1];\n    var visiblePointCountEstimate = count(this.points, dataBox);\n    var basicPointSize = this.plot.pickPixelRatio * Math.max(Math.min(this.sizeMinCap, this.sizeMin), Math.min(this.sizeMax, this.sizeMax / Math.pow(visiblePointCountEstimate, 0.33333)));\n    MATRIX[0] = 2.0 / dataX;\n    MATRIX[4] = 2.0 / dataY;\n    MATRIX[6] = -2.0 * dataBox[0] / dataX - 1.0;\n    MATRIX[7] = -2.0 * dataBox[1] / dataY - 1.0;\n    this.offsetBuffer.bind();\n    shader.bind();\n    shader.attributes.position.pointer();\n    shader.uniforms.matrix = MATRIX;\n    shader.uniforms.color = this.color;\n    shader.uniforms.borderColor = this.borderColor;\n    shader.uniforms.pointCloud = basicPointSize < 5;\n    shader.uniforms.pointSize = basicPointSize;\n    shader.uniforms.centerFraction = Math.min(1, Math.max(0, Math.sqrt(1 - this.areaRatio)));\n\n    if (pick) {\n      PICK_VEC4[0] = pickOffset & 0xff;\n      PICK_VEC4[1] = pickOffset >> 8 & 0xff;\n      PICK_VEC4[2] = pickOffset >> 16 & 0xff;\n      PICK_VEC4[3] = pickOffset >> 24 & 0xff;\n      this.pickBuffer.bind();\n      shader.attributes.pickId.pointer(gl.UNSIGNED_BYTE);\n      shader.uniforms.pickOffset = PICK_VEC4;\n      this.pickOffset = pickOffset;\n    } // Worth switching these off, but we can't make assumptions about other\n    // renderers, so let's restore it after each draw\n\n\n    var blend = gl.getParameter(gl.BLEND);\n    var dither = gl.getParameter(gl.DITHER);\n    if (blend && !this.blend) gl.disable(gl.BLEND);\n    if (dither) gl.disable(gl.DITHER);\n    gl.drawArrays(gl.POINTS, 0, this.pointCount);\n    if (blend && !this.blend) gl.enable(gl.BLEND);\n    if (dither) gl.enable(gl.DITHER);\n    return pickOffset + this.pointCount;\n  };\n}();\n\nproto.draw = proto.unifiedDraw;\nproto.drawPick = proto.unifiedDraw;\n\nproto.pick = function (x, y, value) {\n  var pickOffset = this.pickOffset;\n  var pointCount = this.pointCount;\n\n  if (value < pickOffset || value >= pickOffset + pointCount) {\n    return null;\n  }\n\n  var pointId = value - pickOffset;\n  var points = this.points;\n  return {\n    object: this,\n    pointId: pointId,\n    dataCoord: [points[2 * pointId], points[2 * pointId + 1]]\n  };\n};\n\nfunction createPointcloud2D(plot, options) {\n  var gl = plot.gl;\n  var buffer = createBuffer(gl);\n  var pickBuffer = createBuffer(gl);\n  var shader = createShader(gl, SHADERS.pointVertex, SHADERS.pointFragment);\n  var pickShader = createShader(gl, SHADERS.pickVertex, SHADERS.pickFragment);\n  var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader);\n  result.update(options); //Register with plot\n\n  plot.addObject(result);\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}