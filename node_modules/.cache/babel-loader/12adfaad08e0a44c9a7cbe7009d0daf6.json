{"ast":null,"code":"'use strict';\n\nmodule.exports = createErrorBars;\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createShader = require('./shaders/index');\n\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nfunction ErrorBars(gl, buffer, vao, shader) {\n  this.gl = gl;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.vao = vao;\n  this.pixelRatio = 1;\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.lineWidth = [1, 1, 1];\n  this.capSize = [10, 10, 10];\n  this.lineCount = [0, 0, 0];\n  this.lineOffset = [0, 0, 0];\n  this.opacity = 1;\n  this.hasAlpha = false;\n}\n\nvar proto = ErrorBars.prototype;\n\nproto.isOpaque = function () {\n  return !this.hasAlpha;\n};\n\nproto.isTransparent = function () {\n  return this.hasAlpha;\n};\n\nproto.drawTransparent = proto.draw = function (cameraParams) {\n  var gl = this.gl;\n  var uniforms = this.shader.uniforms;\n  this.shader.bind();\n  var view = uniforms.view = cameraParams.view || IDENTITY;\n  var projection = uniforms.projection = cameraParams.projection || IDENTITY;\n  uniforms.model = cameraParams.model || IDENTITY;\n  uniforms.clipBounds = this.clipBounds;\n  uniforms.opacity = this.opacity;\n  var cx = view[12];\n  var cy = view[13];\n  var cz = view[14];\n  var cw = view[15];\n  var isOrtho = cameraParams._ortho || false;\n  var orthoFix = isOrtho ? 2 : 1; // double up padding for orthographic ticks & labels\n\n  var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl.drawingBufferHeight;\n  this.vao.bind();\n\n  for (var i = 0; i < 3; ++i) {\n    gl.lineWidth(this.lineWidth[i] * this.pixelRatio);\n    uniforms.capSize = this.capSize[i] * pixelScaleF;\n\n    if (this.lineCount[i]) {\n      gl.drawArrays(gl.LINES, this.lineOffset[i], this.lineCount[i]);\n    }\n  }\n\n  this.vao.unbind();\n};\n\nfunction updateBounds(bounds, point) {\n  for (var i = 0; i < 3; ++i) {\n    bounds[0][i] = Math.min(bounds[0][i], point[i]);\n    bounds[1][i] = Math.max(bounds[1][i], point[i]);\n  }\n}\n\nvar FACE_TABLE = function () {\n  var table = new Array(3);\n\n  for (var d = 0; d < 3; ++d) {\n    var row = [];\n\n    for (var j = 1; j <= 2; ++j) {\n      for (var s = -1; s <= 1; s += 2) {\n        var u = (j + d) % 3;\n        var y = [0, 0, 0];\n        y[u] = s;\n        row.push(y);\n      }\n    }\n\n    table[d] = row;\n  }\n\n  return table;\n}();\n\nfunction emitFace(verts, x, c, d) {\n  var offsets = FACE_TABLE[d];\n\n  for (var i = 0; i < offsets.length; ++i) {\n    var o = offsets[i];\n    verts.push(x[0], x[1], x[2], c[0], c[1], c[2], c[3], o[0], o[1], o[2]);\n  }\n\n  return offsets.length;\n}\n\nproto.update = function (options) {\n  options = options || {};\n\n  if ('lineWidth' in options) {\n    this.lineWidth = options.lineWidth;\n\n    if (!Array.isArray(this.lineWidth)) {\n      this.lineWidth = [this.lineWidth, this.lineWidth, this.lineWidth];\n    }\n  }\n\n  if ('capSize' in options) {\n    this.capSize = options.capSize;\n\n    if (!Array.isArray(this.capSize)) {\n      this.capSize = [this.capSize, this.capSize, this.capSize];\n    }\n  }\n\n  this.hasAlpha = false; // default to no transparent draw\n\n  if ('opacity' in options) {\n    this.opacity = +options.opacity;\n\n    if (this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  }\n\n  var color = options.color || [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n  var position = options.position;\n  var error = options.error;\n\n  if (!Array.isArray(color[0])) {\n    color = [color, color, color];\n  }\n\n  if (position && error) {\n    var verts = [];\n    var n = position.length;\n    var vertexCount = 0;\n    this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n    this.lineCount = [0, 0, 0]; //Build geometry for lines\n\n    for (var j = 0; j < 3; ++j) {\n      this.lineOffset[j] = vertexCount;\n\n      i_loop: for (var i = 0; i < n; ++i) {\n        var p = position[i];\n\n        for (var k = 0; k < 3; ++k) {\n          if (isNaN(p[k]) || !isFinite(p[k])) {\n            continue i_loop;\n          }\n        }\n\n        var e = error[i];\n        var c = color[j];\n\n        if (Array.isArray(c[0])) {\n          c = color[i];\n        }\n\n        if (c.length === 3) {\n          c = [c[0], c[1], c[2], 1];\n        } else if (c.length === 4) {\n          c = [c[0], c[1], c[2], c[3]];\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n\n        if (isNaN(e[0][j]) || isNaN(e[1][j])) {\n          continue;\n        }\n\n        if (e[0][j] < 0) {\n          var x = p.slice();\n          x[j] += e[0][j];\n          verts.push(p[0], p[1], p[2], c[0], c[1], c[2], c[3], 0, 0, 0, x[0], x[1], x[2], c[0], c[1], c[2], c[3], 0, 0, 0);\n          updateBounds(this.bounds, x);\n          vertexCount += 2 + emitFace(verts, x, c, j);\n        }\n\n        if (e[1][j] > 0) {\n          var x = p.slice();\n          x[j] += e[1][j];\n          verts.push(p[0], p[1], p[2], c[0], c[1], c[2], c[3], 0, 0, 0, x[0], x[1], x[2], c[0], c[1], c[2], c[3], 0, 0, 0);\n          updateBounds(this.bounds, x);\n          vertexCount += 2 + emitFace(verts, x, c, j);\n        }\n      }\n\n      this.lineCount[j] = vertexCount - this.lineOffset[j];\n    }\n\n    this.buffer.update(verts);\n  }\n};\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.buffer.dispose();\n  this.vao.dispose();\n};\n\nfunction createErrorBars(options) {\n  var gl = options.gl;\n  var buffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: buffer,\n    type: gl.FLOAT,\n    size: 3,\n    offset: 0,\n    stride: 40\n  }, {\n    buffer: buffer,\n    type: gl.FLOAT,\n    size: 4,\n    offset: 12,\n    stride: 40\n  }, {\n    buffer: buffer,\n    type: gl.FLOAT,\n    size: 3,\n    offset: 28,\n    stride: 40\n  }]);\n  var shader = createShader(gl);\n  shader.attributes.position.location = 0;\n  shader.attributes.color.location = 1;\n  shader.attributes.offset.location = 2;\n  var result = new ErrorBars(gl, buffer, vao, shader);\n  result.update(options);\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}