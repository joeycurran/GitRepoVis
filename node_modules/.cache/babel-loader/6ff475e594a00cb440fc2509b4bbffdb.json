{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nmodule.exports = function partition(entry, size, opts) {\n  var flipX = opts.flipX;\n  var flipY = opts.flipY;\n  var swapXY = opts.packing === 'dice-slice';\n  var top = opts.pad[flipY ? 'bottom' : 'top'];\n  var left = opts.pad[flipX ? 'right' : 'left'];\n  var right = opts.pad[flipX ? 'left' : 'right'];\n  var bottom = opts.pad[flipY ? 'top' : 'bottom'];\n  var tmp;\n\n  if (swapXY) {\n    tmp = left;\n    left = top;\n    top = tmp;\n    tmp = right;\n    right = bottom;\n    bottom = tmp;\n  }\n\n  var result = d3Hierarchy.treemap().tile(getTilingMethod(opts.packing, opts.squarifyratio)).paddingInner(opts.pad.inner).paddingLeft(left).paddingRight(right).paddingTop(top).paddingBottom(bottom).size(swapXY ? [size[1], size[0]] : size)(entry);\n\n  if (swapXY || flipX || flipY) {\n    flipTree(result, size, {\n      swapXY: swapXY,\n      flipX: flipX,\n      flipY: flipY\n    });\n  }\n\n  return result;\n};\n\nfunction getTilingMethod(key, squarifyratio) {\n  switch (key) {\n    case 'squarify':\n      return d3Hierarchy.treemapSquarify.ratio(squarifyratio);\n\n    case 'binary':\n      return d3Hierarchy.treemapBinary;\n\n    case 'dice':\n      return d3Hierarchy.treemapDice;\n\n    case 'slice':\n      return d3Hierarchy.treemapSlice;\n\n    default:\n      // i.e. 'slice-dice' | 'dice-slice'\n      return d3Hierarchy.treemapSliceDice;\n  }\n}\n\nfunction flipTree(node, size, opts) {\n  var tmp;\n\n  if (opts.swapXY) {\n    // swap x0 and y0\n    tmp = node.x0;\n    node.x0 = node.y0;\n    node.y0 = tmp; // swap x1 and y1\n\n    tmp = node.x1;\n    node.x1 = node.y1;\n    node.y1 = tmp;\n  }\n\n  if (opts.flipX) {\n    tmp = node.x0;\n    node.x0 = size[0] - node.x1;\n    node.x1 = size[0] - tmp;\n  }\n\n  if (opts.flipY) {\n    tmp = node.y0;\n    node.y0 = size[1] - node.y1;\n    node.y1 = size[1] - tmp;\n  }\n\n  var children = node.children;\n\n  if (children) {\n    for (var i = 0; i < children.length; i++) {\n      flipTree(children[i], size, opts);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}