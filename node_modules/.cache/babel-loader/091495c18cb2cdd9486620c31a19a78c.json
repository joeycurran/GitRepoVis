{"ast":null,"code":"'use strict';\n\nmodule.exports = createHeatmap2D;\n\nvar bsearch = require('binary-search-bounds');\n\nvar iota = require('iota-array');\n\nvar pool = require('typedarray-pool');\n\nvar createShader = require('gl-shader');\n\nvar createBuffer = require('gl-buffer');\n\nvar shaders = require('./lib/shaders');\n\nfunction GLHeatmap2D(plot, shader, pickShader, positionBuffer, weightBuffer, colorBuffer, idBuffer) {\n  this.plot = plot;\n  this.shader = shader;\n  this.pickShader = pickShader;\n  this.positionBuffer = positionBuffer;\n  this.weightBuffer = weightBuffer;\n  this.colorBuffer = colorBuffer;\n  this.idBuffer = idBuffer;\n  this.xData = [];\n  this.yData = [];\n  this.shape = [0, 0];\n  this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  this.pickOffset = 0;\n}\n\nvar proto = GLHeatmap2D.prototype;\nvar WEIGHTS = [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1];\n\nproto.draw = function () {\n  var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  return function () {\n    var plot = this.plot;\n    var shader = this.shader;\n    var bounds = this.bounds;\n    var numVertices = this.numVertices;\n\n    if (numVertices <= 0) {\n      return;\n    }\n\n    var gl = plot.gl;\n    var dataBox = plot.dataBox;\n    var boundX = bounds[2] - bounds[0];\n    var boundY = bounds[3] - bounds[1];\n    var dataX = dataBox[2] - dataBox[0];\n    var dataY = dataBox[3] - dataBox[1];\n    MATRIX[0] = 2.0 * boundX / dataX;\n    MATRIX[4] = 2.0 * boundY / dataY;\n    MATRIX[6] = 2.0 * (bounds[0] - dataBox[0]) / dataX - 1.0;\n    MATRIX[7] = 2.0 * (bounds[1] - dataBox[1]) / dataY - 1.0;\n    shader.bind();\n    var uniforms = shader.uniforms;\n    uniforms.viewTransform = MATRIX;\n    uniforms.shape = this.shape;\n    var attributes = shader.attributes;\n    this.positionBuffer.bind();\n    attributes.position.pointer();\n    this.weightBuffer.bind();\n    attributes.weight.pointer(gl.UNSIGNED_BYTE, false);\n    this.colorBuffer.bind();\n    attributes.color.pointer(gl.UNSIGNED_BYTE, true);\n    gl.drawArrays(gl.TRIANGLES, 0, numVertices);\n  };\n}();\n\nproto.drawPick = function () {\n  var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var PICK_VECTOR = [0, 0, 0, 0];\n  return function (pickOffset) {\n    var plot = this.plot;\n    var shader = this.pickShader;\n    var bounds = this.bounds;\n    var numVertices = this.numVertices;\n\n    if (numVertices <= 0) {\n      return;\n    }\n\n    var gl = plot.gl;\n    var dataBox = plot.dataBox;\n    var boundX = bounds[2] - bounds[0];\n    var boundY = bounds[3] - bounds[1];\n    var dataX = dataBox[2] - dataBox[0];\n    var dataY = dataBox[3] - dataBox[1];\n    MATRIX[0] = 2.0 * boundX / dataX;\n    MATRIX[4] = 2.0 * boundY / dataY;\n    MATRIX[6] = 2.0 * (bounds[0] - dataBox[0]) / dataX - 1.0;\n    MATRIX[7] = 2.0 * (bounds[1] - dataBox[1]) / dataY - 1.0;\n\n    for (var i = 0; i < 4; ++i) {\n      PICK_VECTOR[i] = pickOffset >> i * 8 & 0xff;\n    }\n\n    this.pickOffset = pickOffset;\n    shader.bind();\n    var uniforms = shader.uniforms;\n    uniforms.viewTransform = MATRIX;\n    uniforms.pickOffset = PICK_VECTOR;\n    uniforms.shape = this.shape;\n    var attributes = shader.attributes;\n    this.positionBuffer.bind();\n    attributes.position.pointer();\n    this.weightBuffer.bind();\n    attributes.weight.pointer(gl.UNSIGNED_BYTE, false);\n    this.idBuffer.bind();\n    attributes.pickId.pointer(gl.UNSIGNED_BYTE, false);\n    gl.drawArrays(gl.TRIANGLES, 0, numVertices);\n    return pickOffset + this.shape[0] * this.shape[1];\n  };\n}();\n\nproto.pick = function (x, y, value) {\n  var pickOffset = this.pickOffset;\n  var pointCount = this.shape[0] * this.shape[1];\n\n  if (value < pickOffset || value >= pickOffset + pointCount) {\n    return null;\n  }\n\n  var pointId = value - pickOffset;\n  var xData = this.xData;\n  var yData = this.yData;\n  return {\n    object: this,\n    pointId: pointId,\n    dataCoord: [xData[pointId % this.shape[0]], yData[pointId / this.shape[0] | 0]]\n  };\n};\n\nproto.update = function (options) {\n  options = options || {};\n  var shape = options.shape || [0, 0];\n  var x = options.x || iota(shape[0]);\n  var y = options.y || iota(shape[1]);\n  var z = options.z || new Float32Array(shape[0] * shape[1]);\n  this.xData = x;\n  this.yData = y;\n  var colorLevels = options.colorLevels || [0];\n  var colorValues = options.colorValues || [0, 0, 0, 1];\n  var colorCount = colorLevels.length;\n  var bounds = this.bounds;\n  var lox = bounds[0] = x[0];\n  var loy = bounds[1] = y[0];\n  var hix = bounds[2] = x[x.length - 1];\n  var hiy = bounds[3] = y[y.length - 1];\n  var xs = 1.0 / (hix - lox);\n  var ys = 1.0 / (hiy - loy);\n  var numX = shape[0];\n  var numY = shape[1];\n  this.shape = [numX, numY];\n  var numVerts = (numX - 1) * (numY - 1) * (WEIGHTS.length >>> 1);\n  this.numVertices = numVerts;\n  var colors = pool.mallocUint8(numVerts * 4);\n  var positions = pool.mallocFloat32(numVerts * 2);\n  var weights = pool.mallocUint8(numVerts * 2);\n  var ids = pool.mallocUint32(numVerts);\n  var ptr = 0;\n\n  for (var j = 0; j < numY - 1; ++j) {\n    var yc0 = ys * (y[j] - loy);\n    var yc1 = ys * (y[j + 1] - loy);\n\n    for (var i = 0; i < numX - 1; ++i) {\n      var xc0 = xs * (x[i] - lox);\n      var xc1 = xs * (x[i + 1] - lox);\n\n      for (var dd = 0; dd < WEIGHTS.length; dd += 2) {\n        var dx = WEIGHTS[dd];\n        var dy = WEIGHTS[dd + 1];\n        var offset = (j + dy) * numX + (i + dx);\n        var zc = z[offset];\n        var colorIdx = bsearch.le(colorLevels, zc);\n        var r, g, b, a;\n\n        if (colorIdx < 0) {\n          r = colorValues[0];\n          g = colorValues[1];\n          b = colorValues[2];\n          a = colorValues[3];\n        } else if (colorIdx === colorCount - 1) {\n          r = colorValues[4 * colorCount - 4];\n          g = colorValues[4 * colorCount - 3];\n          b = colorValues[4 * colorCount - 2];\n          a = colorValues[4 * colorCount - 1];\n        } else {\n          var t = (zc - colorLevels[colorIdx]) / (colorLevels[colorIdx + 1] - colorLevels[colorIdx]);\n          var ti = 1.0 - t;\n          var i0 = 4 * colorIdx;\n          var i1 = 4 * (colorIdx + 1);\n          r = ti * colorValues[i0] + t * colorValues[i1];\n          g = ti * colorValues[i0 + 1] + t * colorValues[i1 + 1];\n          b = ti * colorValues[i0 + 2] + t * colorValues[i1 + 2];\n          a = ti * colorValues[i0 + 3] + t * colorValues[i1 + 3];\n        }\n\n        colors[4 * ptr] = 255 * r;\n        colors[4 * ptr + 1] = 255 * g;\n        colors[4 * ptr + 2] = 255 * b;\n        colors[4 * ptr + 3] = 255 * a;\n        positions[2 * ptr] = xc0 * .5 + xc1 * .5;\n        positions[2 * ptr + 1] = yc0 * .5 + yc1 * .5;\n        weights[2 * ptr] = dx;\n        weights[2 * ptr + 1] = dy;\n        ids[ptr] = j * numX + i;\n        ptr += 1;\n      }\n    }\n  }\n\n  this.positionBuffer.update(positions);\n  this.weightBuffer.update(weights);\n  this.colorBuffer.update(colors);\n  this.idBuffer.update(ids);\n  pool.free(positions);\n  pool.free(colors);\n  pool.free(weights);\n  pool.free(ids);\n};\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.pickShader.dispose();\n  this.positionBuffer.dispose();\n  this.weightBuffer.dispose();\n  this.colorBuffer.dispose();\n  this.idBuffer.dispose();\n  this.plot.removeObject(this);\n};\n\nfunction createHeatmap2D(plot, options) {\n  var gl = plot.gl;\n  var shader = createShader(gl, shaders.vertex, shaders.fragment);\n  var pickShader = createShader(gl, shaders.pickVertex, shaders.pickFragment);\n  var positionBuffer = createBuffer(gl);\n  var weightBuffer = createBuffer(gl);\n  var colorBuffer = createBuffer(gl);\n  var idBuffer = createBuffer(gl);\n  var heatmap = new GLHeatmap2D(plot, shader, pickShader, positionBuffer, weightBuffer, colorBuffer, idBuffer);\n  heatmap.update(options);\n  plot.addObject(heatmap);\n  return heatmap;\n}","map":null,"metadata":{},"sourceType":"script"}