{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nmodule.exports = function (vectorfield, bounds) {\n  var positions = vectorfield.positions;\n  var vectors = vectorfield.vectors;\n  var geo = {\n    positions: [],\n    vertexIntensity: [],\n    vertexIntensityBounds: vectorfield.vertexIntensityBounds,\n    vectors: [],\n    cells: [],\n    coneOffset: vectorfield.coneOffset,\n    colormap: vectorfield.colormap\n  };\n\n  if (vectorfield.positions.length === 0) {\n    if (bounds) {\n      bounds[0] = [0, 0, 0];\n      bounds[1] = [0, 0, 0];\n    }\n\n    return geo;\n  } // Compute bounding box for the dataset.\n  // Compute maximum velocity for the dataset to use for scaling the cones.\n\n\n  var maxNorm = 0;\n  var minX = Infinity,\n      maxX = -Infinity;\n  var minY = Infinity,\n      maxY = -Infinity;\n  var minZ = Infinity,\n      maxZ = -Infinity;\n  var p2 = null;\n  var u2 = null;\n  var positionVectors = [];\n  var vectorScale = Infinity;\n  var skipIt = false;\n\n  for (var i = 0; i < positions.length; i++) {\n    var p = positions[i];\n    minX = Math.min(p[0], minX);\n    maxX = Math.max(p[0], maxX);\n    minY = Math.min(p[1], minY);\n    maxY = Math.max(p[1], maxY);\n    minZ = Math.min(p[2], minZ);\n    maxZ = Math.max(p[2], maxZ);\n    var u = vectors[i];\n\n    if (vec3.length(u) > maxNorm) {\n      maxNorm = vec3.length(u);\n    }\n\n    if (i) {\n      // Find vector scale [w/ units of time] using \"successive\" positions\n      // (not \"adjacent\" with would be O(n^2)),\n      //\n      // The vector scale corresponds to the minimum \"time\" to travel across two\n      // two adjacent positions at the average velocity of those two adjacent positions\n      var q = 2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u));\n\n      if (q) {\n        vectorScale = Math.min(vectorScale, q);\n        skipIt = false;\n      } else {\n        skipIt = true;\n      }\n    }\n\n    if (!skipIt) {\n      p2 = p;\n      u2 = u;\n    }\n\n    positionVectors.push(u);\n  }\n\n  var minV = [minX, minY, minZ];\n  var maxV = [maxX, maxY, maxZ];\n\n  if (bounds) {\n    bounds[0] = minV;\n    bounds[1] = maxV;\n  }\n\n  if (maxNorm === 0) {\n    maxNorm = 1;\n  } // Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\n\n  var invertedMaxNorm = 1 / maxNorm;\n\n  if (!isFinite(vectorScale)) {\n    vectorScale = 1.0;\n  }\n\n  geo.vectorScale = vectorScale;\n  var coneScale = vectorfield.coneSize || 0.5;\n\n  if (vectorfield.absoluteConeSize) {\n    coneScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n  }\n\n  geo.coneScale = coneScale; // Build the cone model.\n\n  for (var i = 0, j = 0; i < positions.length; i++) {\n    var p = positions[i];\n    var x = p[0],\n        y = p[1],\n        z = p[2];\n    var d = positionVectors[i];\n    var intensity = vec3.length(d) * invertedMaxNorm;\n\n    for (var k = 0, l = 8; k < l; k++) {\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      var m = geo.positions.length;\n      geo.cells.push([m - 6, m - 5, m - 4], [m - 3, m - 2, m - 1]);\n    }\n  }\n\n  return geo;\n};\n\nvar shaders = require('./lib/shaders');\n\nmodule.exports.createMesh = require('./create_mesh');\n\nmodule.exports.createConeMesh = function (gl, params) {\n  return module.exports.createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'cone'\n  });\n};","map":null,"metadata":{},"sourceType":"script"}