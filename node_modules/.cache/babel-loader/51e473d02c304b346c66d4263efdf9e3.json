{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar barPlot = require('../bar/plot').plot;\n\nmodule.exports = function plot(gd, plotinfo, cdModule, traceLayer) {\n  var fullLayout = gd._fullLayout;\n  plotConnectorRegions(gd, plotinfo, cdModule, traceLayer);\n  plotConnectorLines(gd, plotinfo, cdModule, traceLayer);\n  barPlot(gd, plotinfo, cdModule, traceLayer, {\n    mode: fullLayout.funnelmode,\n    norm: fullLayout.funnelmode,\n    gap: fullLayout.funnelgap,\n    groupgap: fullLayout.funnelgroupgap\n  });\n};\n\nfunction plotConnectorRegions(gd, plotinfo, cdModule, traceLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var group = Lib.ensureSingle(plotGroup, 'g', 'regions');\n\n    if (!trace.connector || !trace.connector.visible) {\n      group.remove();\n      return;\n    }\n\n    var isHorizontal = trace.orientation === 'h';\n    var connectors = group.selectAll('g.region').data(Lib.identity);\n    connectors.enter().append('g').classed('region', true);\n    connectors.exit().remove();\n    var len = connectors.size();\n    connectors.each(function (di, i) {\n      // don't draw lines between nulls\n      if (i !== len - 1 && !di.cNext) return;\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x = xy[0];\n      var y = xy[1];\n      var shape = '';\n\n      if (x[3] !== undefined && y[3] !== undefined) {\n        if (isHorizontal) {\n          shape += 'M' + x[0] + ',' + y[1] + 'L' + x[2] + ',' + y[2] + 'H' + x[3] + 'L' + x[1] + ',' + y[1] + 'Z';\n        } else {\n          shape += 'M' + x[1] + ',' + y[1] + 'L' + x[2] + ',' + y[3] + 'V' + y[2] + 'L' + x[1] + ',' + y[0] + 'Z';\n        }\n      }\n\n      Lib.ensureSingle(d3.select(this), 'path').attr('d', shape).call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n    });\n  });\n}\n\nfunction plotConnectorLines(gd, plotinfo, cdModule, traceLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var group = Lib.ensureSingle(plotGroup, 'g', 'lines');\n\n    if (!trace.connector || !trace.connector.visible || !trace.connector.line.width) {\n      group.remove();\n      return;\n    }\n\n    var isHorizontal = trace.orientation === 'h';\n    var connectors = group.selectAll('g.line').data(Lib.identity);\n    connectors.enter().append('g').classed('line', true);\n    connectors.exit().remove();\n    var len = connectors.size();\n    connectors.each(function (di, i) {\n      // don't draw lines between nulls\n      if (i !== len - 1 && !di.cNext) return;\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x = xy[0];\n      var y = xy[1];\n      var shape = '';\n\n      if (x[3] !== undefined && y[3] !== undefined) {\n        if (isHorizontal) {\n          shape += 'M' + x[0] + ',' + y[1] + 'L' + x[2] + ',' + y[2];\n          shape += 'M' + x[1] + ',' + y[1] + 'L' + x[3] + ',' + y[2];\n        } else {\n          shape += 'M' + x[1] + ',' + y[1] + 'L' + x[2] + ',' + y[3];\n          shape += 'M' + x[1] + ',' + y[0] + 'L' + x[2] + ',' + y[2];\n        }\n      }\n\n      if (shape === '') shape = 'M0,0Z';\n      Lib.ensureSingle(d3.select(this), 'path').attr('d', shape).call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n    });\n  });\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  s[2] = sAxis.c2p(di.nextS0, true);\n  p[2] = pAxis.c2p(di.nextP0, true);\n  s[3] = sAxis.c2p(di.nextS1, true);\n  p[3] = pAxis.c2p(di.nextP1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}","map":null,"metadata":{},"sourceType":"script"}