{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nmodule.exports = function calc(gd, trace) {\n  var i, j, k;\n  var u = trace.u;\n  var v = trace.v;\n  var w = trace.w;\n  var x = trace.x;\n  var y = trace.y;\n  var z = trace.z;\n  var len = Math.min(x.length, y.length, z.length, u.length, v.length, w.length);\n  var slen = 0;\n  var startx, starty, startz;\n\n  if (trace.starts) {\n    startx = trace.starts.x || [];\n    starty = trace.starts.y || [];\n    startz = trace.starts.z || [];\n    slen = Math.min(startx.length, starty.length, startz.length);\n  }\n\n  var normMax = 0;\n  var normMin = Infinity;\n\n  for (i = 0; i < len; i++) {\n    var uu = u[i];\n    var vv = v[i];\n    var ww = w[i];\n    var norm = Math.sqrt(uu * uu + vv * vv + ww * ww);\n    normMax = Math.max(normMax, norm);\n    normMin = Math.min(normMin, norm);\n  }\n\n  colorscaleCalc(gd, trace, {\n    vals: [normMin, normMax],\n    containerStr: '',\n    cLetter: 'c'\n  });\n  var xMax = -Infinity;\n  var xMin = Infinity;\n  var yMax = -Infinity;\n  var yMin = Infinity;\n  var zMax = -Infinity;\n  var zMin = Infinity;\n  var gridFill = '';\n  var filledX;\n  var filledY;\n  var filledZ;\n  var firstX;\n  var firstY;\n  var firstZ;\n\n  if (len) {\n    firstX = x[0];\n    firstY = y[0];\n    firstZ = z[0];\n  }\n\n  for (i = 0; i < len; i++) {\n    xMax = Math.max(xMax, x[i]);\n    xMin = Math.min(xMin, x[i]);\n    yMax = Math.max(yMax, y[i]);\n    yMin = Math.min(yMin, y[i]);\n    zMax = Math.max(zMax, z[i]);\n    zMin = Math.min(zMin, z[i]);\n\n    if (!filledX && x[i] !== firstX) {\n      filledX = true;\n      gridFill += 'x';\n    }\n\n    if (!filledY && y[i] !== firstY) {\n      filledY = true;\n      gridFill += 'y';\n    }\n\n    if (!filledZ && z[i] !== firstZ) {\n      filledZ = true;\n      gridFill += 'z';\n    }\n  } // fill if not filled - case of having dimension(s) with one item\n\n\n  if (!filledX) gridFill += 'x';\n  if (!filledY) gridFill += 'y';\n  if (!filledZ) gridFill += 'z';\n  var Xs = distinctVals(trace.x.slice(0, len));\n  var Ys = distinctVals(trace.y.slice(0, len));\n  var Zs = distinctVals(trace.z.slice(0, len));\n  gridFill = gridFill.replace('x', (x[0] > x[len - 1] ? '-' : '+') + 'x');\n  gridFill = gridFill.replace('y', (y[0] > y[len - 1] ? '-' : '+') + 'y');\n  gridFill = gridFill.replace('z', (z[0] > z[len - 1] ? '-' : '+') + 'z');\n\n  var empty = function () {\n    len = 0;\n    Xs = [];\n    Ys = [];\n    Zs = [];\n  }; // Over-specified mesh case, this would error in tube2mesh\n\n\n  if (!len || len < Xs.length * Ys.length * Zs.length) empty();\n\n  var getArray = function (c) {\n    return c === 'x' ? x : c === 'y' ? y : z;\n  };\n\n  var getVals = function (c) {\n    return c === 'x' ? Xs : c === 'y' ? Ys : Zs;\n  };\n\n  var getDir = function (c) {\n    return c[len - 1] < c[0] ? -1 : 1;\n  };\n\n  var arrK = getArray(gridFill[1]);\n  var arrJ = getArray(gridFill[3]);\n  var arrI = getArray(gridFill[5]);\n  var nk = getVals(gridFill[1]).length;\n  var nj = getVals(gridFill[3]).length;\n  var ni = getVals(gridFill[5]).length;\n  var arbitrary = false;\n\n  var getIndex = function (_i, _j, _k) {\n    return nk * (nj * _i + _j) + _k;\n  };\n\n  var dirK = getDir(getArray(gridFill[1]));\n  var dirJ = getDir(getArray(gridFill[3]));\n  var dirI = getDir(getArray(gridFill[5]));\n\n  for (i = 0; i < ni - 1; i++) {\n    for (j = 0; j < nj - 1; j++) {\n      for (k = 0; k < nk - 1; k++) {\n        var q000 = getIndex(i, j, k);\n        var q001 = getIndex(i, j, k + 1);\n        var q010 = getIndex(i, j + 1, k);\n        var q100 = getIndex(i + 1, j, k);\n\n        if (!(arrK[q000] * dirK < arrK[q001] * dirK) || !(arrJ[q000] * dirJ < arrJ[q010] * dirJ) || !(arrI[q000] * dirI < arrI[q100] * dirI)) {\n          arbitrary = true;\n        }\n\n        if (arbitrary) break;\n      }\n\n      if (arbitrary) break;\n    }\n\n    if (arbitrary) break;\n  }\n\n  if (arbitrary) {\n    Lib.warn('Encountered arbitrary coordinates! Unable to input data grid.');\n    empty();\n  }\n\n  for (i = 0; i < slen; i++) {\n    var sx = startx[i];\n    xMax = Math.max(xMax, sx);\n    xMin = Math.min(xMin, sx);\n    var sy = starty[i];\n    yMax = Math.max(yMax, sy);\n    yMin = Math.min(yMin, sy);\n    var sz = startz[i];\n    zMax = Math.max(zMax, sz);\n    zMin = Math.min(zMin, sz);\n  }\n\n  trace._len = len;\n  trace._slen = slen;\n  trace._normMax = normMax;\n  trace._xbnds = [xMin, xMax];\n  trace._ybnds = [yMin, yMax];\n  trace._zbnds = [zMin, zMax];\n  trace._Xs = Xs;\n  trace._Ys = Ys;\n  trace._Zs = Zs;\n  trace._gridFill = gridFill;\n};\n\nfunction distinctVals(col) {\n  return Lib.distinctVals(col).vals;\n}","map":null,"metadata":{},"sourceType":"script"}