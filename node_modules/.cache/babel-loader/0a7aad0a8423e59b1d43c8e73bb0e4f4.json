{"ast":null,"code":"'use strict';\n\nmodule.exports = planarGraphToPolyline;\n\nvar e2a = require('edges-to-adjacency-list');\n\nvar planarDual = require('planar-dual');\n\nvar preprocessPolygon = require('point-in-big-polygon');\n\nvar twoProduct = require('two-product');\n\nvar robustSum = require('robust-sum');\n\nvar uniq = require('uniq');\n\nvar trimLeaves = require('./lib/trim-leaves');\n\nfunction makeArray(length, fill) {\n  var result = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = fill;\n  }\n\n  return result;\n}\n\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = [];\n  }\n\n  return result;\n}\n\nfunction planarGraphToPolyline(edges, positions) {\n  //Trim leaves\n  var result = trimLeaves(edges, positions);\n  edges = result[0];\n  positions = result[1];\n  var numVertices = positions.length;\n  var numEdges = edges.length; //Calculate adjacency list, check manifold\n\n  var adj = e2a(edges, positions.length);\n\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold');\n    }\n  } //Get faces\n\n\n  var faces = planarDual(edges, positions); //Check orientation of a polygon using exact arithmetic\n\n  function ccw(c) {\n    var n = c.length;\n    var area = [0];\n\n    for (var j = 0; j < n; ++j) {\n      var a = positions[c[j]];\n      var b = positions[c[(j + 1) % n]];\n      var t00 = twoProduct(-a[0], a[1]);\n      var t01 = twoProduct(-a[0], b[1]);\n      var t10 = twoProduct(b[0], a[1]);\n      var t11 = twoProduct(b[0], b[1]);\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));\n    }\n\n    return area[area.length - 1] > 0;\n  } //Extract all clockwise faces\n\n\n  faces = faces.filter(ccw); //Detect which loops are contained in one another to handle parent-of relation\n\n  var numFaces = faces.length;\n  var parent = new Array(numFaces);\n  var containment = new Array(numFaces);\n\n  for (var i = 0; i < numFaces; ++i) {\n    parent[i] = i;\n    var row = new Array(numFaces);\n    var loopVertices = faces[i].map(function (v) {\n      return positions[v];\n    });\n    var pmc = preprocessPolygon([loopVertices]);\n    var count = 0;\n\n    outer: for (var j = 0; j < numFaces; ++j) {\n      row[j] = 0;\n\n      if (i === j) {\n        continue;\n      }\n\n      var c = faces[j];\n      var n = c.length;\n\n      for (var k = 0; k < n; ++k) {\n        var d = pmc(positions[c[k]]);\n\n        if (d !== 0) {\n          if (d < 0) {\n            row[j] = 1;\n            count += 1;\n          }\n\n          continue outer;\n        }\n      }\n\n      row[j] = 1;\n      count += 1;\n    }\n\n    containment[i] = [count, i, row];\n  }\n\n  containment.sort(function (a, b) {\n    return b[0] - a[0];\n  });\n\n  for (var i = 0; i < numFaces; ++i) {\n    var row = containment[i];\n    var idx = row[1];\n    var children = row[2];\n\n    for (var j = 0; j < numFaces; ++j) {\n      if (children[j]) {\n        parent[j] = idx;\n      }\n    }\n  } //Initialize face adjacency list\n\n\n  var fadj = makeArrayOfArrays(numFaces);\n\n  for (var i = 0; i < numFaces; ++i) {\n    fadj[i].push(parent[i]);\n    fadj[parent[i]].push(i);\n  } //Build adjacency matrix for edges\n\n\n  var edgeAdjacency = {};\n  var internalVertices = makeArray(numVertices, false);\n\n  for (var i = 0; i < numFaces; ++i) {\n    var c = faces[i];\n    var n = c.length;\n\n    for (var j = 0; j < n; ++j) {\n      var a = c[j];\n      var b = c[(j + 1) % n];\n      var key = Math.min(a, b) + \":\" + Math.max(a, b);\n\n      if (key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key];\n        fadj[neighbor].push(i);\n        fadj[i].push(neighbor);\n        internalVertices[a] = internalVertices[b] = true;\n      } else {\n        edgeAdjacency[key] = i;\n      }\n    }\n  }\n\n  function sharedBoundary(c) {\n    var n = c.length;\n\n    for (var i = 0; i < n; ++i) {\n      if (!internalVertices[c[i]]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  var toVisit = [];\n  var parity = makeArray(numFaces, -1);\n\n  for (var i = 0; i < numFaces; ++i) {\n    if (parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i);\n      parity[i] = 0;\n    } else {\n      parity[i] = -1;\n    }\n  } //Using face adjacency, classify faces as in/out\n\n\n  var result = [];\n\n  while (toVisit.length > 0) {\n    var top = toVisit.pop();\n    var nbhd = fadj[top];\n    uniq(nbhd, function (a, b) {\n      return a - b;\n    });\n    var nnbhr = nbhd.length;\n    var p = parity[top];\n    var polyline;\n\n    if (p === 0) {\n      var c = faces[top];\n      polyline = [c];\n    }\n\n    for (var i = 0; i < nnbhr; ++i) {\n      var f = nbhd[i];\n\n      if (parity[f] >= 0) {\n        continue;\n      }\n\n      parity[f] = p ^ 1;\n      toVisit.push(f);\n\n      if (p === 0) {\n        var c = faces[f];\n\n        if (!sharedBoundary(c)) {\n          c.reverse();\n          polyline.push(c);\n        }\n      }\n    }\n\n    if (p === 0) {\n      result.push(polyline);\n    }\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}