{"ast":null,"code":"'use strict';\n\nmodule.exports = createLinePlot;\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar unpackFloat = require('glsl-read-float');\n\nvar bsearch = require('binary-search-bounds');\n\nvar ndarray = require('ndarray');\n\nvar shaders = require('./lib/shaders');\n\nvar createShader = shaders.createShader;\nvar createPickShader = shaders.createPickShader;\nvar identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nfunction distance(a, b) {\n  var s = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    var d = a[i] - b[i];\n    s += d * d;\n  }\n\n  return Math.sqrt(s);\n}\n\nfunction filterClipBounds(bounds) {\n  var result = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n  for (var i = 0; i < 3; ++i) {\n    result[0][i] = Math.max(bounds[0][i], result[0][i]);\n    result[1][i] = Math.min(bounds[1][i], result[1][i]);\n  }\n\n  return result;\n}\n\nfunction PickResult(tau, position, index, dataCoordinate) {\n  this.arcLength = tau;\n  this.position = position;\n  this.index = index;\n  this.dataCoordinate = dataCoordinate;\n}\n\nfunction LinePlot(gl, shader, pickShader, buffer, vao, texture) {\n  this.gl = gl;\n  this.shader = shader;\n  this.pickShader = pickShader;\n  this.buffer = buffer;\n  this.vao = vao;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.points = [];\n  this.arcLength = [];\n  this.vertexCount = 0;\n  this.bounds = [[0, 0, 0], [0, 0, 0]];\n  this.pickId = 0;\n  this.lineWidth = 1;\n  this.texture = texture;\n  this.dashScale = 1;\n  this.opacity = 1;\n  this.hasAlpha = false;\n  this.dirty = true;\n  this.pixelRatio = 1;\n}\n\nvar proto = LinePlot.prototype;\n\nproto.isTransparent = function () {\n  return this.hasAlpha;\n};\n\nproto.isOpaque = function () {\n  return !this.hasAlpha;\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nproto.drawTransparent = proto.draw = function (camera) {\n  if (!this.vertexCount) return;\n  var gl = this.gl;\n  var shader = this.shader;\n  var vao = this.vao;\n  shader.bind();\n  shader.uniforms = {\n    model: camera.model || identity,\n    view: camera.view || identity,\n    projection: camera.projection || identity,\n    clipBounds: filterClipBounds(this.clipBounds),\n    dashTexture: this.texture.bind(),\n    dashScale: this.dashScale / this.arcLength[this.arcLength.length - 1],\n    opacity: this.opacity,\n    screenShape: [gl.drawingBufferWidth, gl.drawingBufferHeight],\n    pixelRatio: this.pixelRatio\n  };\n  vao.bind();\n  vao.draw(gl.TRIANGLE_STRIP, this.vertexCount);\n  vao.unbind();\n};\n\nproto.drawPick = function (camera) {\n  if (!this.vertexCount) return;\n  var gl = this.gl;\n  var shader = this.pickShader;\n  var vao = this.vao;\n  shader.bind();\n  shader.uniforms = {\n    model: camera.model || identity,\n    view: camera.view || identity,\n    projection: camera.projection || identity,\n    pickId: this.pickId,\n    clipBounds: filterClipBounds(this.clipBounds),\n    screenShape: [gl.drawingBufferWidth, gl.drawingBufferHeight],\n    pixelRatio: this.pixelRatio\n  };\n  vao.bind();\n  vao.draw(gl.TRIANGLE_STRIP, this.vertexCount);\n  vao.unbind();\n};\n\nproto.update = function (options) {\n  var i, j;\n  this.dirty = true;\n  var connectGaps = !!options.connectGaps;\n\n  if ('dashScale' in options) {\n    this.dashScale = options.dashScale;\n  }\n\n  this.hasAlpha = false; // default to no transparent draw\n\n  if ('opacity' in options) {\n    this.opacity = +options.opacity;\n\n    if (this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  } // Recalculate buffer data\n\n\n  var buffer = [];\n  var arcLengthArray = [];\n  var pointArray = [];\n  var arcLength = 0.0;\n  var vertexCount = 0;\n  var bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  var positions = options.position || options.positions;\n\n  if (positions) {\n    // Default color\n    var colors = options.color || options.colors || [0, 0, 0, 1];\n    var lineWidth = options.lineWidth || 1;\n    var hadGap = false;\n\n    fill_loop: for (i = 1; i < positions.length; ++i) {\n      var a = positions[i - 1];\n      var b = positions[i];\n      arcLengthArray.push(arcLength);\n      pointArray.push(a.slice());\n\n      for (j = 0; j < 3; ++j) {\n        if (isNaN(a[j]) || isNaN(b[j]) || !isFinite(a[j]) || !isFinite(b[j])) {\n          if (!connectGaps && buffer.length > 0) {\n            for (var k = 0; k < 24; ++k) {\n              buffer.push(buffer[buffer.length - 12]);\n            }\n\n            vertexCount += 2;\n            hadGap = true;\n          }\n\n          continue fill_loop;\n        }\n\n        bounds[0][j] = Math.min(bounds[0][j], a[j], b[j]);\n        bounds[1][j] = Math.max(bounds[1][j], a[j], b[j]);\n      }\n\n      var acolor, bcolor;\n\n      if (Array.isArray(colors[0])) {\n        acolor = colors.length > i - 1 ? colors[i - 1] : // using index value\n        colors.length > 0 ? colors[colors.length - 1] : // using last item\n        [0, 0, 0, 1]; // using black\n\n        bcolor = colors.length > i ? colors[i] : // using index value\n        colors.length > 0 ? colors[colors.length - 1] : // using last item\n        [0, 0, 0, 1]; // using black\n      } else {\n        acolor = bcolor = colors;\n      }\n\n      if (acolor.length === 3) {\n        acolor = [acolor[0], acolor[1], acolor[2], 1];\n      }\n\n      if (bcolor.length === 3) {\n        bcolor = [bcolor[0], bcolor[1], bcolor[2], 1];\n      }\n\n      if (!this.hasAlpha && acolor[3] < 1) this.hasAlpha = true;\n      var w0;\n\n      if (Array.isArray(lineWidth)) {\n        w0 = lineWidth.length > i - 1 ? lineWidth[i - 1] : // using index value\n        lineWidth.length > 0 ? lineWidth[lineWidth.length - 1] : // using last item\n        [0, 0, 0, 1]; // using black\n      } else {\n        w0 = lineWidth;\n      }\n\n      var t0 = arcLength;\n      arcLength += distance(a, b);\n\n      if (hadGap) {\n        for (j = 0; j < 2; ++j) {\n          buffer.push(a[0], a[1], a[2], b[0], b[1], b[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3]);\n        }\n\n        vertexCount += 2;\n        hadGap = false;\n      }\n\n      buffer.push(a[0], a[1], a[2], b[0], b[1], b[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3], a[0], a[1], a[2], b[0], b[1], b[2], t0, -w0, acolor[0], acolor[1], acolor[2], acolor[3], b[0], b[1], b[2], a[0], a[1], a[2], arcLength, -w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3], b[0], b[1], b[2], a[0], a[1], a[2], arcLength, w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3]);\n      vertexCount += 4;\n    }\n  }\n\n  this.buffer.update(buffer);\n  arcLengthArray.push(arcLength);\n  pointArray.push(positions[positions.length - 1].slice());\n  this.bounds = bounds;\n  this.vertexCount = vertexCount;\n  this.points = pointArray;\n  this.arcLength = arcLengthArray;\n\n  if ('dashes' in options) {\n    var dashArray = options.dashes; // Calculate prefix sum\n\n    var prefixSum = dashArray.slice();\n    prefixSum.unshift(0);\n\n    for (i = 1; i < prefixSum.length; ++i) {\n      prefixSum[i] = prefixSum[i - 1] + prefixSum[i];\n    }\n\n    var dashTexture = ndarray(new Array(256 * 4), [256, 1, 4]);\n\n    for (i = 0; i < 256; ++i) {\n      for (j = 0; j < 4; ++j) {\n        dashTexture.set(i, 0, j, 0);\n      }\n\n      if (bsearch.le(prefixSum, prefixSum[prefixSum.length - 1] * i / 255.0) & 1) {\n        dashTexture.set(i, 0, 0, 0);\n      } else {\n        dashTexture.set(i, 0, 0, 255);\n      }\n    }\n\n    this.texture.setPixels(dashTexture);\n  }\n};\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.vao.dispose();\n  this.buffer.dispose();\n};\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null;\n  }\n\n  if (selection.id !== this.pickId) {\n    return null;\n  }\n\n  var tau = unpackFloat(selection.value[0], selection.value[1], selection.value[2], 0);\n  var index = bsearch.le(this.arcLength, tau);\n\n  if (index < 0) {\n    return null;\n  }\n\n  if (index === this.arcLength.length - 1) {\n    return new PickResult(this.arcLength[this.arcLength.length - 1], this.points[this.points.length - 1].slice(), index);\n  }\n\n  var a = this.points[index];\n  var b = this.points[Math.min(index + 1, this.points.length - 1)];\n  var t = (tau - this.arcLength[index]) / (this.arcLength[index + 1] - this.arcLength[index]);\n  var ti = 1.0 - t;\n  var x = [0, 0, 0];\n\n  for (var i = 0; i < 3; ++i) {\n    x[i] = ti * a[i] + t * b[i];\n  }\n\n  var dataIndex = Math.min(t < 0.5 ? index : index + 1, this.points.length - 1);\n  return new PickResult(tau, x, dataIndex, this.points[dataIndex]);\n};\n\nfunction createLinePlot(options) {\n  var gl = options.gl || options.scene && options.scene.gl;\n  var shader = createShader(gl);\n  shader.attributes.position.location = 0;\n  shader.attributes.nextPosition.location = 1;\n  shader.attributes.arcLength.location = 2;\n  shader.attributes.lineWidth.location = 3;\n  shader.attributes.color.location = 4;\n  var pickShader = createPickShader(gl);\n  pickShader.attributes.position.location = 0;\n  pickShader.attributes.nextPosition.location = 1;\n  pickShader.attributes.arcLength.location = 2;\n  pickShader.attributes.lineWidth.location = 3;\n  pickShader.attributes.color.location = 4;\n  var buffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    'buffer': buffer,\n    'size': 3,\n    'offset': 0,\n    'stride': 48\n  }, {\n    'buffer': buffer,\n    'size': 3,\n    'offset': 12,\n    'stride': 48\n  }, {\n    'buffer': buffer,\n    'size': 1,\n    'offset': 24,\n    'stride': 48\n  }, {\n    'buffer': buffer,\n    'size': 1,\n    'offset': 28,\n    'stride': 48\n  }, {\n    'buffer': buffer,\n    'size': 4,\n    'offset': 32,\n    'stride': 48\n  }]); // Create texture for dash pattern\n\n  var defaultTexture = ndarray(new Array(256 * 4), [256, 1, 4]);\n\n  for (var i = 0; i < 256 * 4; ++i) {\n    defaultTexture.data[i] = 255;\n  }\n\n  var texture = createTexture(gl, defaultTexture);\n  texture.wrap = gl.REPEAT;\n  var linePlot = new LinePlot(gl, shader, pickShader, buffer, vao, texture);\n  linePlot.update(options);\n  return linePlot;\n}","map":null,"metadata":{},"sourceType":"script"}