{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\n\nvar orient = require('robust-orientation')[3];\n\nvar EVENT_POINT = 0;\nvar EVENT_END = 1;\nvar EVENT_START = 2;\nmodule.exports = monotoneTriangulate; //A partial convex hull fragment, made of two unimonotone polygons\n\nfunction PartialHull(a, b, idx, lowerIds, upperIds) {\n  this.a = a;\n  this.b = b;\n  this.idx = idx;\n  this.lowerIds = lowerIds;\n  this.upperIds = upperIds;\n} //An event in the sweep line procedure\n\n\nfunction Event(a, b, type, idx) {\n  this.a = a;\n  this.b = b;\n  this.type = type;\n  this.idx = idx;\n} //This is used to compare events for the sweep line procedure\n// Points are:\n//  1. sorted lexicographically\n//  2. sorted by type  (point < end < start)\n//  3. segments sorted by winding order\n//  4. sorted by index\n\n\nfunction compareEvent(a, b) {\n  var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;\n\n  if (d) {\n    return d;\n  }\n\n  if (a.type !== EVENT_POINT) {\n    d = orient(a.a, a.b, b.b);\n\n    if (d) {\n      return d;\n    }\n  }\n\n  return a.idx - b.idx;\n}\n\nfunction testPoint(hull, p) {\n  return orient(hull.a, hull.b, p);\n}\n\nfunction addPoint(cells, hulls, points, p, idx) {\n  var lo = bsearch.lt(hulls, p, testPoint);\n  var hi = bsearch.gt(hulls, p, testPoint);\n\n  for (var i = lo; i < hi; ++i) {\n    var hull = hulls[i]; //Insert p into lower hull\n\n    var lowerIds = hull.lowerIds;\n    var m = lowerIds.length;\n\n    while (m > 1 && orient(points[lowerIds[m - 2]], points[lowerIds[m - 1]], p) > 0) {\n      cells.push([lowerIds[m - 1], lowerIds[m - 2], idx]);\n      m -= 1;\n    }\n\n    lowerIds.length = m;\n    lowerIds.push(idx); //Insert p into upper hull\n\n    var upperIds = hull.upperIds;\n    var m = upperIds.length;\n\n    while (m > 1 && orient(points[upperIds[m - 2]], points[upperIds[m - 1]], p) < 0) {\n      cells.push([upperIds[m - 2], upperIds[m - 1], idx]);\n      m -= 1;\n    }\n\n    upperIds.length = m;\n    upperIds.push(idx);\n  }\n}\n\nfunction findSplit(hull, edge) {\n  var d;\n\n  if (hull.a[0] < edge.a[0]) {\n    d = orient(hull.a, hull.b, edge.a);\n  } else {\n    d = orient(edge.b, edge.a, hull.a);\n  }\n\n  if (d) {\n    return d;\n  }\n\n  if (edge.b[0] < hull.b[0]) {\n    d = orient(hull.a, hull.b, edge.b);\n  } else {\n    d = orient(edge.b, edge.a, hull.b);\n  }\n\n  return d || hull.idx - edge.idx;\n}\n\nfunction splitHulls(hulls, points, event) {\n  var splitIdx = bsearch.le(hulls, event, findSplit);\n  var hull = hulls[splitIdx];\n  var upperIds = hull.upperIds;\n  var x = upperIds[upperIds.length - 1];\n  hull.upperIds = [x];\n  hulls.splice(splitIdx + 1, 0, new PartialHull(event.a, event.b, event.idx, [x], upperIds));\n}\n\nfunction mergeHulls(hulls, points, event) {\n  //Swap pointers for merge search\n  var tmp = event.a;\n  event.a = event.b;\n  event.b = tmp;\n  var mergeIdx = bsearch.eq(hulls, event, findSplit);\n  var upper = hulls[mergeIdx];\n  var lower = hulls[mergeIdx - 1];\n  lower.upperIds = upper.upperIds;\n  hulls.splice(mergeIdx, 1);\n}\n\nfunction monotoneTriangulate(points, edges) {\n  var numPoints = points.length;\n  var numEdges = edges.length;\n  var events = []; //Create point events\n\n  for (var i = 0; i < numPoints; ++i) {\n    events.push(new Event(points[i], null, EVENT_POINT, i));\n  } //Create edge events\n\n\n  for (var i = 0; i < numEdges; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n\n    if (a[0] < b[0]) {\n      events.push(new Event(a, b, EVENT_START, i), new Event(b, a, EVENT_END, i));\n    } else if (a[0] > b[0]) {\n      events.push(new Event(b, a, EVENT_START, i), new Event(a, b, EVENT_END, i));\n    }\n  } //Sort events\n\n\n  events.sort(compareEvent); //Initialize hull\n\n  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);\n  var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])]; //Process events in order\n\n  var cells = [];\n\n  for (var i = 0, numEvents = events.length; i < numEvents; ++i) {\n    var event = events[i];\n    var type = event.type;\n\n    if (type === EVENT_POINT) {\n      addPoint(cells, hull, points, event.a, event.idx);\n    } else if (type === EVENT_START) {\n      splitHulls(hull, points, event);\n    } else {\n      mergeHulls(hull, points, event);\n    }\n  } //Return triangulation\n\n\n  return cells;\n}","map":null,"metadata":{},"sourceType":"script"}