{"ast":null,"code":"var lerp = require('gl-vec3/lerp');\n\nvar recompose = require('mat4-recompose');\n\nvar decompose = require('mat4-decompose');\n\nvar determinant = require('gl-mat4/determinant');\n\nvar slerp = require('quat-slerp');\n\nvar state0 = state();\nvar state1 = state();\nvar tmp = state();\nmodule.exports = interpolate;\n\nfunction interpolate(out, start, end, alpha) {\n  if (determinant(start) === 0 || determinant(end) === 0) return false; //decompose the start and end matrices into individual components\n\n  var r0 = decompose(start, state0.translate, state0.scale, state0.skew, state0.perspective, state0.quaternion);\n  var r1 = decompose(end, state1.translate, state1.scale, state1.skew, state1.perspective, state1.quaternion);\n  if (!r0 || !r1) return false; //now lerp/slerp the start and end components into a temporary     lerp(tmptranslate, state0.translate, state1.translate, alpha)\n\n  lerp(tmp.translate, state0.translate, state1.translate, alpha);\n  lerp(tmp.skew, state0.skew, state1.skew, alpha);\n  lerp(tmp.scale, state0.scale, state1.scale, alpha);\n  lerp(tmp.perspective, state0.perspective, state1.perspective, alpha);\n  slerp(tmp.quaternion, state0.quaternion, state1.quaternion, alpha); //and recompose into our 'out' matrix\n\n  recompose(out, tmp.translate, tmp.scale, tmp.skew, tmp.perspective, tmp.quaternion);\n  return true;\n}\n\nfunction state() {\n  return {\n    translate: vec3(),\n    scale: vec3(1),\n    skew: vec3(),\n    perspective: vec4(),\n    quaternion: vec4()\n  };\n}\n\nfunction vec3(n) {\n  return [n || 0, n || 0, n || 0];\n}\n\nfunction vec4() {\n  return [0, 0, 0, 1];\n}","map":null,"metadata":{},"sourceType":"script"}