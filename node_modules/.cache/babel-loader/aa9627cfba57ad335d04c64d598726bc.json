{"ast":null,"code":"\"use strict\";\n\nmodule.exports = createTextSprites;\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar vectorizeText = require('vectorize-text');\n\nvar createShader = require('./shaders').text;\n\nvar globals = window || process.global || {};\n\nvar __TEXT_CACHE = globals.__TEXT_CACHE || {};\n\nglobals.__TEXT_CACHE = {}; //Vertex buffer format for text is:\n//\n/// [x,y,z] = Spatial coordinate\n//\n\nvar VERTEX_SIZE = 3;\n\nfunction TextSprites(gl, shader, buffer, vao) {\n  this.gl = gl;\n  this.shader = shader;\n  this.buffer = buffer;\n  this.vao = vao;\n  this.tickOffset = this.tickCount = this.labelOffset = this.labelCount = null;\n}\n\nvar proto = TextSprites.prototype; //Bind textures for rendering\n\nvar SHAPE = [0, 0];\n\nproto.bind = function (model, view, projection, pixelScale) {\n  this.vao.bind();\n  this.shader.bind();\n  var uniforms = this.shader.uniforms;\n  uniforms.model = model;\n  uniforms.view = view;\n  uniforms.projection = projection;\n  uniforms.pixelScale = pixelScale;\n  SHAPE[0] = this.gl.drawingBufferWidth;\n  SHAPE[1] = this.gl.drawingBufferHeight;\n  this.shader.uniforms.resolution = SHAPE;\n};\n\nproto.unbind = function () {\n  this.vao.unbind();\n};\n\nproto.update = function (bounds, labels, labelFont, ticks, tickFont) {\n  var data = [];\n\n  function addItem(t, text, font, size, lineSpacing, styletags) {\n    var fontcache = __TEXT_CACHE[font];\n\n    if (!fontcache) {\n      fontcache = __TEXT_CACHE[font] = {};\n    }\n\n    var mesh = fontcache[text];\n\n    if (!mesh) {\n      mesh = fontcache[text] = tryVectorizeText(text, {\n        triangles: true,\n        font: font,\n        textAlign: 'center',\n        textBaseline: 'middle',\n        lineSpacing: lineSpacing,\n        styletags: styletags\n      });\n    }\n\n    var scale = (size || 12) / 12;\n    var positions = mesh.positions;\n    var cells = mesh.cells;\n\n    for (var i = 0, nc = cells.length; i < nc; ++i) {\n      var c = cells[i];\n\n      for (var j = 2; j >= 0; --j) {\n        var p = positions[c[j]];\n        data.push(scale * p[0], -scale * p[1], t);\n      }\n    }\n  } //Generate sprites for all 3 axes, store data in texture atlases\n\n\n  var tickOffset = [0, 0, 0];\n  var tickCount = [0, 0, 0];\n  var labelOffset = [0, 0, 0];\n  var labelCount = [0, 0, 0];\n  var lineSpacing = 1.25;\n  var styletags = {\n    breaklines: true,\n    bolds: true,\n    italics: true,\n    subscripts: true,\n    superscripts: true\n  };\n\n  for (var d = 0; d < 3; ++d) {\n    //Generate label\n    labelOffset[d] = data.length / VERTEX_SIZE | 0;\n    addItem(0.5 * (bounds[0][d] + bounds[1][d]), labels[d], labelFont[d], 12, // labelFontSize\n    lineSpacing, styletags);\n    labelCount[d] = (data.length / VERTEX_SIZE | 0) - labelOffset[d]; //Generate sprites for tick marks\n\n    tickOffset[d] = data.length / VERTEX_SIZE | 0;\n\n    for (var i = 0; i < ticks[d].length; ++i) {\n      if (!ticks[d][i].text) {\n        continue;\n      }\n\n      addItem(ticks[d][i].x, ticks[d][i].text, ticks[d][i].font || tickFont, ticks[d][i].fontSize || 12, lineSpacing, styletags);\n    }\n\n    tickCount[d] = (data.length / VERTEX_SIZE | 0) - tickOffset[d];\n  }\n\n  this.buffer.update(data);\n  this.tickOffset = tickOffset;\n  this.tickCount = tickCount;\n  this.labelOffset = labelOffset;\n  this.labelCount = labelCount;\n}; //Draws the tick marks for an axis\n\n\nproto.drawTicks = function (d, scale, angle, offset, color, axis, alignDir, alignOpt) {\n  if (!this.tickCount[d]) {\n    return;\n  }\n\n  this.shader.uniforms.axis = axis;\n  this.shader.uniforms.color = color;\n  this.shader.uniforms.angle = angle;\n  this.shader.uniforms.scale = scale;\n  this.shader.uniforms.offset = offset;\n  this.shader.uniforms.alignDir = alignDir;\n  this.shader.uniforms.alignOpt = alignOpt;\n  this.vao.draw(this.gl.TRIANGLES, this.tickCount[d], this.tickOffset[d]);\n}; //Draws the text label for an axis\n\n\nproto.drawLabel = function (d, scale, angle, offset, color, axis, alignDir, alignOpt) {\n  if (!this.labelCount[d]) {\n    return;\n  }\n\n  this.shader.uniforms.axis = axis;\n  this.shader.uniforms.color = color;\n  this.shader.uniforms.angle = angle;\n  this.shader.uniforms.scale = scale;\n  this.shader.uniforms.offset = offset;\n  this.shader.uniforms.alignDir = alignDir;\n  this.shader.uniforms.alignOpt = alignOpt;\n  this.vao.draw(this.gl.TRIANGLES, this.labelCount[d], this.labelOffset[d]);\n}; //Releases all resources attached to this object\n\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.vao.dispose();\n  this.buffer.dispose();\n};\n\nfunction tryVectorizeText(text, options) {\n  try {\n    return vectorizeText(text, options);\n  } catch (e) {\n    console.warn('error vectorizing text:\"' + text + '\" error:', e);\n    return {\n      cells: [],\n      positions: []\n    };\n  }\n}\n\nfunction createTextSprites(gl, bounds, labels, labelFont, ticks, tickFont) {\n  var buffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    \"buffer\": buffer,\n    \"size\": 3\n  }]);\n  var shader = createShader(gl);\n  shader.attributes.position.location = 0;\n  var result = new TextSprites(gl, shader, buffer, vao);\n  result.update(bounds, labels, labelFont, ticks, tickFont);\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}