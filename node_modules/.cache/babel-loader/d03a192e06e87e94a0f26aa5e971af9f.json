{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar attributes = require('./attributes');\n\nvar attributeTextFont = attributes.textfont;\nvar attributeInsideTextFont = attributes.insidetextfont;\nvar attributeOutsideTextFont = attributes.outsidetextfont;\n\nvar helpers = require('./helpers');\n\nfunction style(gd) {\n  var s = d3.select(gd).selectAll('g.barlayer').selectAll('g.trace');\n  var barcount = s.size();\n  var fullLayout = gd._fullLayout; // trace styling\n\n  s.style('opacity', function (d) {\n    return d[0].trace.opacity;\n  }) // for gapless (either stacked or neighboring grouped) bars use\n  // crispEdges to turn off antialiasing so an artificial gap\n  // isn't introduced.\n  .each(function (d) {\n    if (fullLayout.barmode === 'stack' && barcount > 1 || fullLayout.bargap === 0 && fullLayout.bargroupgap === 0 && !d[0].trace.marker.line.width) {\n      d3.select(this).attr('shape-rendering', 'crispEdges');\n    }\n  });\n  s.selectAll('g.points').each(function (d) {\n    var sel = d3.select(this);\n    var trace = d[0].trace;\n    stylePoints(sel, trace, gd);\n  });\n  Registry.getComponentMethod('errorbars', 'style')(s);\n}\n\nfunction stylePoints(sel, trace, gd) {\n  Drawing.pointStyle(sel.selectAll('path'), trace, gd);\n  styleTextPoints(sel, trace, gd);\n}\n\nfunction styleTextPoints(sel, trace, gd) {\n  sel.selectAll('text').each(function (d) {\n    var tx = d3.select(this);\n    var font = determineFont(tx, d, trace, gd);\n    Drawing.font(tx, font);\n  });\n}\n\nfunction styleOnSelect(gd, cd, sel) {\n  var trace = cd[0].trace;\n\n  if (trace.selectedpoints) {\n    stylePointsInSelectionMode(sel, trace, gd);\n  } else {\n    stylePoints(sel, trace, gd);\n    Registry.getComponentMethod('errorbars', 'style')(sel);\n  }\n}\n\nfunction stylePointsInSelectionMode(s, trace, gd) {\n  Drawing.selectedPointStyle(s.selectAll('path'), trace);\n  styleTextInSelectionMode(s.selectAll('text'), trace, gd);\n}\n\nfunction styleTextInSelectionMode(txs, trace, gd) {\n  txs.each(function (d) {\n    var tx = d3.select(this);\n    var font;\n\n    if (d.selected) {\n      font = Lib.extendFlat({}, determineFont(tx, d, trace, gd));\n      var selectedFontColor = trace.selected.textfont && trace.selected.textfont.color;\n\n      if (selectedFontColor) {\n        font.color = selectedFontColor;\n      }\n\n      Drawing.font(tx, font);\n    } else {\n      Drawing.selectedTextStyle(tx, trace);\n    }\n  });\n}\n\nfunction determineFont(tx, d, trace, gd) {\n  var layoutFont = gd._fullLayout.font;\n  var textFont = trace.textfont;\n\n  if (tx.classed('bartext-inside')) {\n    var barColor = getBarColor(d, trace);\n    textFont = getInsideTextFont(trace, d.i, layoutFont, barColor);\n  } else if (tx.classed('bartext-outside')) {\n    textFont = getOutsideTextFont(trace, d.i, layoutFont);\n  }\n\n  return textFont;\n}\n\nfunction getTextFont(trace, index, defaultValue) {\n  return getFontValue(attributeTextFont, trace.textfont, index, defaultValue);\n}\n\nfunction getInsideTextFont(trace, index, layoutFont, barColor) {\n  var defaultFont = getTextFont(trace, index, layoutFont);\n  var wouldFallBackToLayoutFont = trace._input.textfont === undefined || trace._input.textfont.color === undefined || Array.isArray(trace.textfont.color) && trace.textfont.color[index] === undefined;\n\n  if (wouldFallBackToLayoutFont) {\n    defaultFont = {\n      color: Color.contrast(barColor),\n      family: defaultFont.family,\n      size: defaultFont.size\n    };\n  }\n\n  return getFontValue(attributeInsideTextFont, trace.insidetextfont, index, defaultFont);\n}\n\nfunction getOutsideTextFont(trace, index, layoutFont) {\n  var defaultFont = getTextFont(trace, index, layoutFont);\n  return getFontValue(attributeOutsideTextFont, trace.outsidetextfont, index, defaultFont);\n}\n\nfunction getFontValue(attributeDefinition, attributeValue, index, defaultValue) {\n  attributeValue = attributeValue || {};\n  var familyValue = helpers.getValue(attributeValue.family, index);\n  var sizeValue = helpers.getValue(attributeValue.size, index);\n  var colorValue = helpers.getValue(attributeValue.color, index);\n  return {\n    family: helpers.coerceString(attributeDefinition.family, familyValue, defaultValue.family),\n    size: helpers.coerceNumber(attributeDefinition.size, sizeValue, defaultValue.size),\n    color: helpers.coerceColor(attributeDefinition.color, colorValue, defaultValue.color)\n  };\n}\n\nfunction getBarColor(cd, trace) {\n  if (trace.type === 'waterfall') {\n    return trace[cd.dir].marker.color;\n  }\n\n  return cd.mc || trace.marker.color;\n}\n\nmodule.exports = {\n  style: style,\n  styleTextPoints: styleTextPoints,\n  styleOnSelect: styleOnSelect,\n  getInsideTextFont: getInsideTextFont,\n  getOutsideTextFont: getOutsideTextFont,\n  getBarColor: getBarColor\n};","map":null,"metadata":{},"sourceType":"script"}