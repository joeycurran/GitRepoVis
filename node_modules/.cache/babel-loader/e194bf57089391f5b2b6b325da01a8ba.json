{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar hasTransition = require('../sunburst/helpers').hasTransition;\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\n\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar toMoveInsideBar = require('../bar/plot').toMoveInsideBar;\n\nvar constants = require('./constants');\n\nvar drawDescendants = require('./draw_descendants');\n\nvar drawAncestors = require('./draw_ancestors');\n\nmodule.exports = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._treemaplayer;\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  join = layer.selectAll('g.trace.treemap').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  });\n  join.enter().append('g').classed('trace', true).classed('treemap', true);\n  join.order();\n\n  if (hasTransition(transitionOpts)) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\n\nfunction getKey(pt) {\n  return helpers.isHierarchyRoot(pt) ? '' : // don't use the dummyId\n  helpers.getPtId(pt);\n}\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var gTrace = d3.select(element);\n  var selAncestors = gTrace.selectAll('g.pathbar');\n  var selDescendants = gTrace.selectAll('g.slice');\n\n  if (!entry) {\n    selAncestors.remove();\n    selDescendants.remove();\n    return;\n  }\n\n  var isRoot = helpers.isHierarchyRoot(entry);\n  var hasTransition = helpers.hasTransition(transitionOpts);\n  var maxDepth = helpers.getMaxDepth(trace);\n\n  var hasVisibleDepth = function (pt) {\n    return pt.data.depth - entry.data.depth < maxDepth;\n  };\n\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var barW = vpw;\n  var barH = trace.pathbar.thickness;\n  var barPad = trace.marker.line.width + constants.gapWithPathbar;\n  var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n  var pathbarOrigin = {\n    x0: barW,\n    // slide to the right\n    x1: barW,\n    y0: barDifY,\n    y1: barDifY + barH\n  };\n\n  var findClosestEdge = function (pt, ref, size) {\n    var e = trace.tiling.pad;\n\n    var isLeftOfRect = function (x) {\n      return x - e <= ref.x0;\n    };\n\n    var isRightOfRect = function (x) {\n      return x + e >= ref.x1;\n    };\n\n    var isBottomOfRect = function (y) {\n      return y - e <= ref.y0;\n    };\n\n    var isTopOfRect = function (y) {\n      return y + e >= ref.y1;\n    };\n\n    return {\n      x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n      x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n      y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n      y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n    };\n  }; // stash of 'previous' position data used by tweening functions\n\n\n  var prevEntry = null;\n  var prevLookupPathbar = {};\n  var prevLookupSlices = {};\n  var nextOfPrevEntry = null;\n\n  var getPrev = function (pt, onPathbar) {\n    return onPathbar ? prevLookupPathbar[getKey(pt)] : prevLookupSlices[getKey(pt)];\n  };\n\n  var getOrigin = function (pt, onPathbar, refRect, size) {\n    if (onPathbar) {\n      return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n    } else {\n      var ref = prevLookupSlices[trace.level] || refRect;\n\n      if (hasVisibleDepth(pt)) {\n        // case of an empty object - happens when maxdepth is set\n        return findClosestEdge(pt, ref, size);\n      }\n    }\n\n    return {};\n  }; // N.B. handle multiple-root special case\n\n\n  if (cd0.hasMultipleRoots && isRoot) {\n    maxDepth++;\n  }\n\n  trace._maxDepth = maxDepth;\n  trace._backgroundColor = fullLayout.paper_bgcolor;\n  trace._entryDepth = entry.data.depth;\n  trace._atRootLevel = isRoot;\n  var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n  var viewMapX = function (x) {\n    return cenX + x;\n  };\n\n  var viewMapY = function (y) {\n    return cenY + y;\n  };\n\n  var barY0 = viewMapY(0);\n  var barX0 = viewMapX(0);\n\n  var viewBarX = function (x) {\n    return barX0 + x;\n  };\n\n  var viewBarY = function (y) {\n    return barY0 + y;\n  };\n\n  function pos(x, y) {\n    return x + ',' + y;\n  }\n\n  var xStart = viewBarX(0);\n\n  var limitX0 = function (p) {\n    p.x = Math.max(xStart, p.x);\n  };\n\n  var edgeshape = trace.pathbar.edgeshape; // pathbar(directory) path generation fn\n\n  var pathAncestor = function (d) {\n    var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n\n    var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n\n    var _y0 = viewBarY(d.y0);\n\n    var _y1 = viewBarY(d.y1);\n\n    var halfH = barH / 2;\n    var pL = {};\n    var pR = {};\n    pL.x = _x0;\n    pR.x = _x1;\n    pL.y = pR.y = (_y0 + _y1) / 2;\n    var pA = {\n      x: _x0,\n      y: _y0\n    };\n    var pB = {\n      x: _x1,\n      y: _y0\n    };\n    var pC = {\n      x: _x1,\n      y: _y1\n    };\n    var pD = {\n      x: _x0,\n      y: _y1\n    };\n\n    if (edgeshape === '>') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pC.x -= halfH;\n      pD.x -= halfH;\n    } else if (edgeshape === '/') {\n      pC.x -= halfH;\n      pD.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '\\\\') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '<') {\n      pL.x -= halfH;\n      pR.x -= halfH;\n    }\n\n    limitX0(pA);\n    limitX0(pD);\n    limitX0(pL);\n    limitX0(pB);\n    limitX0(pC);\n    limitX0(pR);\n    return 'M' + pos(pA.x, pA.y) + 'L' + pos(pB.x, pB.y) + 'L' + pos(pR.x, pR.y) + 'L' + pos(pC.x, pC.y) + 'L' + pos(pD.x, pD.y) + 'L' + pos(pL.x, pL.y) + 'Z';\n  }; // slice path generation fn\n\n\n  var pathDescendant = function (d) {\n    var _x0 = viewMapX(d.x0);\n\n    var _x1 = viewMapX(d.x1);\n\n    var _y0 = viewMapY(d.y0);\n\n    var _y1 = viewMapY(d.y1);\n\n    var dx = _x1 - _x0;\n    var dy = _y1 - _y0;\n    if (!dx || !dy) return '';\n    var FILLET = 0; // TODO: may expose this constant\n\n    var r = dx > 2 * FILLET && dy > 2 * FILLET ? FILLET : 0;\n\n    var arc = function (rx, ry) {\n      return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : '';\n    };\n\n    return 'M' + pos(_x0, _y0 + r) + arc(r, -r) + 'L' + pos(_x1 - r, _y0) + arc(r, r) + 'L' + pos(_x1, _y1 - r) + arc(-r, r) + 'L' + pos(_x0 + r, _y1) + arc(-r, -r) + 'Z';\n  };\n\n  var toMoveInsideSlice = function (pt, opts) {\n    var x0 = pt.x0;\n    var x1 = pt.x1;\n    var y0 = pt.y0;\n    var y1 = pt.y1;\n    var textBB = pt.textBB;\n\n    if (x0 === x1) {\n      x0 -= TEXTPAD;\n      x1 += TEXTPAD;\n    }\n\n    if (y0 === y1) {\n      y0 -= TEXTPAD;\n      y1 += TEXTPAD;\n    }\n\n    var hasFlag = function (f) {\n      return trace.textposition.indexOf(f) !== -1;\n    };\n\n    var hasBottom = hasFlag('bottom');\n    var hasTop = hasFlag('top') || opts.isHeader && !hasBottom;\n    var anchor = hasTop ? 'start' : hasBottom ? 'end' : 'middle';\n    var hasRight = hasFlag('right');\n    var hasLeft = hasFlag('left') || opts.onPathbar;\n    var offsetDir = hasLeft ? 'left' : hasRight ? 'right' : 'center';\n\n    if (opts.onPathbar || !opts.isHeader) {\n      x0 += hasLeft ? TEXTPAD : 0;\n      x1 -= hasRight ? TEXTPAD : 0;\n    }\n\n    var pad = trace.marker.pad;\n\n    if (opts.isHeader) {\n      x0 += pad.l - TEXTPAD;\n      x1 -= pad.r - TEXTPAD;\n\n      if (x0 >= x1) {\n        var mid = (x0 + x1) / 2;\n        x0 = mid - TEXTPAD;\n        x1 = mid + TEXTPAD;\n      } // limit the drawing area for headers\n\n\n      var limY;\n\n      if (hasBottom) {\n        limY = y1 - pad.b;\n        if (y0 < limY && limY < y1) y0 = limY;\n      } else {\n        limY = y0 + pad.t;\n        if (y0 < limY && limY < y1) y1 = limY;\n      }\n    } // position the text relative to the slice\n\n\n    var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: false,\n      constrained: true,\n      angle: 0,\n      anchor: anchor\n    });\n\n    if (offsetDir !== 'center') {\n      var deltaX = (x1 - x0) / 2 - transform.scale * (textBB.right - textBB.left) / 2;\n      if (opts.isHeader) deltaX -= TEXTPAD;\n      if (offsetDir === 'left') transform.targetX -= deltaX;else if (offsetDir === 'right') transform.targetX += deltaX;\n    }\n\n    transform.targetX = viewMapX(transform.targetX);\n    transform.targetY = viewMapY(transform.targetY);\n\n    if (isNaN(transform.targetX) || isNaN(transform.targetY)) {\n      return {};\n    }\n\n    return {\n      scale: transform.scale,\n      rotate: transform.rotate,\n      textX: transform.textX,\n      textY: transform.textY,\n      targetX: transform.targetX,\n      targetY: transform.targetY\n    };\n  };\n\n  var interpFromParent = function (pt, onPathbar) {\n    var parentPrev;\n    var i = 0;\n    var Q = pt;\n\n    while (!parentPrev && i < maxDepth) {\n      // loop to find a parent/grandParent on the previous graph\n      i++;\n      Q = Q.parent;\n\n      if (Q) {\n        parentPrev = getPrev(Q, onPathbar);\n      } else i = maxDepth;\n    }\n\n    return parentPrev || {};\n  };\n\n  var makeExitSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev = getPrev(pt, onPathbar);\n    var next;\n\n    if (onPathbar) {\n      next = pathbarOrigin;\n    } else {\n      var entryPrev = getPrev(entry, onPathbar);\n\n      if (entryPrev) {\n        // 'entryPrev' is here has the previous coordinates of the entry\n        // node, which corresponds to the last \"clicked\" node when zooming in\n        next = findClosestEdge(pt, entryPrev, size);\n      } else {\n        // this happens when maxdepth is set, when leaves must\n        // be removed and the entry is new (i.e. does not have a 'prev' object)\n        next = {};\n      }\n    }\n\n    return d3.interpolate(prev, next);\n  };\n\n  var makeUpdateSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev;\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (onPathbar) {\n        prev = pathbarOrigin;\n      } else {\n        if (prevEntry) {\n          // if trace was visible before\n          if (pt.parent) {\n            var ref = nextOfPrevEntry || refRect;\n\n            if (ref && !onPathbar) {\n              prev = findClosestEdge(pt, ref, size);\n            } else {\n              // if new leaf (when maxdepth is set),\n              // grow it from its parent node\n              prev = {};\n              Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n          } else {\n            prev = pt;\n          }\n        } else {\n          prev = {};\n        }\n      }\n    }\n\n    return d3.interpolate(prev, {\n      x0: pt.x0,\n      x1: pt.x1,\n      y0: pt.y0,\n      y1: pt.y1\n    });\n  };\n\n  var makeUpdateTextInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev = {};\n    var origin = getOrigin(pt, onPathbar, refRect, size);\n    Lib.extendFlat(prev, {\n      transform: toMoveInsideSlice({\n        x0: origin.x0,\n        x1: origin.x1,\n        y0: origin.y0,\n        y1: origin.y1,\n        textBB: pt.textBB,\n        _text: pt._text\n      }, {\n        isHeader: helpers.isHeader(pt, trace)\n      })\n    });\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (pt.parent) {\n        Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n      }\n    }\n\n    return d3.interpolate(prev, {\n      transform: {\n        scale: pt.transform.scale,\n        rotate: pt.transform.rotate,\n        textX: pt.transform.textX,\n        textY: pt.transform.textY,\n        targetX: pt.transform.targetX,\n        targetY: pt.transform.targetY\n      }\n    });\n  };\n\n  var handleSlicesExit = function (slices, onPathbar, refRect, size, pathSlice) {\n    var width = size[0];\n    var height = size[1];\n\n    if (hasTransition) {\n      slices.exit().transition().each(function () {\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.select('path.surface');\n        slicePath.transition().attrTween('d', function (pt2) {\n          var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n          return function (t) {\n            return pathSlice(interp(t));\n          };\n        });\n        var sliceTextGroup = sliceTop.select('g.slicetext');\n        sliceTextGroup.attr('opacity', 0);\n      }).remove();\n    } else {\n      slices.exit().remove();\n    }\n  };\n\n  var strTransform = function (d) {\n    return Lib.getTextTransform({\n      textX: d.transform.textX,\n      textY: d.transform.textY,\n      targetX: d.transform.targetX,\n      targetY: d.transform.targetY,\n      scale: d.transform.scale,\n      rotate: d.transform.rotate\n    });\n  };\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    selAncestors.each(function (pt) {\n      prevLookupPathbar[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupPathbar[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n    });\n    selDescendants.each(function (pt) {\n      prevLookupSlices[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupSlices[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n\n  nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n    width: vpw,\n    height: vph,\n    viewX: viewMapX,\n    viewY: viewMapY,\n    pathSlice: pathDescendant,\n    toMoveInsideSlice: toMoveInsideSlice,\n    prevEntry: prevEntry,\n    makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n    makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n    handleSlicesExit: handleSlicesExit,\n    hasTransition: hasTransition,\n    strTransform: strTransform\n  });\n\n  if (trace.pathbar.visible) {\n    drawAncestors(gd, cd, entry, selAncestors, {\n      barDifY: barDifY,\n      width: barW,\n      height: barH,\n      viewX: viewBarX,\n      viewY: viewBarY,\n      pathSlice: pathAncestor,\n      toMoveInsideSlice: toMoveInsideSlice,\n      makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n      makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n      handleSlicesExit: handleSlicesExit,\n      hasTransition: hasTransition,\n      strTransform: strTransform\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}