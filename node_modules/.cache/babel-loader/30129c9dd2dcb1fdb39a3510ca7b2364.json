{"ast":null,"code":"\"use strict\";\n\nmodule.exports = simplifyPolygon;\n\nvar orient = require(\"robust-orientation\");\n\nvar sc = require(\"simplicial-complex\");\n\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b));\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n  return area / perim;\n}\n\nfunction simplifyPolygon(cells, positions, minArea) {\n  var n = positions.length;\n  var nc = cells.length;\n  var inv = new Array(n);\n  var outv = new Array(n);\n  var weights = new Array(n);\n  var dead = new Array(n); //Initialize tables\n\n  for (var i = 0; i < n; ++i) {\n    inv[i] = outv[i] = -1;\n    weights[i] = Infinity;\n    dead[i] = false;\n  } //Compute neighbors\n\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    if (c.length !== 2) {\n      throw new Error(\"Input must be a graph\");\n    }\n\n    var s = c[1];\n    var t = c[0];\n\n    if (outv[t] !== -1) {\n      outv[t] = -2;\n    } else {\n      outv[t] = s;\n    }\n\n    if (inv[s] !== -1) {\n      inv[s] = -2;\n    } else {\n      inv[s] = t;\n    }\n  } //Updates the weight for vertex i\n\n\n  function computeWeight(i) {\n    if (dead[i]) {\n      return Infinity;\n    } //TODO: Check that the line segment doesn't cross once simplified\n\n\n    var s = inv[i];\n    var t = outv[i];\n\n    if (s < 0 || t < 0) {\n      return Infinity;\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t]);\n    }\n  } //Swaps two nodes on the heap (i,j) are the index of the nodes\n\n\n  function heapSwap(i, j) {\n    var a = heap[i];\n    var b = heap[j];\n    heap[i] = b;\n    heap[j] = a;\n    index[a] = j;\n    index[b] = i;\n  } //Returns the weight of node i on the heap\n\n\n  function heapWeight(i) {\n    return weights[heap[i]];\n  }\n\n  function heapParent(i) {\n    if (i & 1) {\n      return i - 1 >> 1;\n    }\n\n    return (i >> 1) - 1;\n  } //Bubble element i down the heap\n\n\n  function heapDown(i) {\n    var w = heapWeight(i);\n\n    while (true) {\n      var tw = w;\n      var left = 2 * i + 1;\n      var right = 2 * (i + 1);\n      var next = i;\n\n      if (left < heapCount) {\n        var lw = heapWeight(left);\n\n        if (lw < tw) {\n          next = left;\n          tw = lw;\n        }\n      }\n\n      if (right < heapCount) {\n        var rw = heapWeight(right);\n\n        if (rw < tw) {\n          next = right;\n        }\n      }\n\n      if (next === i) {\n        return i;\n      }\n\n      heapSwap(i, next);\n      i = next;\n    }\n  } //Bubbles element i up the heap\n\n\n  function heapUp(i) {\n    var w = heapWeight(i);\n\n    while (i > 0) {\n      var parent = heapParent(i);\n\n      if (parent >= 0) {\n        var pw = heapWeight(parent);\n\n        if (w < pw) {\n          heapSwap(i, parent);\n          i = parent;\n          continue;\n        }\n      }\n\n      return i;\n    }\n  } //Pop minimum element\n\n\n  function heapPop() {\n    if (heapCount > 0) {\n      var head = heap[0];\n      heapSwap(0, heapCount - 1);\n      heapCount -= 1;\n      heapDown(0);\n      return head;\n    }\n\n    return -1;\n  } //Update heap item i\n\n\n  function heapUpdate(i, w) {\n    var a = heap[i];\n\n    if (weights[a] === w) {\n      return i;\n    }\n\n    weights[a] = -Infinity;\n    heapUp(i);\n    heapPop();\n    weights[a] = w;\n    heapCount += 1;\n    return heapUp(heapCount - 1);\n  } //Kills a vertex (assume vertex already removed from heap)\n\n\n  function kill(i) {\n    if (dead[i]) {\n      return;\n    } //Kill vertex\n\n\n    dead[i] = true; //Fixup topology\n\n    var s = inv[i];\n    var t = outv[i];\n\n    if (inv[t] >= 0) {\n      inv[t] = s;\n    }\n\n    if (outv[s] >= 0) {\n      outv[s] = t;\n    } //Update weights on s and t\n\n\n    if (index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s));\n    }\n\n    if (index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t));\n    }\n  } //Initialize weights and heap\n\n\n  var heap = [];\n  var index = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    var w = weights[i] = computeWeight(i);\n\n    if (w < Infinity) {\n      index[i] = heap.length;\n      heap.push(i);\n    } else {\n      index[i] = -1;\n    }\n  }\n\n  var heapCount = heap.length;\n\n  for (var i = heapCount >> 1; i >= 0; --i) {\n    heapDown(i);\n  } //Kill vertices\n\n\n  while (true) {\n    var hmin = heapPop();\n\n    if (hmin < 0 || weights[hmin] > minArea) {\n      break;\n    }\n\n    kill(hmin);\n  } //Build collapsed vertex table\n\n\n  var npositions = [];\n\n  for (var i = 0; i < n; ++i) {\n    if (!dead[i]) {\n      index[i] = npositions.length;\n      npositions.push(positions[i].slice());\n    }\n  }\n\n  var nv = npositions.length;\n\n  function tortoiseHare(seq, start) {\n    if (seq[start] < 0) {\n      return start;\n    }\n\n    var t = start;\n    var h = start;\n\n    do {\n      //Walk two steps with h\n      var nh = seq[h];\n\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n\n      h = nh;\n      nh = seq[h];\n\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n\n      h = nh; //Walk one step with t\n\n      t = seq[t];\n    } while (t !== h); //Compress cycles\n\n\n    for (var v = start; v !== h; v = seq[v]) {\n      seq[v] = h;\n    }\n\n    return h;\n  }\n\n  var ncells = [];\n  cells.forEach(function (c) {\n    var tin = tortoiseHare(inv, c[0]);\n    var tout = tortoiseHare(outv, c[1]);\n\n    if (tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin];\n      var cout = index[tout];\n\n      if (cin !== cout) {\n        ncells.push([cin, cout]);\n      }\n    }\n  }); //Normalize result\n\n  sc.unique(sc.normalize(ncells)); //Return final list of cells\n\n  return {\n    positions: npositions,\n    edges: ncells\n  };\n}","map":null,"metadata":{},"sourceType":"script"}