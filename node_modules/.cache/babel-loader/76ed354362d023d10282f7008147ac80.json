{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/joeycurran/Desktop/College/GitHub/GitRepoVis/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst createScatter = require('regl-scatter2d');\n\nconst pick = require('pick-by-alias');\n\nconst getBounds = require('array-bounds');\n\nconst raf = require('raf');\n\nconst arrRange = require('array-range');\n\nconst rect = require('parse-rect');\n\nconst flatten = require('flatten-vertex-data');\n\nmodule.exports = SPLOM; // @constructor\n\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options); // render passes\n\n  this.traces = []; // passes for scatter, combined across traces\n\n  this.passes = {};\n  this.regl = regl; // main scatter drawing instance\n\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n} // update & draw passes once per frame\n\n\nSPLOM.prototype.render = function (...args) {\n  if (args.length) {\n    this.update(...args);\n  }\n\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw(); // make sure draw is not called more often than once a frame\n\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(() => {\n        this.draw();\n        this.dirty = true;\n        this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(() => {\n      this.dirty = false;\n    });\n  }\n\n  return this;\n}; // update passes\n\n\nSPLOM.prototype.update = function (...args) {\n  if (!args.length) return;\n\n  for (let i = 0; i < args.length; i++) {\n    this.updateItem(i, args[i]);\n  } // remove nulled passes\n\n\n  this.traces = this.traces.filter(Boolean); // FIXME: update passes independently\n\n  let passes = [];\n  let offset = 0;\n\n  for (let i = 0; i < this.traces.length; i++) {\n    let trace = this.traces[i];\n    let tracePasses = this.traces[i].passes;\n\n    for (let j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    } // save offset of passes\n\n\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n\n  this.scatter.update(...passes);\n  return this;\n}; // update trace by index, not supposed to be called directly\n\n\nSPLOM.prototype.updateItem = function (i, options) {\n  let regl = this.regl; // remove pass if null\n\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n\n  if (!options) return this;\n  let o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  }); // we provide regl buffer per-trace, since trace data can be changed\n\n  let trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  }); // save styles\n\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower; // put flattened data into buffer\n\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length; // detect bounds per-column\n\n    trace.bounds = [];\n\n    for (let i = 0; i < trace.columns; i++) {\n      trace.bounds[i] = getBounds(o.data[i], 1);\n    }\n  } // add proper range updating markers\n\n\n  let multirange;\n\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n\n  let multipadding = false;\n\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    } // single padding\n    else {\n        trace.padding = getPad(o.padding);\n      }\n  } // create passes\n\n\n  let m = trace.columns;\n  let n = trace.count;\n  let w = trace.viewport.width;\n  let h = trace.viewport.height;\n  let left = trace.viewport.x;\n  let top = trace.viewport.y;\n  let iw = w / m;\n  let ih = h / m;\n  trace.passes = [];\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < m; j++) {\n      if (!trace.diagonal && j === i) continue;\n      if (!trace.upper && i > j) continue;\n      if (!trace.lower && i < j) continue;\n      let key = passId(trace.id, i, j);\n      let pass = this.passes[key] || (this.passes[key] = {});\n\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i * n,\n              count: n\n            }\n          };\n        }\n\n        pass.bounds = getBox(trace.bounds, i, j);\n      }\n\n      if (o.domain || o.viewport || o.data) {\n        let pad = multipadding ? getBox(trace.padding, i, j) : trace.padding;\n\n        if (trace.domain) {\n          let _getBox = getBox(trace.domain, i, j),\n              _getBox2 = _slicedToArray(_getBox, 4),\n              lox = _getBox2[0],\n              loy = _getBox2[1],\n              hix = _getBox2[2],\n              hiy = _getBox2[3];\n\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        } // consider auto-domain equipartial\n        else {\n            pass.viewport = [left + j * iw + iw * pad[0], top + i * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (i + 1) * ih - ih * pad[3]];\n          }\n      }\n\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds;\n      }\n\n      trace.passes.push(key);\n    }\n  }\n\n  return this;\n}; // draw all or passed passes\n\n\nSPLOM.prototype.draw = function (...args) {\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    let idx = [];\n\n    for (let i = 0; i < args.length; i++) {\n      // draw(0, 2, 5) - draw traces\n      if (typeof args[i] === 'number') {\n        let _this$traces$args$i = this.traces[args[i]],\n            passes = _this$traces$args$i.passes,\n            passOffset = _this$traces$args$i.passOffset;\n        idx.push(...arrRange(passOffset, passOffset + passes.length));\n      } // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n      else if (args[i].length) {\n          let els = args[i];\n          let _this$traces$i = this.traces[i],\n              passes = _this$traces$i.passes,\n              passOffset = _this$traces$i.passOffset;\n          passes = passes.map((passId, i) => {\n            idx[passOffset + i] = els;\n          });\n        }\n    }\n\n    this.scatter.draw(...idx);\n  }\n\n  return this;\n}; // dispose resources\n\n\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(trace => {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n}; // return pass corresponding to trace i- j- square\n\n\nfunction passId(trace, i, j) {\n  let id = trace.id != null ? trace.id : trace;\n  let n = i;\n  let m = j;\n  let key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n} // return bounding box corresponding to a pass\n\n\nfunction getBox(items, i, j) {\n  let ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  let iitem = items[i],\n      jitem = items[j];\n\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n\n  return [jlox, iloy, jhix, ihiy];\n}\n\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    let box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}