{"ast":null,"code":"'use strict';\n\nexports.create = defaultTicks;\nexports.equal = ticksEqual;\n\nfunction prettyPrint(spacing, i) {\n  var stepStr = spacing + \"\";\n  var u = stepStr.indexOf(\".\");\n  var sigFigs = 0;\n\n  if (u >= 0) {\n    sigFigs = stepStr.length - u - 1;\n  }\n\n  var shift = Math.pow(10, sigFigs);\n  var x = Math.round(spacing * i * shift);\n  var xstr = x + \"\";\n\n  if (xstr.indexOf(\"e\") >= 0) {\n    return xstr;\n  }\n\n  var xi = x / shift,\n      xf = x % shift;\n\n  if (x < 0) {\n    xi = -Math.ceil(xi) | 0;\n    xf = -xf | 0;\n  } else {\n    xi = Math.floor(xi) | 0;\n    xf = xf | 0;\n  }\n\n  var xis = \"\" + xi;\n\n  if (x < 0) {\n    xis = \"-\" + xis;\n  }\n\n  if (sigFigs) {\n    var xs = \"\" + xf;\n\n    while (xs.length < sigFigs) {\n      xs = \"0\" + xs;\n    }\n\n    return xis + \".\" + xs;\n  } else {\n    return xis;\n  }\n}\n\nfunction defaultTicks(bounds, tickSpacing) {\n  var array = [];\n\n  for (var d = 0; d < 3; ++d) {\n    var ticks = [];\n    var m = 0.5 * (bounds[0][d] + bounds[1][d]);\n\n    for (var t = 0; t * tickSpacing[d] <= bounds[1][d]; ++t) {\n      ticks.push({\n        x: t * tickSpacing[d],\n        text: prettyPrint(tickSpacing[d], t)\n      });\n    }\n\n    for (var t = -1; t * tickSpacing[d] >= bounds[0][d]; --t) {\n      ticks.push({\n        x: t * tickSpacing[d],\n        text: prettyPrint(tickSpacing[d], t)\n      });\n    }\n\n    array.push(ticks);\n  }\n\n  return array;\n}\n\nfunction ticksEqual(ticksA, ticksB) {\n  for (var i = 0; i < 3; ++i) {\n    if (ticksA[i].length !== ticksB[i].length) {\n      return false;\n    }\n\n    for (var j = 0; j < ticksA[i].length; ++j) {\n      var a = ticksA[i][j];\n      var b = ticksB[i][j];\n\n      if (a.x !== b.x || a.text !== b.text || a.font !== b.font || a.fontColor !== b.fontColor || a.fontSize !== b.fontSize || a.dx !== b.dx || a.dy !== b.dy) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"script"}