{"ast":null,"code":"\"use strict\";\n\nvar pool = require(\"typedarray-pool\");\n\nmodule.exports = createSurfaceExtractor; //Helper macros\n\nfunction array(i) {\n  return \"a\" + i;\n}\n\nfunction data(i) {\n  return \"d\" + i;\n}\n\nfunction cube(i, bitmask) {\n  return \"c\" + i + \"_\" + bitmask;\n}\n\nfunction shape(i) {\n  return \"s\" + i;\n}\n\nfunction stride(i, j) {\n  return \"t\" + i + \"_\" + j;\n}\n\nfunction offset(i) {\n  return \"o\" + i;\n}\n\nfunction scalar(i) {\n  return \"x\" + i;\n}\n\nfunction pointer(i) {\n  return \"p\" + i;\n}\n\nfunction delta(i, bitmask) {\n  return \"d\" + i + \"_\" + bitmask;\n}\n\nfunction index(i) {\n  return \"i\" + i;\n}\n\nfunction step(i, j) {\n  return \"u\" + i + \"_\" + j;\n}\n\nfunction pcube(bitmask) {\n  return \"b\" + bitmask;\n}\n\nfunction qcube(bitmask) {\n  return \"y\" + bitmask;\n}\n\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask;\n}\n\nfunction vert(i) {\n  return \"v\" + i;\n}\n\nvar VERTEX_IDS = \"V\";\nvar PHASES = \"P\";\nvar VERTEX_COUNT = \"N\";\nvar POOL_SIZE = \"Q\";\nvar POINTER = \"X\";\nvar TEMPORARY = \"T\";\n\nfunction permBitmask(dimension, mask, order) {\n  var r = 0;\n\n  for (var i = 0; i < dimension; ++i) {\n    if (mask & 1 << i) {\n      r |= 1 << order[i];\n    }\n  }\n\n  return r;\n} //Generates the surface procedure\n\n\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length;\n  var dimension = order.length;\n\n  if (dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\");\n  }\n\n  var funcName = \"extractContour\" + order.join(\"_\");\n  var code = [];\n  var vars = [];\n  var args = []; //Assemble arguments\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    args.push(array(i));\n  }\n\n  for (var i = 0; i < scalarArgs; ++i) {\n    args.push(scalar(i));\n  } //Shape\n\n\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\");\n  } //Data, stride, offset pointers\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\", offset(i) + \"=\" + array(i) + \".offset|0\");\n\n    for (var j = 0; j < dimension; ++j) {\n      vars.push(stride(i, j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\");\n    }\n  } //Pointer, delta and cube variables\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i));\n    vars.push(cube(i, 0));\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      var ptrStr = [];\n\n      for (var k = 0; k < dimension; ++k) {\n        if (j & 1 << k) {\n          ptrStr.push(\"-\" + stride(i, k));\n        }\n      }\n\n      vars.push(delta(i, j) + \"=(\" + ptrStr.join(\"\") + \")|0\");\n      vars.push(cube(i, j) + \"=0\");\n    }\n  } //Create step variables\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    for (var j = 0; j < dimension; ++j) {\n      var stepVal = [stride(i, order[j])];\n\n      if (j > 0) {\n        stepVal.push(stride(i, order[j - 1]) + \"*\" + shape(order[j - 1]));\n      }\n\n      vars.push(step(i, order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\");\n    }\n  } //Create index variables\n\n\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(index(i) + \"=0\");\n  } //Vertex count\n\n\n  vars.push(VERTEX_COUNT + \"=0\"); //Compute pool size, initialize pool step\n\n  var sizeVariable = [\"2\"];\n\n  for (var i = dimension - 2; i >= 0; --i) {\n    sizeVariable.push(shape(order[i]));\n  } //Previous phases and vertex_ids\n\n\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\", PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\", VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\", POINTER + \"=0\"); //Create cube variables for phases\n\n  vars.push(pcube(0) + \"=0\");\n\n  for (var j = 1; j < 1 << dimension; ++j) {\n    var cubeDelta = [];\n    var cubeStep = [];\n\n    for (var k = 0; k < dimension; ++k) {\n      if (j & 1 << k) {\n        if (cubeStep.length === 0) {\n          cubeDelta.push(\"1\");\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"));\n        }\n      }\n\n      cubeStep.push(shape(order[k]));\n    }\n\n    var signFlag = \"\";\n\n    if (cubeDelta[0].indexOf(shape(order[dimension - 2])) < 0) {\n      signFlag = \"-\";\n    }\n\n    var jperm = permBitmask(dimension, j, order);\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\", qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\", pcube(jperm) + \"=0\");\n  }\n\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\");\n\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\", index(order[i]), \"<\", shape(order[i]), \";\", \"++\", index(order[i]), \"){\");\n  }\n\n  function forLoopEnd(i) {\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n\n    code.push(\"}\");\n  }\n\n  function fillEmptySlice(k) {\n    for (var i = k - 1; i >= 0; --i) {\n      forLoopBegin(i, 0);\n    }\n\n    var phaseFuncArgs = [];\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\");\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\");\n      }\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\");\n\n    for (var i = 0; i < k; ++i) {\n      forLoopEnd(i);\n    }\n\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[k]), \";\");\n    }\n  }\n\n  function processGridCell(mask) {\n    //Read in local data\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        code.push(cube(i, 0), \"=\", data(i), \".get(\", pointer(i), \");\");\n      } else {\n        code.push(cube(i, 0), \"=\", data(i), \"[\", pointer(i), \"];\");\n      }\n    } //Read in phase\n\n\n    var phaseFuncArgs = [];\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i, 0));\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n\n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\"); //Read in other cube data\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\");\n    } //Check for boundary crossing\n\n\n    var vertexPredicate = [];\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\");\n    }\n\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\"); //Read in boundary data\n\n    var vertexArgs = [];\n\n    for (var i = 0; i < dimension; ++i) {\n      vertexArgs.push(index(i));\n    }\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      vertexArgs.push(cube(i, 0));\n\n      for (var j = 1; j < 1 << dimension; ++j) {\n        if (typesig[i]) {\n          code.push(cube(i, j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i, j), \");\");\n        } else {\n          code.push(cube(i, j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i, j), \"];\");\n        }\n\n        vertexArgs.push(cube(i, j));\n      }\n    }\n\n    for (var i = 0; i < 1 << dimension; ++i) {\n      vertexArgs.push(pcube(i));\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      vertexArgs.push(scalar(i));\n    } //Generate vertex\n\n\n    code.push(\"vertex(\", vertexArgs.join(), \");\", vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\"); //Check for face crossings\n\n    var base = (1 << dimension) - 1;\n    var corner = pcube(base);\n\n    for (var j = 0; j < dimension; ++j) {\n      if ((mask & ~(1 << j)) === 0) {\n        //Check face\n        var subset = base ^ 1 << j;\n        var edge = pcube(subset);\n        var faceArgs = [];\n\n        for (var k = subset; k > 0; k = k - 1 & subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\");\n        }\n\n        faceArgs.push(vert(0));\n\n        for (var k = 0; k < arrayArgs; ++k) {\n          if (j & 1) {\n            faceArgs.push(cube(k, base), cube(k, subset));\n          } else {\n            faceArgs.push(cube(k, subset), cube(k, base));\n          }\n        }\n\n        if (j & 1) {\n          faceArgs.push(corner, edge);\n        } else {\n          faceArgs.push(edge, corner);\n        }\n\n        for (var k = 0; k < scalarArgs; ++k) {\n          faceArgs.push(scalar(k));\n        }\n\n        code.push(\"if(\", corner, \"!==\", edge, \"){\", \"face(\", faceArgs.join(), \")}\");\n      }\n    } //Increment pointer, close off if statement\n\n\n    code.push(\"}\", POINTER, \"+=1;\");\n  }\n\n  function flip() {\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\", pdelta(j), \"=\", qcube(j), \";\", qcube(j), \"=\", TEMPORARY, \";\");\n    }\n  }\n\n  function createLoop(i, mask) {\n    if (i < 0) {\n      processGridCell(mask);\n      return;\n    }\n\n    fillEmptySlice(i);\n    code.push(\"if(\", shape(order[i]), \">0){\", index(order[i]), \"=1;\");\n    createLoop(i - 1, mask | 1 << order[i]);\n\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n\n    if (i === dimension - 1) {\n      code.push(POINTER, \"=0;\");\n      flip();\n    }\n\n    forLoopBegin(i, 2);\n    createLoop(i - 1, mask);\n\n    if (i === dimension - 1) {\n      code.push(\"if(\", index(order[dimension - 1]), \"&1){\", POINTER, \"=0;}\");\n      flip();\n    }\n\n    forLoopEnd(i);\n    code.push(\"}\");\n  }\n\n  createLoop(dimension - 1, 0); //Release scratch memory\n\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\"); //Compile and link procedure\n\n  var procedureCode = [\"'use strict';\", \"function \", funcName, \"(\", args.join(), \"){\", \"var \", vars.join(), \";\", code.join(\"\"), \"}\", \"return \", funcName].join(\"\");\n  var proc = new Function(\"vertex\", \"face\", \"phase\", \"mallocUint32\", \"freeUint32\", procedureCode);\n  return proc(vertexFunc, faceFunc, phaseFunc, pool.mallocUint32, pool.freeUint32);\n}\n\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg);\n  }\n\n  if (typeof args !== \"object\") {\n    error(\"Must specify arguments\");\n  }\n\n  var order = args.order;\n\n  if (!Array.isArray(order)) {\n    error(\"Must specify order\");\n  }\n\n  var arrays = args.arrayArguments || 1;\n\n  if (arrays < 1) {\n    error(\"Must have at least one array argument\");\n  }\n\n  var scalars = args.scalarArguments || 0;\n\n  if (scalars < 0) {\n    error(\"Scalar arg count must be > 0\");\n  }\n\n  if (typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\");\n  }\n\n  if (typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\");\n  }\n\n  if (typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\");\n  }\n\n  var getters = args.getters || [];\n  var typesig = new Array(arrays);\n\n  for (var i = 0; i < arrays; ++i) {\n    if (getters.indexOf(i) >= 0) {\n      typesig[i] = true;\n    } else {\n      typesig[i] = false;\n    }\n  }\n\n  return compileSurfaceProcedure(args.vertex, args.cell, args.phase, scalars, order, typesig);\n}","map":null,"metadata":{},"sourceType":"script"}