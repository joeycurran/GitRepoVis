{"ast":null,"code":"\"use strict\";\n\nvar ch = require(\"incremental-convex-hull\");\n\nvar uniq = require(\"uniq\");\n\nmodule.exports = triangulate;\n\nfunction LiftedPoint(p, i) {\n  this.point = p;\n  this.index = i;\n}\n\nfunction compareLifted(a, b) {\n  var ap = a.point;\n  var bp = b.point;\n  var d = ap.length;\n\n  for (var i = 0; i < d; ++i) {\n    var s = bp[i] - ap[i];\n\n    if (s) {\n      return s;\n    }\n  }\n\n  return 0;\n}\n\nfunction triangulate1D(n, points, includePointAtInfinity) {\n  if (n === 1) {\n    if (includePointAtInfinity) {\n      return [[-1, 0]];\n    } else {\n      return [];\n    }\n  }\n\n  var lifted = points.map(function (p, i) {\n    return [p[0], i];\n  });\n  lifted.sort(function (a, b) {\n    return a[0] - b[0];\n  });\n  var cells = new Array(n - 1);\n\n  for (var i = 1; i < n; ++i) {\n    var a = lifted[i - 1];\n    var b = lifted[i];\n    cells[i - 1] = [a[1], b[1]];\n  }\n\n  if (includePointAtInfinity) {\n    cells.push([-1, cells[0][1]], [cells[n - 1][1], -1]);\n  }\n\n  return cells;\n}\n\nfunction triangulate(points, includePointAtInfinity) {\n  var n = points.length;\n\n  if (n === 0) {\n    return [];\n  }\n\n  var d = points[0].length;\n\n  if (d < 1) {\n    return [];\n  } //Special case:  For 1D we can just sort the points\n\n\n  if (d === 1) {\n    return triangulate1D(n, points, includePointAtInfinity);\n  } //Lift points, sort\n\n\n  var lifted = new Array(n);\n  var upper = 1.0;\n\n  for (var i = 0; i < n; ++i) {\n    var p = points[i];\n    var x = new Array(d + 1);\n    var l = 0.0;\n\n    for (var j = 0; j < d; ++j) {\n      var v = p[j];\n      x[j] = v;\n      l += v * v;\n    }\n\n    x[d] = l;\n    lifted[i] = new LiftedPoint(x, i);\n    upper = Math.max(l, upper);\n  }\n\n  uniq(lifted, compareLifted); //Double points\n\n  n = lifted.length; //Create new list of points\n\n  var dpoints = new Array(n + d + 1);\n  var dindex = new Array(n + d + 1); //Add steiner points at top\n\n  var u = (d + 1) * (d + 1) * upper;\n  var y = new Array(d + 1);\n\n  for (var i = 0; i <= d; ++i) {\n    y[i] = 0.0;\n  }\n\n  y[d] = u;\n  dpoints[0] = y.slice();\n  dindex[0] = -1;\n\n  for (var i = 0; i <= d; ++i) {\n    var x = y.slice();\n    x[i] = 1;\n    dpoints[i + 1] = x;\n    dindex[i + 1] = -1;\n  } //Copy rest of the points over\n\n\n  for (var i = 0; i < n; ++i) {\n    var h = lifted[i];\n    dpoints[i + d + 1] = h.point;\n    dindex[i + d + 1] = h.index;\n  } //Construct convex hull\n\n\n  var hull = ch(dpoints, false);\n\n  if (includePointAtInfinity) {\n    hull = hull.filter(function (cell) {\n      var count = 0;\n\n      for (var j = 0; j <= d; ++j) {\n        var v = dindex[cell[j]];\n\n        if (v < 0) {\n          if (++count >= 2) {\n            return false;\n          }\n        }\n\n        cell[j] = v;\n      }\n\n      return true;\n    });\n  } else {\n    hull = hull.filter(function (cell) {\n      for (var i = 0; i <= d; ++i) {\n        var v = dindex[cell[i]];\n\n        if (v < 0) {\n          return false;\n        }\n\n        cell[i] = v;\n      }\n\n      return true;\n    });\n  }\n\n  if (d & 1) {\n    for (var i = 0; i < hull.length; ++i) {\n      var h = hull[i];\n      var x = h[0];\n      h[0] = h[1];\n      h[1] = x;\n    }\n  }\n\n  return hull;\n}","map":null,"metadata":{},"sourceType":"script"}