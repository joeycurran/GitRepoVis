{"ast":null,"code":"'use strict';\n\nmodule.exports = createSurfacePlot;\n\nvar bits = require('bit-twiddle');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar pool = require('typedarray-pool');\n\nvar colormap = require('colormap');\n\nvar ops = require('ndarray-ops');\n\nvar pack = require('ndarray-pack');\n\nvar ndarray = require('ndarray');\n\nvar surfaceNets = require('surface-nets');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar invert = require('gl-mat4/invert');\n\nvar bsearch = require('binary-search-bounds');\n\nvar gradient = require('ndarray-gradient');\n\nvar shaders = require('./lib/shaders');\n\nvar createShader = shaders.createShader;\nvar createContourShader = shaders.createContourShader;\nvar createPickShader = shaders.createPickShader;\nvar createPickContourShader = shaders.createPickContourShader;\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar QUAD = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 0], [0, 1]];\nvar PERMUTATIONS = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\n(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i];\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    p[u + 0] = 1;\n    p[v + 3] = 1;\n    p[i + 6] = 1;\n  }\n})();\n\nfunction SurfacePickResult(position, index, uv, level, dataCoordinate) {\n  this.position = position;\n  this.index = index;\n  this.uv = uv;\n  this.level = level;\n  this.dataCoordinate = dataCoordinate;\n}\n\nvar N_COLORS = 256;\n\nfunction genColormap(name) {\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c) {\n    return [c[0], c[1], c[2], 255 * c[3]];\n  })]);\n  ops.divseq(x, 255.0);\n  return x;\n}\n\nfunction SurfacePlot(gl, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {\n  this.gl = gl;\n  this.shape = shape;\n  this.bounds = bounds;\n  this.objectOffset = objectOffset;\n  this.intensityBounds = [];\n  this._shader = shader;\n  this._pickShader = pickShader;\n  this._coordinateBuffer = coordinates;\n  this._vao = vao;\n  this._colorMap = colorMap;\n  this._contourShader = contourShader;\n  this._contourPickShader = contourPickShader;\n  this._contourBuffer = contourBuffer;\n  this._contourVAO = contourVAO;\n  this._contourOffsets = [[], [], []];\n  this._contourCounts = [[], [], []];\n  this._vertexCount = 0;\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);\n  this._dynamicBuffer = dynamicBuffer;\n  this._dynamicVAO = dynamicVAO;\n  this._dynamicOffsets = [0, 0, 0];\n  this._dynamicCounts = [0, 0, 0];\n  this.contourWidth = [1, 1, 1];\n  this.contourLevels = [[1], [1], [1]];\n  this.contourTint = [0, 0, 0];\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];\n  this.showContour = true;\n  this.showSurface = true;\n  this.enableHighlight = [true, true, true];\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.highlightTint = [1, 1, 1];\n  this.highlightLevel = [-1, -1, -1]; // Dynamic contour options\n\n  this.enableDynamic = [true, true, true];\n  this.dynamicLevel = [NaN, NaN, NaN];\n  this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.dynamicTint = [1, 1, 1];\n  this.dynamicWidth = [1, 1, 1];\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.surfaceProject = [false, false, false];\n  this.contourProject = [[false, false, false], [false, false, false], [false, false, false]];\n  this.colorBounds = [false, false]; // Store xyz fields, need this for picking\n\n  this._field = [ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0])];\n  this.pickId = 1;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.snapToData = false;\n  this.pixelRatio = 1;\n  this.opacity = 1.0;\n  this.lightPosition = [10, 10000, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.vertexColor = 0;\n  this.dirty = true;\n}\n\nvar proto = SurfacePlot.prototype;\n\nproto.isTransparent = function () {\n  return this.opacity < 1;\n};\n\nproto.isOpaque = function () {\n  if (this.opacity >= 1) {\n    return true;\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    if (this._contourCounts[i].length > 0 || this._dynamicCounts[i] > 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nvar ZERO_VEC = [0, 0, 0];\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [[[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]]\n};\n\nfunction computeProjectionData(camera, obj) {\n  var i, j, k; // Compute cube properties\n\n  var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;\n  var showSurface = obj.showSurface;\n  var showContour = obj.showContour;\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i];\n\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j];\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i];\n\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0;\n    }\n\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1;\n    }\n\n    axisSquish[5 * i] = 0;\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];\n    multiply(axisSquish, camera.model, axisSquish);\n    var nclipBounds = PROJECT_DATA.clipBounds[i];\n\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j];\n      }\n    }\n\n    nclipBounds[0][i] = -1e8;\n    nclipBounds[1][i] = 1e8;\n  }\n\n  PROJECT_DATA.showSurface = showSurface;\n  PROJECT_DATA.showContour = showContour;\n  return PROJECT_DATA;\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n};\nvar MATRIX_INVERSE = IDENTITY.slice();\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\nfunction drawCore(params, transparent) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n\n  this._colorMap.bind(0);\n\n  var uniforms = UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.contourColor = this.contourColor[0];\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  uniforms.kambient = this.ambientLight;\n  uniforms.kdiffuse = this.diffuseLight;\n  uniforms.kspecular = this.specularLight;\n  uniforms.roughness = this.roughness;\n  uniforms.fresnel = this.fresnel;\n  uniforms.opacity = this.opacity;\n  uniforms.height = 0.0;\n  uniforms.permutation = DEFAULT_PERM;\n  uniforms.vertexColor = this.vertexColor; // Compute camera matrix inverse\n\n  var invCameraMatrix = MATRIX_INVERSE;\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n\n  var w = invCameraMatrix[15];\n\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n\n    uniforms.lightPosition[i] = s / w;\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface && transparent === this.opacity < 1) {\n    // Set up uniforms\n    this._shader.bind();\n\n    this._shader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue;\n      }\n\n      this._shader.uniforms.model = projectData.projections[i];\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour && !transparent) {\n    var shader = this._contourShader; // Don't apply lighting to contours\n\n    uniforms.kambient = 1.0;\n    uniforms.kdiffuse = 0.0;\n    uniforms.kspecular = 0.0;\n    uniforms.opacity = 1.0;\n    shader.bind();\n    shader.uniforms = uniforms; // Draw contour lines\n\n    var vao = this._contourVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio);\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i];\n          shader.uniforms.contourTint = this.highlightTint[i];\n        } else if (j === 0 || j - 1 === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i];\n          shader.uniforms.contourTint = this.contourTint[i];\n        }\n\n        if (!this._contourCounts[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j];\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j];\n            shader.uniforms.contourTint = this.highlightTint[j];\n          } else if (k === 0 || k - 1 === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j];\n            shader.uniforms.contourTint = this.contourTint[j];\n          }\n\n          if (!this._contourCounts[j][k]) {\n            continue;\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k];\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n        }\n      }\n    }\n\n    vao.unbind(); // Draw dynamic contours\n\n    vao = this._dynamicVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue;\n      }\n\n      shader.uniforms.model = uniforms.model;\n      shader.uniforms.clipBounds = uniforms.clipBounds;\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio);\n      shader.uniforms.contourColor = this.dynamicColor[i];\n      shader.uniforms.contourTint = this.dynamicTint[i];\n      shader.uniforms.height = this.dynamicLevel[i];\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue;\n        }\n\n        shader.uniforms.model = projectData.projections[j];\n        shader.uniforms.clipBounds = projectData.clipBounds[j];\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n      }\n    }\n\n    vao.unbind();\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false);\n};\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true);\n};\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n};\n\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n  var uniforms = PICK_UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.shape = this._field[2].shape;\n  uniforms.pickId = this.pickId / 255.0;\n  uniforms.lowerBound = this.bounds[0];\n  uniforms.upperBound = this.bounds[1];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.permutation = DEFAULT_PERM;\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind();\n\n    this._pickShader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    this._vao.draw(gl.TRIANGLES, this._vertexCount); // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue;\n      }\n\n      this._pickShader.uniforms.model = projectData.projections[i];\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    var vao = this._contourVAO;\n    vao.bind();\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n      shader.uniforms.permutation = PERMUTATIONS[j];\n\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i];\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);\n        }\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k];\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n          }\n        }\n      }\n    }\n\n    vao.unbind();\n  }\n};\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null;\n  }\n\n  if (selection.id !== this.pickId) {\n    return null;\n  }\n\n  var shape = this._field[2].shape;\n  var result = this._pickResult; // Compute uv coordinate\n\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0;\n  var ix = Math.floor(x);\n  var fx = x - ix;\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0;\n  var iy = Math.floor(y);\n  var fy = y - iy;\n  ix += 1;\n  iy += 1; // Compute xyz coordinate\n\n  var pos = result.position;\n  pos[0] = pos[1] = pos[2] = 0;\n\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx;\n\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy;\n      var r = ix + dx;\n      var c = iy + dy;\n      var w = s * t;\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w;\n      }\n    }\n  } // Find closest level\n\n\n  var levelIndex = this._pickResult.level;\n\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);\n\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0;\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]];\n      var b = this.contourLevels[j][levelIndex[j] + 1];\n\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1;\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : ix + 1;\n  result.index[1] = fy < 0.5 ? iy : iy + 1;\n  result.uv[0] = x / shape[0];\n  result.uv[1] = y / shape[1];\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);\n  }\n\n  return result;\n};\n\nproto.padField = function (dstField, srcField) {\n  var srcShape = srcField.shape.slice();\n  var dstShape = dstField.shape.slice(); // Center\n\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField); // Edges\n\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1), srcField.hi(srcShape[0], 1));\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1), srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1));\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]), srcField.hi(1));\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]), srcField.lo(srcShape[0] - 1)); // Corners\n\n  dstField.set(0, 0, srcField.get(0, 0));\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));\n};\n\nfunction handleArray(param, ctor) {\n  if (Array.isArray(param)) {\n    return [ctor(param[0]), ctor(param[1]), ctor(param[2])];\n  }\n\n  return [ctor(param), ctor(param), ctor(param)];\n}\n\nfunction toColor(x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1];\n    }\n\n    return [x[0], x[1], x[2], x[3]];\n  }\n\n  return [0, 0, 0, 1];\n}\n\nfunction handleColor(param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [toColor(param[0]), toColor(param[1]), toColor(param[2])];\n    } else {\n      var c = toColor(param);\n      return [c.slice(), c.slice(), c.slice()];\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {};\n  this.objectOffset = params.objectOffset || this.objectOffset;\n  this.dirty = true;\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number);\n  }\n\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean);\n  }\n\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface;\n  }\n\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean);\n  }\n\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor);\n  }\n\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean);\n    });\n  }\n\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject;\n  }\n\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor);\n  }\n\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number);\n  }\n\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number);\n  }\n\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n  }\n\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds;\n  }\n\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n\n  var field = params.field || params.coords && params.coords[2] || null;\n  var levelsChanged = false;\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);\n    } else {\n      field = this._field[2].hi(0, 0);\n    }\n  } // Update field\n\n\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2); // Resize if necessary\n\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data);\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));\n    } // Pad field\n\n\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);\n    this.padField(this._field[2], field); // Save shape of field\n\n    this.shape = field.shape.slice();\n    var shape = this.shape; // Resize coordinate fields if necessary\n\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data);\n        this._field[i].data = pool.mallocFloat(this._field[2].size);\n      }\n\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);\n    } // Generate x/y coordinates\n\n\n    if (params.coords) {\n      var coords = params.coords;\n\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i];\n\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape');\n          }\n        }\n\n        this.padField(this._field[i], coord);\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks;\n\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i];\n\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick);\n        }\n\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length');\n        } // Make a copy view of the tick array\n\n\n        var tick2 = ndarray(tick.data, shape);\n        tick2.stride[i] = tick.stride[0];\n        tick2.stride[i ^ 1] = 0; // Fill in field array\n\n        this.padField(this._field[i], tick2);\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0];\n        offset[i] = 1;\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);\n      }\n\n      this._field[0].set(0, 0, 0);\n\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j);\n      }\n\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1);\n\n      this._field[1].set(0, 0, 0);\n\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j);\n      }\n\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1);\n    } // Save shape\n\n\n    var fields = this._field; // Compute surface normals\n\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);\n\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror');\n    }\n\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);\n\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0);\n        var dxdv = dfields.get(0, i, j, 1);\n        var dydu = dfields.get(1, i, j, 0);\n        var dydv = dfields.get(1, i, j, 1);\n        var dzdu = dfields.get(2, i, j, 0);\n        var dzdv = dfields.get(2, i, j, 1);\n        var nx = dydu * dzdv - dydv * dzdu;\n        var ny = dzdu * dxdv - dzdv * dxdu;\n        var nz = dxdu * dydv - dxdv * dydu;\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));\n\n          if (nl < 1e-8) {\n            nz = 1.0;\n            ny = nx = 0.0;\n            nl = 1.0;\n          } else {\n            nl = 1.0 / nl;\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl);\n        }\n\n        normals.set(i, j, 0, nx * nl);\n        normals.set(i, j, 1, ny * nl);\n        normals.set(i, j, 2, nz * nl);\n      }\n    }\n\n    pool.free(dfields.data); // Initialize surface\n\n    var lo = [Infinity, Infinity, Infinity];\n    var hi = [-Infinity, -Infinity, -Infinity];\n    var lo_intensity = Infinity;\n    var hi_intensity = -Infinity;\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6;\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count));\n    var tptr = 0;\n    var vertexCount = 0;\n\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop: for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy);\n\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop;\n              }\n            }\n          }\n        }\n\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0];\n          var c = j + QUAD[k][1];\n\n          var tx = this._field[0].get(r + 1, c + 1);\n\n          var ty = this._field[1].get(r + 1, c + 1);\n\n          f = this._field[2].get(r + 1, c + 1);\n          nx = normals.get(r + 1, c + 1, 0);\n          ny = normals.get(r + 1, c + 1, 1);\n          nz = normals.get(r + 1, c + 1, 2);\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c);\n          }\n\n          var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];\n          tverts[tptr++] = r;\n          tverts[tptr++] = c;\n          tverts[tptr++] = tx;\n          tverts[tptr++] = ty;\n          tverts[tptr++] = f;\n          tverts[tptr++] = 0;\n          tverts[tptr++] = vf;\n          tverts[tptr++] = nx;\n          tverts[tptr++] = ny;\n          tverts[tptr++] = nz;\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);\n          lo[2] = Math.min(lo[2], f + this.objectOffset[2]);\n          lo_intensity = Math.min(lo_intensity, vf);\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);\n          hi[2] = Math.max(hi[2], f + this.objectOffset[2]);\n          hi_intensity = Math.max(hi_intensity, vf);\n          vertexCount += 1;\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0];\n      hi_intensity = +params.intensityBounds[1];\n    } // Scale all vertex intensities\n\n\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);\n    }\n\n    this._vertexCount = vertexCount;\n\n    this._coordinateBuffer.update(tverts.subarray(0, tptr));\n\n    pool.freeFloat(tverts);\n    pool.free(normals.data); // Update bounds\n\n    this.bounds = [lo, hi]; // Save intensity\n\n    this.intensity = params.intensity || this._field[2];\n\n    if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n      levelsChanged = true;\n    } // Save intensity bound\n\n\n    this.intensityBounds = [lo_intensity, hi_intensity];\n  } // Update level crossings\n\n\n  if ('levels' in params) {\n    var levels = params.levels;\n\n    if (!Array.isArray(levels[0])) {\n      levels = [[], [], levels];\n    } else {\n      levels = levels.slice();\n    }\n\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice();\n      levels[i].sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i];\n      }\n    }\n\n    change_test: for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true;\n        break;\n      }\n\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true;\n          break change_test;\n        }\n      }\n    }\n\n    this.contourLevels = levels;\n  }\n\n  if (levelsChanged) {\n    fields = this._field;\n    shape = this.shape; // Update contour lines\n\n    var contourVerts = [];\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim];\n      var levelOffsets = [];\n      var levelCounts = [];\n      var parts = [0, 0, 0];\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i]);\n        levelOffsets.push(contourVerts.length / 5 | 0);\n        vertexCount = 0;\n\n        edge_loop: for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j];\n\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]];\n            var x = p[0];\n            var ix = Math.floor(x) | 0;\n            var fx = x - ix;\n            var y = p[1];\n            var iy = Math.floor(y) | 0;\n            var fy = y - iy;\n            var hole = false;\n\n            axis_loop: for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0;\n              var iu = (dim + axis + 1) % 3;\n\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx;\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;\n\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy;\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c);\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);\n                  }\n\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true;\n                    break axis_loop;\n                  }\n\n                  var w = s * t;\n                  parts[axis] += w * f;\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2]);\n              vertexCount += 1;\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop();\n                }\n\n                vertexCount -= 1;\n              }\n\n              continue edge_loop;\n            }\n          }\n        }\n\n        levelCounts.push(vertexCount);\n      } // Store results\n\n\n      this._contourOffsets[dim] = levelOffsets;\n      this._contourCounts[dim] = levelCounts;\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length);\n\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i];\n    }\n\n    this._contourBuffer.update(floatBuffer);\n\n    pool.freeFloat(floatBuffer);\n  }\n\n  if (params.colormap) {\n    this._colorMap.setPixels(genColormap(params.colormap));\n  }\n};\n\nproto.dispose = function () {\n  this._shader.dispose();\n\n  this._vao.dispose();\n\n  this._coordinateBuffer.dispose();\n\n  this._colorMap.dispose();\n\n  this._contourBuffer.dispose();\n\n  this._contourVAO.dispose();\n\n  this._contourShader.dispose();\n\n  this._contourPickShader.dispose();\n\n  this._dynamicBuffer.dispose();\n\n  this._dynamicVAO.dispose();\n\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data);\n  }\n};\n\nproto.highlight = function (selection) {\n  var i;\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0];\n    this.dyanamicLevel = [NaN, NaN, NaN];\n    this.highlightLevel = [-1, -1, -1];\n    return;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i];\n    } else {\n      this.highlightLevel[i] = -1;\n    }\n  }\n\n  var levels;\n\n  if (this.snapToData) {\n    levels = selection.dataCoordinate;\n  } else {\n    levels = selection.position;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i];\n  }\n\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return;\n  }\n\n  var vertexCount = 0;\n  var shape = this.shape;\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN;\n      this._dynamicCounts[d] = 0;\n      continue;\n    }\n\n    this.dynamicLevel[d] = levels[d];\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var f = this._field[d];\n    var g = this._field[u];\n    var h = this._field[v];\n    var graph = surfaceNets(f, levels[d]);\n    var edges = graph.cells;\n    var positions = graph.positions;\n    this._dynamicOffsets[d] = vertexCount;\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]];\n        var x = +p[0];\n        var ix = x | 0;\n        var jx = Math.min(ix + 1, shape[0]) | 0;\n        var fx = x - ix;\n        var hx = 1.0 - fx;\n        var y = +p[1];\n        var iy = y | 0;\n        var jy = Math.min(iy + 1, shape[1]) | 0;\n        var fy = y - iy;\n        var hy = 1.0 - fy;\n        var w00 = hx * hy;\n        var w01 = hx * fy;\n        var w10 = fx * hy;\n        var w11 = fx * fy;\n        var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);\n        var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1;\n          }\n\n          break;\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu;\n        scratchBuffer[2 * vertexCount + 1] = cv;\n        vertexCount += 1;\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));\n\n  pool.freeFloat(scratchBuffer);\n};\n\nfunction createSurfacePlot(params) {\n  var gl = params.gl;\n  var shader = createShader(gl);\n  var pickShader = createPickShader(gl);\n  var contourShader = createContourShader(gl);\n  var contourPickShader = createPickContourShader(gl);\n  var coordinateBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: coordinateBuffer,\n    size: 4,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 0\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 16\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 28\n  }]);\n  var contourBuffer = createBuffer(gl);\n  var contourVAO = createVAO(gl, [{\n    buffer: contourBuffer,\n    size: 4,\n    stride: 20,\n    offset: 0\n  }, {\n    buffer: contourBuffer,\n    size: 1,\n    stride: 20,\n    offset: 16\n  }]);\n  var dynamicBuffer = createBuffer(gl);\n  var dynamicVAO = createVAO(gl, [{\n    buffer: dynamicBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }]);\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE);\n  cmap.minFilter = gl.LINEAR;\n  cmap.magFilter = gl.LINEAR;\n  var surface = new SurfacePlot(gl, [0, 0], // shape\n  [[0, 0, 0], [0, 0, 0]], // bounds\n  shader, pickShader, coordinateBuffer, vao, cmap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, [0, 0, 0] // objectOffset\n  );\n  var nparams = {\n    levels: [[], [], []]\n  };\n\n  for (var id in params) {\n    nparams[id] = params[id];\n  }\n\n  nparams.colormap = nparams.colormap || 'jet';\n  surface.update(nparams);\n  return surface;\n}","map":null,"metadata":{},"sourceType":"script"}