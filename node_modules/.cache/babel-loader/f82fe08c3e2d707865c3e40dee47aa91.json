{"ast":null,"code":"'use strict';\n\nmodule.exports = gradient;\n\nvar dup = require('dup');\n\nvar cwiseCompiler = require('cwise-compiler');\n\nvar TEMPLATE_CACHE = {};\nvar GRADIENT_CACHE = {};\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n};\nvar centralDiff = cwiseCompiler({\n  args: ['array', 'array', 'array'],\n  pre: EmptyProc,\n  post: EmptyProc,\n  body: {\n    args: [{\n      name: 'out',\n      lvalue: true,\n      rvalue: false,\n      count: 1\n    }, {\n      name: 'left',\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }, {\n      name: 'right',\n      lvalue: false,\n      rvalue: true,\n      count: 1\n    }],\n    body: \"out=0.5*(left-right)\",\n    thisVars: [],\n    localVars: []\n  },\n  funcName: 'cdiff'\n});\nvar zeroOut = cwiseCompiler({\n  args: ['array'],\n  pre: EmptyProc,\n  post: EmptyProc,\n  body: {\n    args: [{\n      name: 'out',\n      lvalue: true,\n      rvalue: false,\n      count: 1\n    }],\n    body: \"out=0\",\n    thisVars: [],\n    localVars: []\n  },\n  funcName: 'zero'\n});\n\nfunction generateTemplate(d) {\n  if (d in TEMPLATE_CACHE) {\n    return TEMPLATE_CACHE[d];\n  }\n\n  var code = [];\n\n  for (var i = 0; i < d; ++i) {\n    code.push('out', i, 's=0.5*(inp', i, 'l-inp', i, 'r);');\n  }\n\n  var args = ['array'];\n  var names = ['junk'];\n\n  for (var i = 0; i < d; ++i) {\n    args.push('array');\n    names.push('out' + i + 's');\n    var o = dup(d);\n    o[i] = -1;\n    args.push({\n      array: 0,\n      offset: o.slice()\n    });\n    o[i] = 1;\n    args.push({\n      array: 0,\n      offset: o.slice()\n    });\n    names.push('inp' + i + 'l', 'inp' + i + 'r');\n  }\n\n  return TEMPLATE_CACHE[d] = cwiseCompiler({\n    args: args,\n    pre: EmptyProc,\n    post: EmptyProc,\n    body: {\n      body: code.join(''),\n      args: names.map(function (n) {\n        return {\n          name: n,\n          lvalue: n.indexOf('out') === 0,\n          rvalue: n.indexOf('inp') === 0,\n          count: n !== 'junk' | 0\n        };\n      }),\n      thisVars: [],\n      localVars: []\n    },\n    funcName: 'fdTemplate' + d\n  });\n}\n\nfunction generateGradient(boundaryConditions) {\n  var token = boundaryConditions.join();\n  var proc = GRADIENT_CACHE[token];\n\n  if (proc) {\n    return proc;\n  }\n\n  var d = boundaryConditions.length;\n  var code = ['function gradient(dst,src){var s=src.shape.slice();'];\n\n  function handleBoundary(facet) {\n    var cod = d - facet.length;\n    var loStr = [];\n    var hiStr = [];\n    var pickStr = [];\n\n    for (var i = 0; i < d; ++i) {\n      if (facet.indexOf(i + 1) >= 0) {\n        pickStr.push('0');\n      } else if (facet.indexOf(-(i + 1)) >= 0) {\n        pickStr.push('s[' + i + ']-1');\n      } else {\n        pickStr.push('-1');\n        loStr.push('1');\n        hiStr.push('s[' + i + ']-2');\n      }\n    }\n\n    var boundStr = '.lo(' + loStr.join() + ').hi(' + hiStr.join() + ')';\n\n    if (loStr.length === 0) {\n      boundStr = '';\n    }\n\n    if (cod > 0) {\n      code.push('if(1');\n\n      for (var i = 0; i < d; ++i) {\n        if (facet.indexOf(i + 1) >= 0 || facet.indexOf(-(i + 1)) >= 0) {\n          continue;\n        }\n\n        code.push('&&s[', i, ']>2');\n      }\n\n      code.push('){grad', cod, '(src.pick(', pickStr.join(), ')', boundStr);\n\n      for (var i = 0; i < d; ++i) {\n        if (facet.indexOf(i + 1) >= 0 || facet.indexOf(-(i + 1)) >= 0) {\n          continue;\n        }\n\n        code.push(',dst.pick(', pickStr.join(), ',', i, ')', boundStr);\n      }\n\n      code.push(');');\n    }\n\n    for (var i = 0; i < facet.length; ++i) {\n      var bnd = Math.abs(facet[i]) - 1;\n      var outStr = 'dst.pick(' + pickStr.join() + ',' + bnd + ')' + boundStr;\n\n      switch (boundaryConditions[bnd]) {\n        case 'clamp':\n          var cPickStr = pickStr.slice();\n          var dPickStr = pickStr.slice();\n\n          if (facet[i] < 0) {\n            cPickStr[bnd] = 's[' + bnd + ']-2';\n          } else {\n            dPickStr[bnd] = '1';\n          }\n\n          if (cod === 0) {\n            code.push('if(s[', bnd, ']>1){dst.set(', pickStr.join(), ',', bnd, ',0.5*(src.get(', cPickStr.join(), ')-src.get(', dPickStr.join(), ')))}else{dst.set(', pickStr.join(), ',', bnd, ',0)};');\n          } else {\n            code.push('if(s[', bnd, ']>1){diff(', outStr, ',src.pick(', cPickStr.join(), ')', boundStr, ',src.pick(', dPickStr.join(), ')', boundStr, ');}else{zero(', outStr, ');};');\n          }\n\n          break;\n\n        case 'mirror':\n          if (cod === 0) {\n            code.push('dst.set(', pickStr.join(), ',', bnd, ',0);');\n          } else {\n            code.push('zero(', outStr, ');');\n          }\n\n          break;\n\n        case 'wrap':\n          var aPickStr = pickStr.slice();\n          var bPickStr = pickStr.slice();\n\n          if (facet[i] < 0) {\n            aPickStr[bnd] = 's[' + bnd + ']-2';\n            bPickStr[bnd] = '0';\n          } else {\n            aPickStr[bnd] = 's[' + bnd + ']-1';\n            bPickStr[bnd] = '1';\n          }\n\n          if (cod === 0) {\n            code.push('if(s[', bnd, ']>2){dst.set(', pickStr.join(), ',', bnd, ',0.5*(src.get(', aPickStr.join(), ')-src.get(', bPickStr.join(), ')))}else{dst.set(', pickStr.join(), ',', bnd, ',0)};');\n          } else {\n            code.push('if(s[', bnd, ']>2){diff(', outStr, ',src.pick(', aPickStr.join(), ')', boundStr, ',src.pick(', bPickStr.join(), ')', boundStr, ');}else{zero(', outStr, ');};');\n          }\n\n          break;\n\n        default:\n          throw new Error('ndarray-gradient: Invalid boundary condition');\n      }\n    }\n\n    if (cod > 0) {\n      code.push('};');\n    }\n  } //Enumerate ridges, facets, etc. of hypercube\n\n\n  for (var i = 0; i < 1 << d; ++i) {\n    var faces = [];\n\n    for (var j = 0; j < d; ++j) {\n      if (i & 1 << j) {\n        faces.push(j + 1);\n      }\n    }\n\n    for (var k = 0; k < 1 << faces.length; ++k) {\n      var sfaces = faces.slice();\n\n      for (var j = 0; j < faces.length; ++j) {\n        if (k & 1 << j) {\n          sfaces[j] = -sfaces[j];\n        }\n      }\n\n      handleBoundary(sfaces);\n    }\n  }\n\n  code.push('return dst;};return gradient'); //Compile and link routine, save cached procedure\n\n  var linkNames = ['diff', 'zero'];\n  var linkArgs = [centralDiff, zeroOut];\n\n  for (var i = 1; i <= d; ++i) {\n    linkNames.push('grad' + i);\n    linkArgs.push(generateTemplate(i));\n  }\n\n  linkNames.push(code.join(''));\n  var link = Function.apply(void 0, linkNames);\n  var proc = link.apply(void 0, linkArgs);\n  TEMPLATE_CACHE[token] = proc;\n  return proc;\n}\n\nfunction gradient(out, inp, bc) {\n  if (Array.isArray(bc)) {\n    if (bc.length !== inp.dimension) {\n      throw new Error('ndarray-gradient: invalid boundary conditions');\n    }\n  } else if (typeof bc === 'string') {\n    bc = dup(inp.dimension, bc);\n  } else {\n    bc = dup(inp.dimension, 'clamp');\n  }\n\n  if (out.dimension !== inp.dimension + 1) {\n    throw new Error('ndarray-gradient: output dimension must be +1 input dimension');\n  }\n\n  if (out.shape[inp.dimension] !== inp.dimension) {\n    throw new Error('ndarray-gradient: output shape must match input shape');\n  }\n\n  for (var i = 0; i < inp.dimension; ++i) {\n    if (out.shape[i] !== inp.shape[i]) {\n      throw new Error('ndarray-gradient: shape mismatch');\n    }\n  }\n\n  if (inp.size === 0) {\n    return out;\n  }\n\n  if (inp.dimension <= 0) {\n    out.set(0);\n    return out;\n  }\n\n  var cached = generateGradient(bc);\n  return cached(out, inp);\n}","map":null,"metadata":{},"sourceType":"script"}