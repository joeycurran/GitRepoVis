{"ast":null,"code":"\"use strict\";\n\nmodule.exports = axesProperties;\n\nvar getPlanes = require(\"extract-frustum-planes\");\n\nvar splitPoly = require(\"split-polygon\");\n\nvar cubeParams = require(\"./lib/cube.js\");\n\nvar m4mul = require(\"gl-mat4/multiply\");\n\nvar m4transpose = require(\"gl-mat4/transpose\");\n\nvar v4transformMat4 = require(\"gl-vec4/transformMat4\");\n\nvar identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nvar mvp = new Float32Array(16);\n\nfunction AxesRange3D(lo, hi, pixelsPerDataUnit) {\n  this.lo = lo;\n  this.hi = hi;\n  this.pixelsPerDataUnit = pixelsPerDataUnit;\n}\n\nvar SCRATCH_P = [0, 0, 0, 1];\nvar SCRATCH_Q = [0, 0, 0, 1];\n\nfunction gradient(result, M, v, width, height) {\n  for (var i = 0; i < 3; ++i) {\n    var p = SCRATCH_P;\n    var q = SCRATCH_Q;\n\n    for (var j = 0; j < 3; ++j) {\n      q[j] = p[j] = v[j];\n    }\n\n    q[3] = p[3] = 1;\n    q[i] += 1;\n    v4transformMat4(q, q, M);\n\n    if (q[3] < 0) {\n      result[i] = Infinity;\n    }\n\n    p[i] -= 1;\n    v4transformMat4(p, p, M);\n\n    if (p[3] < 0) {\n      result[i] = Infinity;\n    }\n\n    var dx = (p[0] / p[3] - q[0] / q[3]) * width;\n    var dy = (p[1] / p[3] - q[1] / q[3]) * height;\n    result[i] = 0.25 * Math.sqrt(dx * dx + dy * dy);\n  }\n\n  return result;\n}\n\nvar RANGES = [new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity)];\nvar SCRATCH_X = [0, 0, 0];\n\nfunction axesProperties(axes, camera, width, height, params) {\n  var model = camera.model || identity;\n  var view = camera.view || identity;\n  var projection = camera.projection || identity;\n  var isOrtho = camera._ortho || false;\n  var bounds = axes.bounds;\n  var params = params || cubeParams(model, view, projection, bounds, isOrtho);\n  var axis = params.axis;\n  m4mul(mvp, view, model);\n  m4mul(mvp, projection, mvp); //Calculate the following properties for each axis:\n  //\n  // * lo - start of visible range for each axis in tick coordinates\n  // * hi - end of visible range for each axis in tick coordinates\n  // * ticksPerPixel - pixel density of tick marks for the axis\n  //\n\n  var ranges = RANGES;\n\n  for (var i = 0; i < 3; ++i) {\n    ranges[i].lo = Infinity;\n    ranges[i].hi = -Infinity;\n    ranges[i].pixelsPerDataUnit = Infinity;\n  } //Compute frustum planes, intersect with box\n\n\n  var frustum = getPlanes(m4transpose(mvp, mvp));\n  m4transpose(mvp, mvp); //Loop over vertices of viewable box\n\n  for (var d = 0; d < 3; ++d) {\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var x = SCRATCH_X;\n\n    i_loop: for (var i = 0; i < 2; ++i) {\n      var poly = [];\n\n      if (axis[d] < 0 === !!i) {\n        continue;\n      }\n\n      x[d] = bounds[i][d];\n\n      for (var j = 0; j < 2; ++j) {\n        x[u] = bounds[j ^ i][u];\n\n        for (var k = 0; k < 2; ++k) {\n          x[v] = bounds[k ^ j ^ i][v];\n          poly.push(x.slice());\n        }\n      }\n\n      var Q = isOrtho ? 5 : 4;\n\n      for (var j = Q; j === Q; ++j) {\n        // Note: using only near plane here (& for orthographic projection we use the far).\n        if (poly.length === 0) {\n          continue i_loop;\n        }\n\n        poly = splitPoly.positive(poly, frustum[j]);\n      } //Loop over vertices of polygon to find extremal points\n\n\n      for (var j = 0; j < poly.length; ++j) {\n        var v = poly[j];\n        var grad = gradient(SCRATCH_X, mvp, v, width, height);\n\n        for (var k = 0; k < 3; ++k) {\n          ranges[k].lo = Math.min(ranges[k].lo, v[k]);\n          ranges[k].hi = Math.max(ranges[k].hi, v[k]);\n\n          if (k !== d) {\n            ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]));\n          }\n        }\n      }\n    }\n  }\n\n  return ranges;\n}","map":null,"metadata":{},"sourceType":"script"}