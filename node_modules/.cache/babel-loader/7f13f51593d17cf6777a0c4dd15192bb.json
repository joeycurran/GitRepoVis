{"ast":null,"code":"'use strict';\n\nvar monotoneTriangulate = require('./lib/monotone');\n\nvar makeIndex = require('./lib/triangulation');\n\nvar delaunayFlip = require('./lib/delaunay');\n\nvar filterTriangulation = require('./lib/filter');\n\nmodule.exports = cdt2d;\n\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];\n}\n\nfunction compareEdge(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge);\n}\n\nfunction getDefault(options, property, dflt) {\n  if (property in options) {\n    return options[property];\n  }\n\n  return dflt;\n}\n\nfunction cdt2d(points, edges, options) {\n  if (!Array.isArray(edges)) {\n    options = edges || {};\n    edges = [];\n  } else {\n    options = options || {};\n    edges = edges || [];\n  } //Parse out options\n\n\n  var delaunay = !!getDefault(options, 'delaunay', true);\n  var interior = !!getDefault(options, 'interior', true);\n  var exterior = !!getDefault(options, 'exterior', true);\n  var infinity = !!getDefault(options, 'infinity', false); //Handle trivial case\n\n  if (!interior && !exterior || points.length === 0) {\n    return [];\n  } //Construct initial triangulation\n\n\n  var cells = monotoneTriangulate(points, edges); //If delaunay refinement needed, then improve quality by edge flipping\n\n  if (delaunay || interior !== exterior || infinity) {\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges));\n\n    for (var i = 0; i < cells.length; ++i) {\n      var f = cells[i];\n      triangulation.addTriangle(f[0], f[1], f[2]);\n    } //Run edge flipping\n\n\n    if (delaunay) {\n      delaunayFlip(points, triangulation);\n    } //Filter points\n\n\n    if (!exterior) {\n      return filterTriangulation(triangulation, -1);\n    } else if (!interior) {\n      return filterTriangulation(triangulation, 1, infinity);\n    } else if (infinity) {\n      return filterTriangulation(triangulation, 0, infinity);\n    } else {\n      return triangulation.cells();\n    }\n  } else {\n    return cells;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}