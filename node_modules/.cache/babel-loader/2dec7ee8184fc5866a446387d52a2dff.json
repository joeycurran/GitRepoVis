{"ast":null,"code":"'use strict';\n\nmodule.exports = createOrbitController;\n\nvar filterVector = require('filtered-vector');\n\nvar lookAt = require('gl-mat4/lookAt');\n\nvar mat4FromQuat = require('gl-mat4/fromQuat');\n\nvar invert44 = require('gl-mat4/invert');\n\nvar quatFromFrame = require('./lib/quatFromFrame');\n\nfunction len3(x, y, z) {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n}\n\nfunction len4(w, x, y, z) {\n  return Math.sqrt(Math.pow(w, 2) + Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n}\n\nfunction normalize4(out, a) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  var al = len4(ax, ay, az, aw);\n\n  if (al > 1e-6) {\n    out[0] = ax / al;\n    out[1] = ay / al;\n    out[2] = az / al;\n    out[3] = aw / al;\n  } else {\n    out[0] = out[1] = out[2] = 0.0;\n    out[3] = 1.0;\n  }\n}\n\nfunction OrbitCameraController(initQuat, initCenter, initRadius) {\n  this.radius = filterVector([initRadius]);\n  this.center = filterVector(initCenter);\n  this.rotation = filterVector(initQuat);\n  this.computedRadius = this.radius.curve(0);\n  this.computedCenter = this.center.curve(0);\n  this.computedRotation = this.rotation.curve(0);\n  this.computedUp = [0.1, 0, 0];\n  this.computedEye = [0.1, 0, 0];\n  this.computedMatrix = [0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  this.recalcMatrix(0);\n}\n\nvar proto = OrbitCameraController.prototype;\n\nproto.lastT = function () {\n  return Math.max(this.radius.lastT(), this.center.lastT(), this.rotation.lastT());\n};\n\nproto.recalcMatrix = function (t) {\n  this.radius.curve(t);\n  this.center.curve(t);\n  this.rotation.curve(t);\n  var quat = this.computedRotation;\n  normalize4(quat, quat);\n  var mat = this.computedMatrix;\n  mat4FromQuat(mat, quat);\n  var center = this.computedCenter;\n  var eye = this.computedEye;\n  var up = this.computedUp;\n  var radius = Math.exp(this.computedRadius[0]);\n  eye[0] = center[0] + radius * mat[2];\n  eye[1] = center[1] + radius * mat[6];\n  eye[2] = center[2] + radius * mat[10];\n  up[0] = mat[1];\n  up[1] = mat[5];\n  up[2] = mat[9];\n\n  for (var i = 0; i < 3; ++i) {\n    var rr = 0.0;\n\n    for (var j = 0; j < 3; ++j) {\n      rr += mat[i + 4 * j] * eye[j];\n    }\n\n    mat[12 + i] = -rr;\n  }\n};\n\nproto.getMatrix = function (t, result) {\n  this.recalcMatrix(t);\n  var m = this.computedMatrix;\n\n  if (result) {\n    for (var i = 0; i < 16; ++i) {\n      result[i] = m[i];\n    }\n\n    return result;\n  }\n\n  return m;\n};\n\nproto.idle = function (t) {\n  this.center.idle(t);\n  this.radius.idle(t);\n  this.rotation.idle(t);\n};\n\nproto.flush = function (t) {\n  this.center.flush(t);\n  this.radius.flush(t);\n  this.rotation.flush(t);\n};\n\nproto.pan = function (t, dx, dy, dz) {\n  dx = dx || 0.0;\n  dy = dy || 0.0;\n  dz = dz || 0.0;\n  this.recalcMatrix(t);\n  var mat = this.computedMatrix;\n  var ux = mat[1];\n  var uy = mat[5];\n  var uz = mat[9];\n  var ul = len3(ux, uy, uz);\n  ux /= ul;\n  uy /= ul;\n  uz /= ul;\n  var rx = mat[0];\n  var ry = mat[4];\n  var rz = mat[8];\n  var ru = rx * ux + ry * uy + rz * uz;\n  rx -= ux * ru;\n  ry -= uy * ru;\n  rz -= uz * ru;\n  var rl = len3(rx, ry, rz);\n  rx /= rl;\n  ry /= rl;\n  rz /= rl;\n  var fx = mat[2];\n  var fy = mat[6];\n  var fz = mat[10];\n  var fu = fx * ux + fy * uy + fz * uz;\n  var fr = fx * rx + fy * ry + fz * rz;\n  fx -= fu * ux + fr * rx;\n  fy -= fu * uy + fr * ry;\n  fz -= fu * uz + fr * rz;\n  var fl = len3(fx, fy, fz);\n  fx /= fl;\n  fy /= fl;\n  fz /= fl;\n  var vx = rx * dx + ux * dy;\n  var vy = ry * dx + uy * dy;\n  var vz = rz * dx + uz * dy;\n  this.center.move(t, vx, vy, vz); //Update z-component of radius\n\n  var radius = Math.exp(this.computedRadius[0]);\n  radius = Math.max(1e-4, radius + dz);\n  this.radius.set(t, Math.log(radius));\n};\n\nproto.rotate = function (t, dx, dy, dz) {\n  this.recalcMatrix(t);\n  dx = dx || 0.0;\n  dy = dy || 0.0;\n  var mat = this.computedMatrix;\n  var rx = mat[0];\n  var ry = mat[4];\n  var rz = mat[8];\n  var ux = mat[1];\n  var uy = mat[5];\n  var uz = mat[9];\n  var fx = mat[2];\n  var fy = mat[6];\n  var fz = mat[10];\n  var qx = dx * rx + dy * ux;\n  var qy = dx * ry + dy * uy;\n  var qz = dx * rz + dy * uz;\n  var bx = -(fy * qz - fz * qy);\n  var by = -(fz * qx - fx * qz);\n  var bz = -(fx * qy - fy * qx);\n  var bw = Math.sqrt(Math.max(0.0, 1.0 - Math.pow(bx, 2) - Math.pow(by, 2) - Math.pow(bz, 2)));\n  var bl = len4(bx, by, bz, bw);\n\n  if (bl > 1e-6) {\n    bx /= bl;\n    by /= bl;\n    bz /= bl;\n    bw /= bl;\n  } else {\n    bx = by = bz = 0.0;\n    bw = 1.0;\n  }\n\n  var rotation = this.computedRotation;\n  var ax = rotation[0];\n  var ay = rotation[1];\n  var az = rotation[2];\n  var aw = rotation[3];\n  var cx = ax * bw + aw * bx + ay * bz - az * by;\n  var cy = ay * bw + aw * by + az * bx - ax * bz;\n  var cz = az * bw + aw * bz + ax * by - ay * bx;\n  var cw = aw * bw - ax * bx - ay * by - az * bz; //Apply roll\n\n  if (dz) {\n    bx = fx;\n    by = fy;\n    bz = fz;\n    var s = Math.sin(dz) / len3(bx, by, bz);\n    bx *= s;\n    by *= s;\n    bz *= s;\n    bw = Math.cos(dx);\n    cx = cx * bw + cw * bx + cy * bz - cz * by;\n    cy = cy * bw + cw * by + cz * bx - cx * bz;\n    cz = cz * bw + cw * bz + cx * by - cy * bx;\n    cw = cw * bw - cx * bx - cy * by - cz * bz;\n  }\n\n  var cl = len4(cx, cy, cz, cw);\n\n  if (cl > 1e-6) {\n    cx /= cl;\n    cy /= cl;\n    cz /= cl;\n    cw /= cl;\n  } else {\n    cx = cy = cz = 0.0;\n    cw = 1.0;\n  }\n\n  this.rotation.set(t, cx, cy, cz, cw);\n};\n\nproto.lookAt = function (t, eye, center, up) {\n  this.recalcMatrix(t);\n  center = center || this.computedCenter;\n  eye = eye || this.computedEye;\n  up = up || this.computedUp;\n  var mat = this.computedMatrix;\n  lookAt(mat, eye, center, up);\n  var rotation = this.computedRotation;\n  quatFromFrame(rotation, mat[0], mat[1], mat[2], mat[4], mat[5], mat[6], mat[8], mat[9], mat[10]);\n  normalize4(rotation, rotation);\n  this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);\n  var fl = 0.0;\n\n  for (var i = 0; i < 3; ++i) {\n    fl += Math.pow(center[i] - eye[i], 2);\n  }\n\n  this.radius.set(t, 0.5 * Math.log(Math.max(fl, 1e-6)));\n  this.center.set(t, center[0], center[1], center[2]);\n};\n\nproto.translate = function (t, dx, dy, dz) {\n  this.center.move(t, dx || 0.0, dy || 0.0, dz || 0.0);\n};\n\nproto.setMatrix = function (t, matrix) {\n  var rotation = this.computedRotation;\n  quatFromFrame(rotation, matrix[0], matrix[1], matrix[2], matrix[4], matrix[5], matrix[6], matrix[8], matrix[9], matrix[10]);\n  normalize4(rotation, rotation);\n  this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);\n  var mat = this.computedMatrix;\n  invert44(mat, matrix);\n  var w = mat[15];\n\n  if (Math.abs(w) > 1e-6) {\n    var cx = mat[12] / w;\n    var cy = mat[13] / w;\n    var cz = mat[14] / w;\n    this.recalcMatrix(t);\n    var r = Math.exp(this.computedRadius[0]);\n    this.center.set(t, cx - mat[2] * r, cy - mat[6] * r, cz - mat[10] * r);\n    this.radius.idle(t);\n  } else {\n    this.center.idle(t);\n    this.radius.idle(t);\n  }\n};\n\nproto.setDistance = function (t, d) {\n  if (d > 0) {\n    this.radius.set(t, Math.log(d));\n  }\n};\n\nproto.setDistanceLimits = function (lo, hi) {\n  if (lo > 0) {\n    lo = Math.log(lo);\n  } else {\n    lo = -Infinity;\n  }\n\n  if (hi > 0) {\n    hi = Math.log(hi);\n  } else {\n    hi = Infinity;\n  }\n\n  hi = Math.max(hi, lo);\n  this.radius.bounds[0][0] = lo;\n  this.radius.bounds[1][0] = hi;\n};\n\nproto.getDistanceLimits = function (out) {\n  var bounds = this.radius.bounds;\n\n  if (out) {\n    out[0] = Math.exp(bounds[0][0]);\n    out[1] = Math.exp(bounds[1][0]);\n    return out;\n  }\n\n  return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];\n};\n\nproto.toJSON = function () {\n  this.recalcMatrix(this.lastT());\n  return {\n    center: this.computedCenter.slice(),\n    rotation: this.computedRotation.slice(),\n    distance: Math.log(this.computedRadius[0]),\n    zoomMin: this.radius.bounds[0][0],\n    zoomMax: this.radius.bounds[1][0]\n  };\n};\n\nproto.fromJSON = function (options) {\n  var t = this.lastT();\n  var c = options.center;\n\n  if (c) {\n    this.center.set(t, c[0], c[1], c[2]);\n  }\n\n  var r = options.rotation;\n\n  if (r) {\n    this.rotation.set(t, r[0], r[1], r[2], r[3]);\n  }\n\n  var d = options.distance;\n\n  if (d && d > 0) {\n    this.radius.set(t, Math.log(d));\n  }\n\n  this.setDistanceLimits(options.zoomMin, options.zoomMax);\n};\n\nfunction createOrbitController(options) {\n  options = options || {};\n  var center = options.center || [0, 0, 0];\n  var rotation = options.rotation || [0, 0, 0, 1];\n  var radius = options.radius || 1.0;\n  center = [].slice.call(center, 0, 3);\n  rotation = [].slice.call(rotation, 0, 4);\n  normalize4(rotation, rotation);\n  var result = new OrbitCameraController(rotation, center, Math.log(radius));\n  result.setDistanceLimits(options.zoomMin, options.zoomMax);\n\n  if ('eye' in options || 'up' in options) {\n    result.lookAt(0, options.eye, options.center, options.up);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}