{"ast":null,"code":"'use strict';\n\nmodule.exports = createAxes;\n\nvar createText = require('./lib/text.js');\n\nvar createLines = require('./lib/lines.js');\n\nvar createBackground = require('./lib/background.js');\n\nvar getCubeProperties = require('./lib/cube.js');\n\nvar Ticks = require('./lib/ticks.js');\n\nvar identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\nfunction copyVec3(a, b) {\n  a[0] = b[0];\n  a[1] = b[1];\n  a[2] = b[2];\n  return a;\n}\n\nfunction Axes(gl) {\n  this.gl = gl;\n  this.pixelRatio = 1;\n  this.bounds = [[-10, -10, -10], [10, 10, 10]];\n  this.ticks = [[], [], []];\n  this.autoTicks = true;\n  this.tickSpacing = [1, 1, 1];\n  this.tickEnable = [true, true, true];\n  this.tickFont = ['sans-serif', 'sans-serif', 'sans-serif'];\n  this.tickSize = [12, 12, 12];\n  this.tickAngle = [0, 0, 0];\n  this.tickAlign = ['auto', 'auto', 'auto'];\n  this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.tickPad = [10, 10, 10];\n  this.lastCubeProps = {\n    cubeEdges: [0, 0, 0],\n    axis: [0, 0, 0]\n  };\n  this.labels = ['x', 'y', 'z'];\n  this.labelEnable = [true, true, true];\n  this.labelFont = 'sans-serif';\n  this.labelSize = [20, 20, 20];\n  this.labelAngle = [0, 0, 0];\n  this.labelAlign = ['auto', 'auto', 'auto'];\n  this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.labelPad = [10, 10, 10];\n  this.lineEnable = [true, true, true];\n  this.lineMirror = [false, false, false];\n  this.lineWidth = [1, 1, 1];\n  this.lineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.lineTickEnable = [true, true, true];\n  this.lineTickMirror = [false, false, false];\n  this.lineTickLength = [0, 0, 0];\n  this.lineTickWidth = [1, 1, 1];\n  this.lineTickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.gridEnable = [true, true, true];\n  this.gridWidth = [1, 1, 1];\n  this.gridColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.zeroEnable = [true, true, true];\n  this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.zeroLineWidth = [2, 2, 2];\n  this.backgroundEnable = [false, false, false];\n  this.backgroundColor = [[0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5]];\n  this._firstInit = true;\n  this._text = null;\n  this._lines = null;\n  this._background = createBackground(gl);\n}\n\nvar proto = Axes.prototype;\n\nproto.update = function (options) {\n  options = options || {}; //Option parsing helper functions\n\n  function parseOption(nest, cons, name) {\n    if (name in options) {\n      var opt = options[name];\n      var prev = this[name];\n      var next;\n\n      if (nest ? Array.isArray(opt) && Array.isArray(opt[0]) : Array.isArray(opt)) {\n        this[name] = next = [cons(opt[0]), cons(opt[1]), cons(opt[2])];\n      } else {\n        this[name] = next = [cons(opt), cons(opt), cons(opt)];\n      }\n\n      for (var i = 0; i < 3; ++i) {\n        if (next[i] !== prev[i]) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  var NUMBER = parseOption.bind(this, false, Number);\n  var BOOLEAN = parseOption.bind(this, false, Boolean);\n  var STRING = parseOption.bind(this, false, String);\n  var COLOR = parseOption.bind(this, true, function (v) {\n    if (Array.isArray(v)) {\n      if (v.length === 3) {\n        return [+v[0], +v[1], +v[2], 1.0];\n      } else if (v.length === 4) {\n        return [+v[0], +v[1], +v[2], +v[3]];\n      }\n    }\n\n    return [0, 0, 0, 1];\n  }); //Tick marks and bounds\n\n  var nextTicks;\n  var ticksUpdate = false;\n  var boundsChanged = false;\n\n  if ('bounds' in options) {\n    var bounds = options.bounds;\n\n    i_loop: for (var i = 0; i < 2; ++i) {\n      for (var j = 0; j < 3; ++j) {\n        if (bounds[i][j] !== this.bounds[i][j]) {\n          boundsChanged = true;\n        }\n\n        this.bounds[i][j] = bounds[i][j];\n      }\n    }\n  }\n\n  if ('ticks' in options) {\n    nextTicks = options.ticks;\n    ticksUpdate = true;\n    this.autoTicks = false;\n\n    for (var i = 0; i < 3; ++i) {\n      this.tickSpacing[i] = 0.0;\n    }\n  } else if (NUMBER('tickSpacing')) {\n    this.autoTicks = true;\n    boundsChanged = true;\n  }\n\n  if (this._firstInit) {\n    if (!('ticks' in options || 'tickSpacing' in options)) {\n      this.autoTicks = true;\n    } //Force tick recomputation on first update\n\n\n    boundsChanged = true;\n    ticksUpdate = true;\n    this._firstInit = false;\n  }\n\n  if (boundsChanged && this.autoTicks) {\n    nextTicks = Ticks.create(this.bounds, this.tickSpacing);\n    ticksUpdate = true;\n  } //Compare next ticks to previous ticks, only update if needed\n\n\n  if (ticksUpdate) {\n    for (var i = 0; i < 3; ++i) {\n      nextTicks[i].sort(function (a, b) {\n        return a.x - b.x;\n      });\n    }\n\n    if (Ticks.equal(nextTicks, this.ticks)) {\n      ticksUpdate = false;\n    } else {\n      this.ticks = nextTicks;\n    }\n  } //Parse tick properties\n\n\n  BOOLEAN('tickEnable');\n\n  if (STRING('tickFont')) {\n    ticksUpdate = true; //If font changes, must rebuild vbo\n  }\n\n  NUMBER('tickSize');\n  NUMBER('tickAngle');\n  NUMBER('tickPad');\n  COLOR('tickColor'); //Axis labels\n\n  var labelUpdate = STRING('labels');\n\n  if (STRING('labelFont')) {\n    labelUpdate = true;\n  }\n\n  BOOLEAN('labelEnable');\n  NUMBER('labelSize');\n  NUMBER('labelPad');\n  COLOR('labelColor'); //Axis lines\n\n  BOOLEAN('lineEnable');\n  BOOLEAN('lineMirror');\n  NUMBER('lineWidth');\n  COLOR('lineColor'); //Axis line ticks\n\n  BOOLEAN('lineTickEnable');\n  BOOLEAN('lineTickMirror');\n  NUMBER('lineTickLength');\n  NUMBER('lineTickWidth');\n  COLOR('lineTickColor'); //Grid lines\n\n  BOOLEAN('gridEnable');\n  NUMBER('gridWidth');\n  COLOR('gridColor'); //Zero line\n\n  BOOLEAN('zeroEnable');\n  COLOR('zeroLineColor');\n  NUMBER('zeroLineWidth'); //Background\n\n  BOOLEAN('backgroundEnable');\n  COLOR('backgroundColor'); //Update text if necessary\n\n  if (!this._text) {\n    this._text = createText(this.gl, this.bounds, this.labels, this.labelFont, this.ticks, this.tickFont);\n  } else if (this._text && (labelUpdate || ticksUpdate)) {\n    this._text.update(this.bounds, this.labels, this.labelFont, this.ticks, this.tickFont);\n  } //Update lines if necessary\n\n\n  if (this._lines && ticksUpdate) {\n    this._lines.dispose();\n\n    this._lines = null;\n  }\n\n  if (!this._lines) {\n    this._lines = createLines(this.gl, this.bounds, this.ticks);\n  }\n};\n\nfunction OffsetInfo() {\n  this.primalOffset = [0, 0, 0];\n  this.primalMinor = [0, 0, 0];\n  this.mirrorOffset = [0, 0, 0];\n  this.mirrorMinor = [0, 0, 0];\n}\n\nvar LINE_OFFSET = [new OffsetInfo(), new OffsetInfo(), new OffsetInfo()];\n\nfunction computeLineOffset(result, i, bounds, cubeEdges, cubeAxis) {\n  var primalOffset = result.primalOffset;\n  var primalMinor = result.primalMinor;\n  var dualOffset = result.mirrorOffset;\n  var dualMinor = result.mirrorMinor;\n  var e = cubeEdges[i]; //Calculate offsets\n\n  for (var j = 0; j < 3; ++j) {\n    if (i === j) {\n      continue;\n    }\n\n    var a = primalOffset,\n        b = dualOffset,\n        c = primalMinor,\n        d = dualMinor;\n\n    if (e & 1 << j) {\n      a = dualOffset;\n      b = primalOffset;\n      c = dualMinor;\n      d = primalMinor;\n    }\n\n    a[j] = bounds[0][j];\n    b[j] = bounds[1][j];\n\n    if (cubeAxis[j] > 0) {\n      c[j] = -1;\n      d[j] = 0;\n    } else {\n      c[j] = 0;\n      d[j] = +1;\n    }\n  }\n}\n\nvar CUBE_ENABLE = [0, 0, 0];\nvar DEFAULT_PARAMS = {\n  model: identity,\n  view: identity,\n  projection: identity,\n  _ortho: false\n};\n\nproto.isOpaque = function () {\n  return true;\n};\n\nproto.isTransparent = function () {\n  return false;\n};\n\nproto.drawTransparent = function (params) {};\n\nvar ALIGN_OPTION_AUTO = 0; // i.e. as defined in the shader the text would rotate to stay upwards range: [-90,90]\n\nvar PRIMAL_MINOR = [0, 0, 0];\nvar MIRROR_MINOR = [0, 0, 0];\nvar PRIMAL_OFFSET = [0, 0, 0];\n\nproto.draw = function (params) {\n  params = params || DEFAULT_PARAMS;\n  var gl = this.gl; //Geometry for camera and axes\n\n  var model = params.model || identity;\n  var view = params.view || identity;\n  var projection = params.projection || identity;\n  var bounds = this.bounds;\n  var isOrtho = params._ortho || false; //Unpack axis info\n\n  var cubeParams = getCubeProperties(model, view, projection, bounds, isOrtho);\n  var cubeEdges = cubeParams.cubeEdges;\n  var cubeAxis = cubeParams.axis;\n  var cx = view[12];\n  var cy = view[13];\n  var cz = view[14];\n  var cw = view[15];\n  var orthoFix = isOrtho ? 2 : 1; // double up padding for orthographic ticks & labels\n\n  var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl.drawingBufferHeight;\n\n  for (var i = 0; i < 3; ++i) {\n    this.lastCubeProps.cubeEdges[i] = cubeEdges[i];\n    this.lastCubeProps.axis[i] = cubeAxis[i];\n  } //Compute axis info\n\n\n  var lineOffset = LINE_OFFSET;\n\n  for (var i = 0; i < 3; ++i) {\n    computeLineOffset(LINE_OFFSET[i], i, this.bounds, cubeEdges, cubeAxis);\n  } //Set up state parameters\n\n\n  var gl = this.gl; //Draw background first\n\n  var cubeEnable = CUBE_ENABLE;\n\n  for (var i = 0; i < 3; ++i) {\n    if (this.backgroundEnable[i]) {\n      cubeEnable[i] = cubeAxis[i];\n    } else {\n      cubeEnable[i] = 0;\n    }\n  }\n\n  this._background.draw(model, view, projection, bounds, cubeEnable, this.backgroundColor); //Draw lines\n\n\n  this._lines.bind(model, view, projection, this); //First draw grid lines and zero lines\n\n\n  for (var i = 0; i < 3; ++i) {\n    var x = [0, 0, 0];\n\n    if (cubeAxis[i] > 0) {\n      x[i] = bounds[1][i];\n    } else {\n      x[i] = bounds[0][i];\n    } //Draw grid lines\n\n\n    for (var j = 0; j < 2; ++j) {\n      var u = (i + 1 + j) % 3;\n      var v = (i + 1 + (j ^ 1)) % 3;\n\n      if (this.gridEnable[u]) {\n        this._lines.drawGrid(u, v, this.bounds, x, this.gridColor[u], this.gridWidth[u] * this.pixelRatio);\n      }\n    } //Draw zero lines (need to do this AFTER all grid lines are drawn)\n\n\n    for (var j = 0; j < 2; ++j) {\n      var u = (i + 1 + j) % 3;\n      var v = (i + 1 + (j ^ 1)) % 3;\n\n      if (this.zeroEnable[v]) {\n        //Check if zero line in bounds\n        if (Math.min(bounds[0][v], bounds[1][v]) <= 0 && Math.max(bounds[0][v], bounds[1][v]) >= 0) {\n          this._lines.drawZero(u, v, this.bounds, x, this.zeroLineColor[v], this.zeroLineWidth[v] * this.pixelRatio);\n        }\n      }\n    }\n  } //Then draw axis lines and tick marks\n\n\n  for (var i = 0; i < 3; ++i) {\n    //Draw axis lines\n    if (this.lineEnable[i]) {\n      this._lines.drawAxisLine(i, this.bounds, lineOffset[i].primalOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);\n    }\n\n    if (this.lineMirror[i]) {\n      this._lines.drawAxisLine(i, this.bounds, lineOffset[i].mirrorOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);\n    } //Compute minor axes\n\n\n    var primalMinor = copyVec3(PRIMAL_MINOR, lineOffset[i].primalMinor);\n    var mirrorMinor = copyVec3(MIRROR_MINOR, lineOffset[i].mirrorMinor);\n    var tickLength = this.lineTickLength;\n\n    for (var j = 0; j < 3; ++j) {\n      var scaleFactor = pixelScaleF / model[5 * j];\n      primalMinor[j] *= tickLength[j] * scaleFactor;\n      mirrorMinor[j] *= tickLength[j] * scaleFactor;\n    } //Draw axis line ticks\n\n\n    if (this.lineTickEnable[i]) {\n      this._lines.drawAxisTicks(i, lineOffset[i].primalOffset, primalMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);\n    }\n\n    if (this.lineTickMirror[i]) {\n      this._lines.drawAxisTicks(i, lineOffset[i].mirrorOffset, mirrorMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);\n    }\n  }\n\n  this._lines.unbind(); //Draw text sprites\n\n\n  this._text.bind(model, view, projection, this.pixelRatio);\n\n  var alignOpt; // options in shader are from this list {-1, 0, 1, 2, 3, ..., n}\n  // -1: backward compatible\n  //  0: raw data\n  //  1: auto align, free angles\n  //  2: auto align, horizontal or vertical\n  //3-n: auto align, round to n directions e.g. 12 -> round to angles with 30-degree steps\n\n  var hv_ratio = 0.5; // can have an effect on the ratio between horizontals and verticals when using option 2\n\n  var enableAlign;\n  var alignDir;\n\n  function alignTo(i) {\n    alignDir = [0, 0, 0];\n    alignDir[i] = 1;\n  }\n\n  function solveTickAlignments(i, minor, major) {\n    var i1 = (i + 1) % 3;\n    var i2 = (i + 2) % 3;\n    var A = minor[i1];\n    var B = minor[i2];\n    var C = major[i1];\n    var D = major[i2];\n\n    if (A > 0 && D > 0) {\n      alignTo(i1);\n      return;\n    } else if (A > 0 && D < 0) {\n      alignTo(i1);\n      return;\n    } else if (A < 0 && D > 0) {\n      alignTo(i1);\n      return;\n    } else if (A < 0 && D < 0) {\n      alignTo(i1);\n      return;\n    } else if (B > 0 && C > 0) {\n      alignTo(i2);\n      return;\n    } else if (B > 0 && C < 0) {\n      alignTo(i2);\n      return;\n    } else if (B < 0 && C > 0) {\n      alignTo(i2);\n      return;\n    } else if (B < 0 && C < 0) {\n      alignTo(i2);\n      return;\n    }\n  }\n\n  for (var i = 0; i < 3; ++i) {\n    var minor = lineOffset[i].primalMinor;\n    var major = lineOffset[i].mirrorMinor;\n    var offset = copyVec3(PRIMAL_OFFSET, lineOffset[i].primalOffset);\n\n    for (var j = 0; j < 3; ++j) {\n      if (this.lineTickEnable[i]) {\n        offset[j] += pixelScaleF * minor[j] * Math.max(this.lineTickLength[j], 0) / model[5 * j];\n      }\n    }\n\n    var axis = [0, 0, 0];\n    axis[i] = 1; //Draw tick text\n\n    if (this.tickEnable[i]) {\n      if (this.tickAngle[i] === -3600) {\n        this.tickAngle[i] = 0;\n        this.tickAlign[i] = 'auto';\n      } else {\n        this.tickAlign[i] = -1;\n      }\n\n      enableAlign = 1;\n      alignOpt = [this.tickAlign[i], hv_ratio, enableAlign];\n      if (alignOpt[0] === 'auto') alignOpt[0] = ALIGN_OPTION_AUTO;else alignOpt[0] = parseInt('' + alignOpt[0]);\n      alignDir = [0, 0, 0];\n      solveTickAlignments(i, minor, major); //Add tick padding\n\n      for (var j = 0; j < 3; ++j) {\n        offset[j] += pixelScaleF * minor[j] * this.tickPad[j] / model[5 * j];\n      } //Draw axis\n\n\n      this._text.drawTicks(i, this.tickSize[i], this.tickAngle[i], offset, this.tickColor[i], axis, alignDir, alignOpt);\n    } //Draw labels\n\n\n    if (this.labelEnable[i]) {\n      enableAlign = 0;\n      alignDir = [0, 0, 0];\n\n      if (this.labels[i].length > 4) {\n        // for large label axis enable alignDir to axis\n        alignTo(i);\n        enableAlign = 1;\n      }\n\n      alignOpt = [this.labelAlign[i], hv_ratio, enableAlign];\n      if (alignOpt[0] === 'auto') alignOpt[0] = ALIGN_OPTION_AUTO;else alignOpt[0] = parseInt('' + alignOpt[0]); //Add label padding\n\n      for (var j = 0; j < 3; ++j) {\n        offset[j] += pixelScaleF * minor[j] * this.labelPad[j] / model[5 * j];\n      }\n\n      offset[i] += 0.5 * (bounds[0][i] + bounds[1][i]); //Draw axis\n\n      this._text.drawLabel(i, this.labelSize[i], this.labelAngle[i], offset, this.labelColor[i], [0, 0, 0], alignDir, alignOpt);\n    }\n  }\n\n  this._text.unbind();\n};\n\nproto.dispose = function () {\n  this._text.dispose();\n\n  this._lines.dispose();\n\n  this._background.dispose();\n\n  this._lines = null;\n  this._text = null;\n  this._background = null;\n  this.gl = null;\n};\n\nfunction createAxes(gl, options) {\n  var axes = new Axes(gl);\n  axes.update(options);\n  return axes;\n}","map":null,"metadata":{},"sourceType":"script"}