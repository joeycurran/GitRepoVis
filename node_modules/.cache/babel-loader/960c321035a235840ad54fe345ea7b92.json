{"ast":null,"code":"'use strict';\n\nmodule.exports = convexHullnD;\n\nvar ich = require('incremental-convex-hull');\n\nvar aff = require('affine-hull');\n\nfunction permute(points, front) {\n  var n = points.length;\n  var npoints = new Array(n);\n\n  for (var i = 0; i < front.length; ++i) {\n    npoints[i] = points[front[i]];\n  }\n\n  var ptr = front.length;\n\n  for (var i = 0; i < n; ++i) {\n    if (front.indexOf(i) < 0) {\n      npoints[ptr++] = points[i];\n    }\n  }\n\n  return npoints;\n}\n\nfunction invPermute(cells, front) {\n  var nc = cells.length;\n  var nf = front.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      var x = c[j];\n\n      if (x < nf) {\n        c[j] = front[x];\n      } else {\n        x = x - nf;\n\n        for (var k = 0; k < nf; ++k) {\n          if (x >= front[k]) {\n            x += 1;\n          }\n        }\n\n        c[j] = x;\n      }\n    }\n  }\n\n  return cells;\n}\n\nfunction convexHullnD(points, d) {\n  try {\n    return ich(points, true);\n  } catch (e) {\n    //If point set is degenerate, try to find a basis and rerun it\n    var ah = aff(points);\n\n    if (ah.length <= d) {\n      //No basis, no try\n      return [];\n    }\n\n    var npoints = permute(points, ah);\n    var nhull = ich(npoints, true);\n    return invPermute(nhull, ah);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}